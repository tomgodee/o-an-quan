import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  bigint: any;
  citext: any;
  date: any;
  float8: any;
  json: any;
  jsonb: any;
  numeric: any;
  timestamptz: any;
  uuid: any;
};


export type AddParcelTypesInput = {
  empty_weight?: Maybe<Scalars['Float']>;
  height: Scalars['Float'];
  id?: Maybe<Scalars['uuid']>;
  is_default?: Maybe<Scalars['Boolean']>;
  length: Scalars['Float'];
  max_weight?: Maybe<Scalars['Float']>;
  min_weight?: Maybe<Scalars['Float']>;
  name: Scalars['String'];
  store_id: Scalars['uuid'];
  type?: Maybe<Scalars['String']>;
  width: Scalars['Float'];
};

export type AddParcelTypesOutput = {
  count: Scalars['Int'];
};

export type AddShopifyStoreOutput = {
  shopify_integration?: Maybe<Shopify_Integration>;
  shopify_integration_id: Scalars['String'];
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: Maybe<Scalars['Boolean']>;
  _gt?: Maybe<Scalars['Boolean']>;
  _gte?: Maybe<Scalars['Boolean']>;
  _in?: Maybe<Array<Scalars['Boolean']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Boolean']>;
  _lte?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Scalars['Boolean']>;
  _nin?: Maybe<Array<Scalars['Boolean']>>;
};

export type CarrierSettingCommand = {
  payload?: Maybe<Scalars['json']>;
  type: Scalars['String'];
};

export type CarrierSettingCommandOutput = {
  carrierId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['json']>;
  outcome: Scalars['String'];
  storeId?: Maybe<Scalars['String']>;
};

export type CarrierSettingOutput = {
  ATL_AGE_VERIFICATION_REQUIRED: Scalars['Boolean'];
  ATL_AUTHORITY_TO_LEAVE: Scalars['String'];
  ATL_SIGNATURE_REQUIRED: Scalars['Boolean'];
  ATL_UNATTENDED_SAFETY: Scalars['String'];
  carrier?: Maybe<Carrier>;
  carrierId: Scalars['String'];
  carrierName: Scalars['String'];
  provider: Scalars['String'];
  store?: Maybe<Store>;
  storeId: Scalars['String'];
};

export type ConnectShopifyStoreInput = {
  accessToken: Scalars['String'];
  scope: Scalars['String'];
  shopDomain: Scalars['String'];
};

export type ConnectShopifyStoreOutput = {
  error?: Maybe<Scalars['String']>;
  success: Scalars['Boolean'];
};

export type CreateManifestOutput = {
  manifest?: Maybe<Manifest>;
  manifest_id: Scalars['uuid'];
};

export type CreatedSaleOrder = {
  orderReference?: Maybe<Scalars['String']>;
  salesOrderId: Scalars['String'];
};

export type DeleteParcelTypesByIdsInput = {
  ids: Array<Scalars['uuid']>;
  storeId: Scalars['uuid'];
};

export type DeleteParcelTypesByIdsOutput = {
  errors: Array<Scalars['String']>;
  success: Scalars['Boolean'];
};

export type EditAddressInput = {
  administrativeAreaLevel1?: Maybe<Scalars['String']>;
  administrativeAreaLevel2?: Maybe<Scalars['String']>;
  administrativeAreaLevel3?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  countryCode?: Maybe<Scalars['String']>;
  line1?: Maybe<Scalars['String']>;
  line2?: Maybe<Scalars['String']>;
  locality?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  postalCode?: Maybe<Scalars['String']>;
};

export type EditAddressOutput = {
  address?: Maybe<Address>;
  errors?: Maybe<Array<Maybe<Scalars['String']>>>;
  id?: Maybe<Scalars['uuid']>;
  success: Scalars['Boolean'];
};

export type EditParcelTypeInput = {
  empty_weight?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_default?: Maybe<Scalars['Boolean']>;
  length?: Maybe<Scalars['Float']>;
  max_weight?: Maybe<Scalars['Float']>;
  min_weight?: Maybe<Scalars['Float']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Float']>;
};

export type EditParcelTypeOutput = {
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_default?: Maybe<Scalars['Boolean']>;
  parcel_type?: Maybe<Parcel_Type>;
};

export type EditProductVariantPackagesInput = {
  barcode?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Float']>;
  id: Scalars['uuid'];
  length?: Maybe<Scalars['Float']>;
  sku?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

export type EditProductVariantPackagesOutput = {
  barcode: Scalars['String'];
  description: Scalars['String'];
  height: Scalars['Float'];
  id: Scalars['uuid'];
  length: Scalars['Float'];
  product_variant_id: Scalars['uuid'];
  sku: Scalars['String'];
  title: Scalars['String'];
  weight: Scalars['Float'];
  width: Scalars['Float'];
};

export type EditStoreInput = {
  carrierSelectionPref: Scalars['String'];
};

export type EditStoreOutput = {
  errors: Array<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  success: Scalars['Boolean'];
};

export type FailedSaleOrder = {
  orderReference: Scalars['String'];
  reason: Scalars['String'];
  salesOrderId?: Maybe<Scalars['String']>;
};

export type FulfilmentShipmentCommand = {
  payload?: Maybe<Scalars['json']>;
  type: Scalars['String'];
};

export type FulfilmentShipmentCommandOutput = {
  draft_fulfilment_shipment?: Maybe<Draft_Fulfilment_Shipment>;
  error?: Maybe<Scalars['json']>;
  fulfilmentShipmentId?: Maybe<Scalars['String']>;
  outcome: Scalars['String'];
};

export type FulfilmentShipmentParcelInput = {
  empty_weight_gram?: Maybe<Scalars['Int']>;
  fulfilment_shipment_id: Scalars['uuid'];
  height_mm?: Maybe<Scalars['Int']>;
  id: Scalars['uuid'];
  length_mm?: Maybe<Scalars['Int']>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  type: Scalars['String'];
  weight_gram: Scalars['Int'];
  width_mm?: Maybe<Scalars['Int']>;
};

export type FulfilmentShipmentsCommand = {
  payload?: Maybe<Scalars['json']>;
  type: Scalars['String'];
};

export type FulfilmentShipmentsCommandOutput = {
  error?: Maybe<Scalars['json']>;
  outcome: Scalars['String'];
  result?: Maybe<Scalars['json']>;
};

export type GetShippingRatesOutput = {
  errors?: Maybe<Array<Scalars['String']>>;
  rateRequestId?: Maybe<Scalars['uuid']>;
  shippingRates: Array<Shipping_Rate>;
  shippingRates_aggregate: Shipping_Rate_Aggregate;
};


export type GetShippingRatesOutputShippingRatesArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


export type GetShippingRatesOutputShippingRates_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};

export type GetShopifyAccessToken = {
  shopAccessToken: Scalars['String'];
  shopDomain: Scalars['String'];
};

export type GetShopifyAccessTokensOutput = {
  shops: Array<GetShopifyAccessToken>;
};

export type GetShopifyStoreOutput = {
  connected_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  scope?: Maybe<Scalars['String']>;
};

export type InitiateShopifyInventorySyncOutput = {
  error?: Maybe<Scalars['String']>;
  inventorySyncJobId?: Maybe<Scalars['Float']>;
  success: Scalars['Boolean'];
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: Maybe<Scalars['Int']>;
  _gt?: Maybe<Scalars['Int']>;
  _gte?: Maybe<Scalars['Int']>;
  _in?: Maybe<Array<Scalars['Int']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Int']>;
  _lte?: Maybe<Scalars['Int']>;
  _neq?: Maybe<Scalars['Int']>;
  _nin?: Maybe<Array<Scalars['Int']>>;
};

export type PackLineItemsInput = {
  ids: Array<Scalars['uuid']>;
  salesOrderId: Scalars['uuid'];
};

export type PackLineItemsOutput = {
  errors?: Maybe<Array<Maybe<Scalars['String']>>>;
  success: Scalars['Boolean'];
};

export type RatesShipment = {
  customsInfo?: Maybe<Array<ShipmentCustomsInfo>>;
  fromAddress: RatesShipmentAddress;
  parcels: Array<RatesShipmentParcel>;
  toAddress: RatesShipmentAddress;
  warehouseId?: Maybe<Scalars['String']>;
};

export type RatesShipmentAddress = {
  administrativeAreaLevel1?: Maybe<Scalars['String']>;
  administrativeAreaLevel2?: Maybe<Scalars['String']>;
  administrativeAreaLevel3?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  countryCode?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  line1?: Maybe<Scalars['String']>;
  line2?: Maybe<Scalars['String']>;
  locality?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['uuid']>;
  longitude?: Maybe<Scalars['Float']>;
  name?: Maybe<Scalars['String']>;
  postalCode?: Maybe<Scalars['String']>;
};

export type RatesShipmentParcel = {
  emptyWeight?: Maybe<Scalars['Float']>;
  height: Scalars['Float'];
  length: Scalars['Float'];
  parcelType?: Maybe<Scalars['String']>;
  weight: Scalars['Float'];
  width: Scalars['Float'];
};

export type SalesOrderCommand = {
  payload?: Maybe<Scalars['json']>;
  type: Scalars['String'];
};

export type SalesOrderCommandOutput = {
  error?: Maybe<Scalars['json']>;
  outcome: Scalars['String'];
  salesOrder?: Maybe<Sales_Order>;
  salesOrderId?: Maybe<Scalars['Float']>;
};

export type SalesOrdersCommand = {
  payload?: Maybe<Scalars['json']>;
  type: Scalars['String'];
};

export type SalesOrdersCommandOutput = {
  error?: Maybe<Scalars['json']>;
  outcome: Scalars['String'];
  result?: Maybe<SalesOrdersCommandResult>;
  url?: Maybe<Scalars['String']>;
};

export type SalesOrdersCommandResult = {
  createdSalesOrders?: Maybe<Array<Maybe<CreatedSaleOrder>>>;
  failedSalesOrders?: Maybe<Array<Maybe<FailedSaleOrder>>>;
};

export type SelectShippingRateOutput = {
  errors: Array<Scalars['String']>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  success: Scalars['Boolean'];
};

export type ShipEngineTrackingHandlerOutput = {
  success: Scalars['Boolean'];
};

export type ShipmentCustomsInfo = {
  countryOfOrigin: Scalars['String'];
  currency: Scalars['String'];
  harmonizedCode: Scalars['String'];
  price: Scalars['Int'];
  productDescription: Scalars['String'];
  quantity: Scalars['Int'];
  sku: Scalars['String'];
  skuDescription: Scalars['String'];
};

export type ShippingWebhookHandlerOutput = {
  success: Scalars['Boolean'];
};

export type ShippingWebhookShiptopiaInput = {
  data: Scalars['String'];
  time: Scalars['String'];
  type: Scalars['String'];
};

export type ShopifyWebhookHandlerInput = {
  payload: Scalars['String'];
  shopDomain: Scalars['String'];
  topic: Scalars['String'];
};

export type ShopifyWebhookHandlerOutput = {
  success: Scalars['Boolean'];
};

export type StockTransferCommand = {
  payload?: Maybe<Scalars['json']>;
  type: Scalars['String'];
};

export type StockTransferCommandOutput = {
  error?: Maybe<Scalars['json']>;
  outcome: Scalars['String'];
  stockTransfer?: Maybe<Stock_Transfer>;
  stockTransferId?: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: Maybe<Scalars['String']>;
  _gt?: Maybe<Scalars['String']>;
  _gte?: Maybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: Maybe<Scalars['String']>;
  _in?: Maybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: Maybe<Scalars['String']>;
  _is_null?: Maybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: Maybe<Scalars['String']>;
  _lt?: Maybe<Scalars['String']>;
  _lte?: Maybe<Scalars['String']>;
  _neq?: Maybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: Maybe<Scalars['String']>;
  _nin?: Maybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: Maybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: Maybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: Maybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: Maybe<Scalars['String']>;
};

export type SyncProductsOutput = {
  job_ids: Array<Scalars['String']>;
};

export type SyncSalesOrderOutput = {
  sales_order?: Maybe<Sales_Order>;
  sales_order_id: Scalars['uuid'];
};

export type TestOrderCommand = {
  payload?: Maybe<Scalars['json']>;
  type: Scalars['String'];
};

export type TestOrderCommandOutput = {
  error?: Maybe<Scalars['json']>;
  outcome: Scalars['String'];
  sales_orders?: Maybe<Array<Maybe<CreatedSaleOrder>>>;
};

export type UpsertFulfilmentShipmentParcelOutput = {
  errors: Array<Scalars['String']>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  success: Scalars['Boolean'];
};

/** columns and relationships of "address" */
export type Address = {
  administrative_area_level_1?: Maybe<Scalars['String']>;
  administrative_area_level_2?: Maybe<Scalars['String']>;
  administrative_area_level_3?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  contact_number?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  /** An array relationship */
  customers: Array<Customer>;
  /** An aggregate relationship */
  customers_aggregate: Customer_Aggregate;
  email?: Maybe<Scalars['String']>;
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  id: Scalars['uuid'];
  is_fulfilment_center: Scalars['Boolean'];
  latitude?: Maybe<Scalars['float8']>;
  line_1?: Maybe<Scalars['String']>;
  line_2?: Maybe<Scalars['String']>;
  locality?: Maybe<Scalars['String']>;
  /** An array relationship */
  locations: Array<Location>;
  /** An aggregate relationship */
  locations_aggregate: Location_Aggregate;
  longitude?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  postal_code?: Maybe<Scalars['String']>;
  /** An array relationship */
  salesOrdersByBillingAddressId: Array<Sales_Order>;
  /** An aggregate relationship */
  salesOrdersByBillingAddressId_aggregate: Sales_Order_Aggregate;
  /** An array relationship */
  sales_orders: Array<Sales_Order>;
  /** An aggregate relationship */
  sales_orders_aggregate: Sales_Order_Aggregate;
  /** An object relationship */
  store?: Maybe<Store>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "address" */
export type AddressCustomersArgs = {
  distinct_on?: Maybe<Array<Customer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Order_By>>;
  where?: Maybe<Customer_Bool_Exp>;
};


/** columns and relationships of "address" */
export type AddressCustomers_AggregateArgs = {
  distinct_on?: Maybe<Array<Customer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Order_By>>;
  where?: Maybe<Customer_Bool_Exp>;
};


/** columns and relationships of "address" */
export type AddressFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "address" */
export type AddressFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "address" */
export type AddressLocationsArgs = {
  distinct_on?: Maybe<Array<Location_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Location_Order_By>>;
  where?: Maybe<Location_Bool_Exp>;
};


/** columns and relationships of "address" */
export type AddressLocations_AggregateArgs = {
  distinct_on?: Maybe<Array<Location_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Location_Order_By>>;
  where?: Maybe<Location_Bool_Exp>;
};


/** columns and relationships of "address" */
export type AddressSalesOrdersByBillingAddressIdArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "address" */
export type AddressSalesOrdersByBillingAddressId_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "address" */
export type AddressSales_OrdersArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "address" */
export type AddressSales_Orders_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};

/** aggregated selection of "address" */
export type Address_Aggregate = {
  aggregate?: Maybe<Address_Aggregate_Fields>;
  nodes: Array<Address>;
};

export type Address_Aggregate_Bool_Exp = {
  avg?: Maybe<Address_Aggregate_Bool_Exp_Avg>;
  bool_and?: Maybe<Address_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Address_Aggregate_Bool_Exp_Bool_Or>;
  corr?: Maybe<Address_Aggregate_Bool_Exp_Corr>;
  count?: Maybe<Address_Aggregate_Bool_Exp_Count>;
  covar_samp?: Maybe<Address_Aggregate_Bool_Exp_Covar_Samp>;
  max?: Maybe<Address_Aggregate_Bool_Exp_Max>;
  min?: Maybe<Address_Aggregate_Bool_Exp_Min>;
  stddev_samp?: Maybe<Address_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: Maybe<Address_Aggregate_Bool_Exp_Sum>;
  var_samp?: Maybe<Address_Aggregate_Bool_Exp_Var_Samp>;
};

export type Address_Aggregate_Bool_Exp_Avg = {
  arguments: Address_Select_Column_Address_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Bool_And = {
  arguments: Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Corr = {
  arguments: Address_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Address_Select_Column_Address_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Address_Select_Column_Address_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Address_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Address_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Address_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Address_Select_Column_Address_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Address_Select_Column_Address_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Address_Aggregate_Bool_Exp_Max = {
  arguments: Address_Select_Column_Address_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Min = {
  arguments: Address_Select_Column_Address_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Address_Select_Column_Address_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Sum = {
  arguments: Address_Select_Column_Address_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Address_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Address_Select_Column_Address_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Address_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "address" */
export type Address_Aggregate_Fields = {
  avg?: Maybe<Address_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Address_Max_Fields>;
  min?: Maybe<Address_Min_Fields>;
  stddev?: Maybe<Address_Stddev_Fields>;
  stddev_pop?: Maybe<Address_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Address_Stddev_Samp_Fields>;
  sum?: Maybe<Address_Sum_Fields>;
  var_pop?: Maybe<Address_Var_Pop_Fields>;
  var_samp?: Maybe<Address_Var_Samp_Fields>;
  variance?: Maybe<Address_Variance_Fields>;
};


/** aggregate fields of "address" */
export type Address_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Address_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "address" */
export type Address_Aggregate_Order_By = {
  avg?: Maybe<Address_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Address_Max_Order_By>;
  min?: Maybe<Address_Min_Order_By>;
  stddev?: Maybe<Address_Stddev_Order_By>;
  stddev_pop?: Maybe<Address_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Address_Stddev_Samp_Order_By>;
  sum?: Maybe<Address_Sum_Order_By>;
  var_pop?: Maybe<Address_Var_Pop_Order_By>;
  var_samp?: Maybe<Address_Var_Samp_Order_By>;
  variance?: Maybe<Address_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "address" */
export type Address_Arr_Rel_Insert_Input = {
  data: Array<Address_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Address_On_Conflict>;
};

/** aggregate avg on columns */
export type Address_Avg_Fields = {
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "address" */
export type Address_Avg_Order_By = {
  latitude?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "address". All fields are combined with a logical 'AND'. */
export type Address_Bool_Exp = {
  _and?: Maybe<Array<Address_Bool_Exp>>;
  _not?: Maybe<Address_Bool_Exp>;
  _or?: Maybe<Array<Address_Bool_Exp>>;
  administrative_area_level_1?: Maybe<String_Comparison_Exp>;
  administrative_area_level_2?: Maybe<String_Comparison_Exp>;
  administrative_area_level_3?: Maybe<String_Comparison_Exp>;
  company?: Maybe<String_Comparison_Exp>;
  contact_number?: Maybe<String_Comparison_Exp>;
  country_code?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customers?: Maybe<Customer_Bool_Exp>;
  customers_aggregate?: Maybe<Customer_Aggregate_Bool_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_fulfilment_center?: Maybe<Boolean_Comparison_Exp>;
  latitude?: Maybe<Float8_Comparison_Exp>;
  line_1?: Maybe<String_Comparison_Exp>;
  line_2?: Maybe<String_Comparison_Exp>;
  locality?: Maybe<String_Comparison_Exp>;
  locations?: Maybe<Location_Bool_Exp>;
  locations_aggregate?: Maybe<Location_Aggregate_Bool_Exp>;
  longitude?: Maybe<Float8_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  postal_code?: Maybe<String_Comparison_Exp>;
  salesOrdersByBillingAddressId?: Maybe<Sales_Order_Bool_Exp>;
  salesOrdersByBillingAddressId_aggregate?: Maybe<Sales_Order_Aggregate_Bool_Exp>;
  sales_orders?: Maybe<Sales_Order_Bool_Exp>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Bool_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "address" */
export const Address_Constraint = {
  /** unique or primary key constraint on columns "id" */
  AddressPkey: 'address_pkey'
} as const;

export type Address_Constraint = typeof Address_Constraint[keyof typeof Address_Constraint];
/** input type for incrementing numeric columns in table "address" */
export type Address_Inc_Input = {
  latitude?: Maybe<Scalars['float8']>;
  longitude?: Maybe<Scalars['float8']>;
};

/** input type for inserting data into table "address" */
export type Address_Insert_Input = {
  administrative_area_level_1?: Maybe<Scalars['String']>;
  administrative_area_level_2?: Maybe<Scalars['String']>;
  administrative_area_level_3?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  contact_number?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customers?: Maybe<Customer_Arr_Rel_Insert_Input>;
  email?: Maybe<Scalars['String']>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  is_fulfilment_center?: Maybe<Scalars['Boolean']>;
  latitude?: Maybe<Scalars['float8']>;
  line_1?: Maybe<Scalars['String']>;
  line_2?: Maybe<Scalars['String']>;
  locality?: Maybe<Scalars['String']>;
  locations?: Maybe<Location_Arr_Rel_Insert_Input>;
  longitude?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  postal_code?: Maybe<Scalars['String']>;
  salesOrdersByBillingAddressId?: Maybe<Sales_Order_Arr_Rel_Insert_Input>;
  sales_orders?: Maybe<Sales_Order_Arr_Rel_Insert_Input>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Address_Max_Fields = {
  administrative_area_level_1?: Maybe<Scalars['String']>;
  administrative_area_level_2?: Maybe<Scalars['String']>;
  administrative_area_level_3?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  contact_number?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  latitude?: Maybe<Scalars['float8']>;
  line_1?: Maybe<Scalars['String']>;
  line_2?: Maybe<Scalars['String']>;
  locality?: Maybe<Scalars['String']>;
  longitude?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  postal_code?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "address" */
export type Address_Max_Order_By = {
  administrative_area_level_1?: Maybe<Order_By>;
  administrative_area_level_2?: Maybe<Order_By>;
  administrative_area_level_3?: Maybe<Order_By>;
  company?: Maybe<Order_By>;
  contact_number?: Maybe<Order_By>;
  country_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  latitude?: Maybe<Order_By>;
  line_1?: Maybe<Order_By>;
  line_2?: Maybe<Order_By>;
  locality?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  postal_code?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Address_Min_Fields = {
  administrative_area_level_1?: Maybe<Scalars['String']>;
  administrative_area_level_2?: Maybe<Scalars['String']>;
  administrative_area_level_3?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  contact_number?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  latitude?: Maybe<Scalars['float8']>;
  line_1?: Maybe<Scalars['String']>;
  line_2?: Maybe<Scalars['String']>;
  locality?: Maybe<Scalars['String']>;
  longitude?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  postal_code?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "address" */
export type Address_Min_Order_By = {
  administrative_area_level_1?: Maybe<Order_By>;
  administrative_area_level_2?: Maybe<Order_By>;
  administrative_area_level_3?: Maybe<Order_By>;
  company?: Maybe<Order_By>;
  contact_number?: Maybe<Order_By>;
  country_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  latitude?: Maybe<Order_By>;
  line_1?: Maybe<Order_By>;
  line_2?: Maybe<Order_By>;
  locality?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  postal_code?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "address" */
export type Address_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Address>;
};

/** input type for inserting object relation for remote table "address" */
export type Address_Obj_Rel_Insert_Input = {
  data: Address_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Address_On_Conflict>;
};

/** on_conflict condition type for table "address" */
export type Address_On_Conflict = {
  constraint: Address_Constraint;
  update_columns?: Array<Address_Update_Column>;
  where?: Maybe<Address_Bool_Exp>;
};

/** Ordering options when selecting data from "address". */
export type Address_Order_By = {
  administrative_area_level_1?: Maybe<Order_By>;
  administrative_area_level_2?: Maybe<Order_By>;
  administrative_area_level_3?: Maybe<Order_By>;
  company?: Maybe<Order_By>;
  contact_number?: Maybe<Order_By>;
  country_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customers_aggregate?: Maybe<Customer_Aggregate_Order_By>;
  email?: Maybe<Order_By>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  is_fulfilment_center?: Maybe<Order_By>;
  latitude?: Maybe<Order_By>;
  line_1?: Maybe<Order_By>;
  line_2?: Maybe<Order_By>;
  locality?: Maybe<Order_By>;
  locations_aggregate?: Maybe<Location_Aggregate_Order_By>;
  longitude?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  postal_code?: Maybe<Order_By>;
  salesOrdersByBillingAddressId_aggregate?: Maybe<Sales_Order_Aggregate_Order_By>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: address */
export type Address_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "address" */
export const Address_Select_Column = {
  /** column name */
  AdministrativeAreaLevel_1: 'administrative_area_level_1',
  /** column name */
  AdministrativeAreaLevel_2: 'administrative_area_level_2',
  /** column name */
  AdministrativeAreaLevel_3: 'administrative_area_level_3',
  /** column name */
  Company: 'company',
  /** column name */
  ContactNumber: 'contact_number',
  /** column name */
  CountryCode: 'country_code',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Email: 'email',
  /** column name */
  Id: 'id',
  /** column name */
  IsFulfilmentCenter: 'is_fulfilment_center',
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Line_1: 'line_1',
  /** column name */
  Line_2: 'line_2',
  /** column name */
  Locality: 'locality',
  /** column name */
  Longitude: 'longitude',
  /** column name */
  Name: 'name',
  /** column name */
  PostalCode: 'postal_code',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Address_Select_Column = typeof Address_Select_Column[keyof typeof Address_Select_Column];
/** select "address_aggregate_bool_exp_avg_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Avg_Arguments_Columns = {
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Longitude: 'longitude'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Avg_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Avg_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Avg_Arguments_Columns];
/** select "address_aggregate_bool_exp_bool_and_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  IsFulfilmentCenter: 'is_fulfilment_center'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "address_aggregate_bool_exp_bool_or_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  IsFulfilmentCenter: 'is_fulfilment_center'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** select "address_aggregate_bool_exp_corr_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Corr_Arguments_Columns = {
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Longitude: 'longitude'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Corr_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Corr_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Corr_Arguments_Columns];
/** select "address_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns = {
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Longitude: 'longitude'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns];
/** select "address_aggregate_bool_exp_max_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Max_Arguments_Columns = {
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Longitude: 'longitude'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Max_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Max_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Max_Arguments_Columns];
/** select "address_aggregate_bool_exp_min_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Min_Arguments_Columns = {
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Longitude: 'longitude'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Min_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Min_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Min_Arguments_Columns];
/** select "address_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns = {
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Longitude: 'longitude'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns];
/** select "address_aggregate_bool_exp_sum_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Sum_Arguments_Columns = {
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Longitude: 'longitude'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Sum_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Sum_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Sum_Arguments_Columns];
/** select "address_aggregate_bool_exp_var_samp_arguments_columns" columns of table "address" */
export const Address_Select_Column_Address_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns = {
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Longitude: 'longitude'
} as const;

export type Address_Select_Column_Address_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns = typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns[keyof typeof Address_Select_Column_Address_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns];
/** input type for updating data in table "address" */
export type Address_Set_Input = {
  administrative_area_level_1?: Maybe<Scalars['String']>;
  administrative_area_level_2?: Maybe<Scalars['String']>;
  administrative_area_level_3?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  contact_number?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_fulfilment_center?: Maybe<Scalars['Boolean']>;
  latitude?: Maybe<Scalars['float8']>;
  line_1?: Maybe<Scalars['String']>;
  line_2?: Maybe<Scalars['String']>;
  locality?: Maybe<Scalars['String']>;
  longitude?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  postal_code?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Address_Stddev_Fields = {
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "address" */
export type Address_Stddev_Order_By = {
  latitude?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Address_Stddev_Pop_Fields = {
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "address" */
export type Address_Stddev_Pop_Order_By = {
  latitude?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Address_Stddev_Samp_Fields = {
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "address" */
export type Address_Stddev_Samp_Order_By = {
  latitude?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
};

/** Streaming cursor of the table "address" */
export type Address_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Address_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Address_Stream_Cursor_Value_Input = {
  administrative_area_level_1?: Maybe<Scalars['String']>;
  administrative_area_level_2?: Maybe<Scalars['String']>;
  administrative_area_level_3?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  contact_number?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_fulfilment_center?: Maybe<Scalars['Boolean']>;
  latitude?: Maybe<Scalars['float8']>;
  line_1?: Maybe<Scalars['String']>;
  line_2?: Maybe<Scalars['String']>;
  locality?: Maybe<Scalars['String']>;
  longitude?: Maybe<Scalars['float8']>;
  name?: Maybe<Scalars['String']>;
  postal_code?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Address_Sum_Fields = {
  latitude?: Maybe<Scalars['float8']>;
  longitude?: Maybe<Scalars['float8']>;
};

/** order by sum() on columns of table "address" */
export type Address_Sum_Order_By = {
  latitude?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
};

/** columns and relationships of "address_type" */
export type Address_Type = {
  value: Scalars['String'];
};

/** aggregated selection of "address_type" */
export type Address_Type_Aggregate = {
  aggregate?: Maybe<Address_Type_Aggregate_Fields>;
  nodes: Array<Address_Type>;
};

/** aggregate fields of "address_type" */
export type Address_Type_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Address_Type_Max_Fields>;
  min?: Maybe<Address_Type_Min_Fields>;
};


/** aggregate fields of "address_type" */
export type Address_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Address_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "address_type". All fields are combined with a logical 'AND'. */
export type Address_Type_Bool_Exp = {
  _and?: Maybe<Array<Address_Type_Bool_Exp>>;
  _not?: Maybe<Address_Type_Bool_Exp>;
  _or?: Maybe<Array<Address_Type_Bool_Exp>>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "address_type" */
export const Address_Type_Constraint = {
  /** unique or primary key constraint on columns "value" */
  AddressTypePkey: 'address_type_pkey'
} as const;

export type Address_Type_Constraint = typeof Address_Type_Constraint[keyof typeof Address_Type_Constraint];
/** input type for inserting data into table "address_type" */
export type Address_Type_Insert_Input = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Address_Type_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Address_Type_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "address_type" */
export type Address_Type_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Address_Type>;
};

/** on_conflict condition type for table "address_type" */
export type Address_Type_On_Conflict = {
  constraint: Address_Type_Constraint;
  update_columns?: Array<Address_Type_Update_Column>;
  where?: Maybe<Address_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "address_type". */
export type Address_Type_Order_By = {
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: address_type */
export type Address_Type_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "address_type" */
export const Address_Type_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Address_Type_Select_Column = typeof Address_Type_Select_Column[keyof typeof Address_Type_Select_Column];
/** input type for updating data in table "address_type" */
export type Address_Type_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "address_type" */
export type Address_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Address_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Address_Type_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "address_type" */
export const Address_Type_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Address_Type_Update_Column = typeof Address_Type_Update_Column[keyof typeof Address_Type_Update_Column];
export type Address_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Address_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Address_Type_Bool_Exp;
};

/** update columns of table "address" */
export const Address_Update_Column = {
  /** column name */
  AdministrativeAreaLevel_1: 'administrative_area_level_1',
  /** column name */
  AdministrativeAreaLevel_2: 'administrative_area_level_2',
  /** column name */
  AdministrativeAreaLevel_3: 'administrative_area_level_3',
  /** column name */
  Company: 'company',
  /** column name */
  ContactNumber: 'contact_number',
  /** column name */
  CountryCode: 'country_code',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Email: 'email',
  /** column name */
  Id: 'id',
  /** column name */
  IsFulfilmentCenter: 'is_fulfilment_center',
  /** column name */
  Latitude: 'latitude',
  /** column name */
  Line_1: 'line_1',
  /** column name */
  Line_2: 'line_2',
  /** column name */
  Locality: 'locality',
  /** column name */
  Longitude: 'longitude',
  /** column name */
  Name: 'name',
  /** column name */
  PostalCode: 'postal_code',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Address_Update_Column = typeof Address_Update_Column[keyof typeof Address_Update_Column];
export type Address_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Address_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Address_Set_Input>;
  /** filter the rows which have to be updated */
  where: Address_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Address_Var_Pop_Fields = {
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "address" */
export type Address_Var_Pop_Order_By = {
  latitude?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Address_Var_Samp_Fields = {
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "address" */
export type Address_Var_Samp_Order_By = {
  latitude?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Address_Variance_Fields = {
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "address" */
export type Address_Variance_Order_By = {
  latitude?: Maybe<Order_By>;
  longitude?: Maybe<Order_By>;
};

/** columns and relationships of "auth.account_providers" */
export type Auth_Account_Providers = {
  /** An object relationship */
  account: Auth_Accounts;
  account_id: Scalars['uuid'];
  auth_provider: Scalars['String'];
  auth_provider_unique_id: Scalars['String'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  provider: Auth_Providers;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "auth.account_providers" */
export type Auth_Account_Providers_Aggregate = {
  aggregate?: Maybe<Auth_Account_Providers_Aggregate_Fields>;
  nodes: Array<Auth_Account_Providers>;
};

export type Auth_Account_Providers_Aggregate_Bool_Exp = {
  count?: Maybe<Auth_Account_Providers_Aggregate_Bool_Exp_Count>;
};

export type Auth_Account_Providers_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Auth_Account_Providers_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.account_providers" */
export type Auth_Account_Providers_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Auth_Account_Providers_Max_Fields>;
  min?: Maybe<Auth_Account_Providers_Min_Fields>;
};


/** aggregate fields of "auth.account_providers" */
export type Auth_Account_Providers_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.account_providers" */
export type Auth_Account_Providers_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Auth_Account_Providers_Max_Order_By>;
  min?: Maybe<Auth_Account_Providers_Min_Order_By>;
};

/** input type for inserting array relation for remote table "auth.account_providers" */
export type Auth_Account_Providers_Arr_Rel_Insert_Input = {
  data: Array<Auth_Account_Providers_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Auth_Account_Providers_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.account_providers". All fields are combined with a logical 'AND'. */
export type Auth_Account_Providers_Bool_Exp = {
  _and?: Maybe<Array<Auth_Account_Providers_Bool_Exp>>;
  _not?: Maybe<Auth_Account_Providers_Bool_Exp>;
  _or?: Maybe<Array<Auth_Account_Providers_Bool_Exp>>;
  account?: Maybe<Auth_Accounts_Bool_Exp>;
  account_id?: Maybe<Uuid_Comparison_Exp>;
  auth_provider?: Maybe<String_Comparison_Exp>;
  auth_provider_unique_id?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  provider?: Maybe<Auth_Providers_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.account_providers" */
export const Auth_Account_Providers_Constraint = {
  /** unique or primary key constraint on columns "auth_provider", "account_id" */
  AccountProvidersAccountIdAuthProviderKey: 'account_providers_account_id_auth_provider_key',
  /** unique or primary key constraint on columns "auth_provider", "auth_provider_unique_id" */
  AccountProvidersAuthProviderAuthProviderUniqueIdKey: 'account_providers_auth_provider_auth_provider_unique_id_key',
  /** unique or primary key constraint on columns "id" */
  AccountProvidersPkey: 'account_providers_pkey'
} as const;

export type Auth_Account_Providers_Constraint = typeof Auth_Account_Providers_Constraint[keyof typeof Auth_Account_Providers_Constraint];
/** input type for inserting data into table "auth.account_providers" */
export type Auth_Account_Providers_Insert_Input = {
  account?: Maybe<Auth_Accounts_Obj_Rel_Insert_Input>;
  account_id?: Maybe<Scalars['uuid']>;
  auth_provider?: Maybe<Scalars['String']>;
  auth_provider_unique_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  provider?: Maybe<Auth_Providers_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Auth_Account_Providers_Max_Fields = {
  account_id?: Maybe<Scalars['uuid']>;
  auth_provider?: Maybe<Scalars['String']>;
  auth_provider_unique_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "auth.account_providers" */
export type Auth_Account_Providers_Max_Order_By = {
  account_id?: Maybe<Order_By>;
  auth_provider?: Maybe<Order_By>;
  auth_provider_unique_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Auth_Account_Providers_Min_Fields = {
  account_id?: Maybe<Scalars['uuid']>;
  auth_provider?: Maybe<Scalars['String']>;
  auth_provider_unique_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "auth.account_providers" */
export type Auth_Account_Providers_Min_Order_By = {
  account_id?: Maybe<Order_By>;
  auth_provider?: Maybe<Order_By>;
  auth_provider_unique_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "auth.account_providers" */
export type Auth_Account_Providers_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Auth_Account_Providers>;
};

/** on_conflict condition type for table "auth.account_providers" */
export type Auth_Account_Providers_On_Conflict = {
  constraint: Auth_Account_Providers_Constraint;
  update_columns?: Array<Auth_Account_Providers_Update_Column>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.account_providers". */
export type Auth_Account_Providers_Order_By = {
  account?: Maybe<Auth_Accounts_Order_By>;
  account_id?: Maybe<Order_By>;
  auth_provider?: Maybe<Order_By>;
  auth_provider_unique_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  provider?: Maybe<Auth_Providers_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: auth.account_providers */
export type Auth_Account_Providers_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "auth.account_providers" */
export const Auth_Account_Providers_Select_Column = {
  /** column name */
  AccountId: 'account_id',
  /** column name */
  AuthProvider: 'auth_provider',
  /** column name */
  AuthProviderUniqueId: 'auth_provider_unique_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Auth_Account_Providers_Select_Column = typeof Auth_Account_Providers_Select_Column[keyof typeof Auth_Account_Providers_Select_Column];
/** input type for updating data in table "auth.account_providers" */
export type Auth_Account_Providers_Set_Input = {
  account_id?: Maybe<Scalars['uuid']>;
  auth_provider?: Maybe<Scalars['String']>;
  auth_provider_unique_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "auth_account_providers" */
export type Auth_Account_Providers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Auth_Account_Providers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Auth_Account_Providers_Stream_Cursor_Value_Input = {
  account_id?: Maybe<Scalars['uuid']>;
  auth_provider?: Maybe<Scalars['String']>;
  auth_provider_unique_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "auth.account_providers" */
export const Auth_Account_Providers_Update_Column = {
  /** column name */
  AccountId: 'account_id',
  /** column name */
  AuthProvider: 'auth_provider',
  /** column name */
  AuthProviderUniqueId: 'auth_provider_unique_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Auth_Account_Providers_Update_Column = typeof Auth_Account_Providers_Update_Column[keyof typeof Auth_Account_Providers_Update_Column];
export type Auth_Account_Providers_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Auth_Account_Providers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Auth_Account_Providers_Bool_Exp;
};

/** columns and relationships of "auth.account_roles" */
export type Auth_Account_Roles = {
  /** An object relationship */
  account: Auth_Accounts;
  account_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  role: Scalars['String'];
  /** An object relationship */
  role_by_role: Auth_Roles;
};

/** aggregated selection of "auth.account_roles" */
export type Auth_Account_Roles_Aggregate = {
  aggregate?: Maybe<Auth_Account_Roles_Aggregate_Fields>;
  nodes: Array<Auth_Account_Roles>;
};

export type Auth_Account_Roles_Aggregate_Bool_Exp = {
  count?: Maybe<Auth_Account_Roles_Aggregate_Bool_Exp_Count>;
};

export type Auth_Account_Roles_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Auth_Account_Roles_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.account_roles" */
export type Auth_Account_Roles_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Auth_Account_Roles_Max_Fields>;
  min?: Maybe<Auth_Account_Roles_Min_Fields>;
};


/** aggregate fields of "auth.account_roles" */
export type Auth_Account_Roles_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.account_roles" */
export type Auth_Account_Roles_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Auth_Account_Roles_Max_Order_By>;
  min?: Maybe<Auth_Account_Roles_Min_Order_By>;
};

/** input type for inserting array relation for remote table "auth.account_roles" */
export type Auth_Account_Roles_Arr_Rel_Insert_Input = {
  data: Array<Auth_Account_Roles_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Auth_Account_Roles_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.account_roles". All fields are combined with a logical 'AND'. */
export type Auth_Account_Roles_Bool_Exp = {
  _and?: Maybe<Array<Auth_Account_Roles_Bool_Exp>>;
  _not?: Maybe<Auth_Account_Roles_Bool_Exp>;
  _or?: Maybe<Array<Auth_Account_Roles_Bool_Exp>>;
  account?: Maybe<Auth_Accounts_Bool_Exp>;
  account_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  role?: Maybe<String_Comparison_Exp>;
  role_by_role?: Maybe<Auth_Roles_Bool_Exp>;
};

/** unique or primary key constraints on table "auth.account_roles" */
export const Auth_Account_Roles_Constraint = {
  /** unique or primary key constraint on columns "id" */
  AccountRolesPkey: 'account_roles_pkey',
  /** unique or primary key constraint on columns "role", "account_id" */
  UserRolesAccountIdRoleKey: 'user_roles_account_id_role_key'
} as const;

export type Auth_Account_Roles_Constraint = typeof Auth_Account_Roles_Constraint[keyof typeof Auth_Account_Roles_Constraint];
/** input type for inserting data into table "auth.account_roles" */
export type Auth_Account_Roles_Insert_Input = {
  account?: Maybe<Auth_Accounts_Obj_Rel_Insert_Input>;
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
  role_by_role?: Maybe<Auth_Roles_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Auth_Account_Roles_Max_Fields = {
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "auth.account_roles" */
export type Auth_Account_Roles_Max_Order_By = {
  account_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  role?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Auth_Account_Roles_Min_Fields = {
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "auth.account_roles" */
export type Auth_Account_Roles_Min_Order_By = {
  account_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  role?: Maybe<Order_By>;
};

/** response of any mutation on the table "auth.account_roles" */
export type Auth_Account_Roles_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Auth_Account_Roles>;
};

/** on_conflict condition type for table "auth.account_roles" */
export type Auth_Account_Roles_On_Conflict = {
  constraint: Auth_Account_Roles_Constraint;
  update_columns?: Array<Auth_Account_Roles_Update_Column>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.account_roles". */
export type Auth_Account_Roles_Order_By = {
  account?: Maybe<Auth_Accounts_Order_By>;
  account_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  role?: Maybe<Order_By>;
  role_by_role?: Maybe<Auth_Roles_Order_By>;
};

/** primary key columns input for table: auth.account_roles */
export type Auth_Account_Roles_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "auth.account_roles" */
export const Auth_Account_Roles_Select_Column = {
  /** column name */
  AccountId: 'account_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Role: 'role'
} as const;

export type Auth_Account_Roles_Select_Column = typeof Auth_Account_Roles_Select_Column[keyof typeof Auth_Account_Roles_Select_Column];
/** input type for updating data in table "auth.account_roles" */
export type Auth_Account_Roles_Set_Input = {
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "auth_account_roles" */
export type Auth_Account_Roles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Auth_Account_Roles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Auth_Account_Roles_Stream_Cursor_Value_Input = {
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
};

/** update columns of table "auth.account_roles" */
export const Auth_Account_Roles_Update_Column = {
  /** column name */
  AccountId: 'account_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Role: 'role'
} as const;

export type Auth_Account_Roles_Update_Column = typeof Auth_Account_Roles_Update_Column[keyof typeof Auth_Account_Roles_Update_Column];
export type Auth_Account_Roles_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Auth_Account_Roles_Set_Input>;
  /** filter the rows which have to be updated */
  where: Auth_Account_Roles_Bool_Exp;
};

/** columns and relationships of "auth.accounts" */
export type Auth_Accounts = {
  /** An array relationship */
  account_providers: Array<Auth_Account_Providers>;
  /** An aggregate relationship */
  account_providers_aggregate: Auth_Account_Providers_Aggregate;
  /** An array relationship */
  account_roles: Array<Auth_Account_Roles>;
  /** An aggregate relationship */
  account_roles_aggregate: Auth_Account_Roles_Aggregate;
  active: Scalars['Boolean'];
  created_at: Scalars['timestamptz'];
  custom_register_data?: Maybe<Scalars['jsonb']>;
  default_role: Scalars['String'];
  email?: Maybe<Scalars['citext']>;
  id: Scalars['uuid'];
  is_anonymous: Scalars['Boolean'];
  mfa_enabled: Scalars['Boolean'];
  new_email?: Maybe<Scalars['citext']>;
  otp_secret?: Maybe<Scalars['String']>;
  password_hash?: Maybe<Scalars['String']>;
  /** An array relationship */
  refresh_tokens: Array<Auth_Refresh_Tokens>;
  /** An aggregate relationship */
  refresh_tokens_aggregate: Auth_Refresh_Tokens_Aggregate;
  /** An object relationship */
  role: Auth_Roles;
  ticket: Scalars['uuid'];
  ticket_expires_at: Scalars['timestamptz'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['uuid'];
};


/** columns and relationships of "auth.accounts" */
export type Auth_AccountsAccount_ProvidersArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Providers_Order_By>>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};


/** columns and relationships of "auth.accounts" */
export type Auth_AccountsAccount_Providers_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Providers_Order_By>>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};


/** columns and relationships of "auth.accounts" */
export type Auth_AccountsAccount_RolesArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Roles_Order_By>>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};


/** columns and relationships of "auth.accounts" */
export type Auth_AccountsAccount_Roles_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Roles_Order_By>>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};


/** columns and relationships of "auth.accounts" */
export type Auth_AccountsCustom_Register_DataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "auth.accounts" */
export type Auth_AccountsRefresh_TokensArgs = {
  distinct_on?: Maybe<Array<Auth_Refresh_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Refresh_Tokens_Order_By>>;
  where?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
};


/** columns and relationships of "auth.accounts" */
export type Auth_AccountsRefresh_Tokens_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Refresh_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Refresh_Tokens_Order_By>>;
  where?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
};

/** aggregated selection of "auth.accounts" */
export type Auth_Accounts_Aggregate = {
  aggregate?: Maybe<Auth_Accounts_Aggregate_Fields>;
  nodes: Array<Auth_Accounts>;
};

export type Auth_Accounts_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Auth_Accounts_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Auth_Accounts_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Auth_Accounts_Aggregate_Bool_Exp_Count>;
};

export type Auth_Accounts_Aggregate_Bool_Exp_Bool_And = {
  arguments: Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Auth_Accounts_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Auth_Accounts_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Auth_Accounts_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Auth_Accounts_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Auth_Accounts_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Auth_Accounts_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.accounts" */
export type Auth_Accounts_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Auth_Accounts_Max_Fields>;
  min?: Maybe<Auth_Accounts_Min_Fields>;
};


/** aggregate fields of "auth.accounts" */
export type Auth_Accounts_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Auth_Accounts_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.accounts" */
export type Auth_Accounts_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Auth_Accounts_Max_Order_By>;
  min?: Maybe<Auth_Accounts_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Auth_Accounts_Append_Input = {
  custom_register_data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "auth.accounts" */
export type Auth_Accounts_Arr_Rel_Insert_Input = {
  data: Array<Auth_Accounts_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Auth_Accounts_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.accounts". All fields are combined with a logical 'AND'. */
export type Auth_Accounts_Bool_Exp = {
  _and?: Maybe<Array<Auth_Accounts_Bool_Exp>>;
  _not?: Maybe<Auth_Accounts_Bool_Exp>;
  _or?: Maybe<Array<Auth_Accounts_Bool_Exp>>;
  account_providers?: Maybe<Auth_Account_Providers_Bool_Exp>;
  account_providers_aggregate?: Maybe<Auth_Account_Providers_Aggregate_Bool_Exp>;
  account_roles?: Maybe<Auth_Account_Roles_Bool_Exp>;
  account_roles_aggregate?: Maybe<Auth_Account_Roles_Aggregate_Bool_Exp>;
  active?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  custom_register_data?: Maybe<Jsonb_Comparison_Exp>;
  default_role?: Maybe<String_Comparison_Exp>;
  email?: Maybe<Citext_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_anonymous?: Maybe<Boolean_Comparison_Exp>;
  mfa_enabled?: Maybe<Boolean_Comparison_Exp>;
  new_email?: Maybe<Citext_Comparison_Exp>;
  otp_secret?: Maybe<String_Comparison_Exp>;
  password_hash?: Maybe<String_Comparison_Exp>;
  refresh_tokens?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
  refresh_tokens_aggregate?: Maybe<Auth_Refresh_Tokens_Aggregate_Bool_Exp>;
  role?: Maybe<Auth_Roles_Bool_Exp>;
  ticket?: Maybe<Uuid_Comparison_Exp>;
  ticket_expires_at?: Maybe<Timestamptz_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.accounts" */
export const Auth_Accounts_Constraint = {
  /** unique or primary key constraint on columns "email" */
  AccountsEmailKey: 'accounts_email_key',
  /** unique or primary key constraint on columns "new_email" */
  AccountsNewEmailKey: 'accounts_new_email_key',
  /** unique or primary key constraint on columns "id" */
  AccountsPkey: 'accounts_pkey',
  /** unique or primary key constraint on columns "user_id" */
  AccountsUserIdKey: 'accounts_user_id_key'
} as const;

export type Auth_Accounts_Constraint = typeof Auth_Accounts_Constraint[keyof typeof Auth_Accounts_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Auth_Accounts_Delete_At_Path_Input = {
  custom_register_data?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Auth_Accounts_Delete_Elem_Input = {
  custom_register_data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Auth_Accounts_Delete_Key_Input = {
  custom_register_data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "auth.accounts" */
export type Auth_Accounts_Insert_Input = {
  account_providers?: Maybe<Auth_Account_Providers_Arr_Rel_Insert_Input>;
  account_roles?: Maybe<Auth_Account_Roles_Arr_Rel_Insert_Input>;
  active?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  custom_register_data?: Maybe<Scalars['jsonb']>;
  default_role?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  is_anonymous?: Maybe<Scalars['Boolean']>;
  mfa_enabled?: Maybe<Scalars['Boolean']>;
  new_email?: Maybe<Scalars['citext']>;
  otp_secret?: Maybe<Scalars['String']>;
  password_hash?: Maybe<Scalars['String']>;
  refresh_tokens?: Maybe<Auth_Refresh_Tokens_Arr_Rel_Insert_Input>;
  role?: Maybe<Auth_Roles_Obj_Rel_Insert_Input>;
  ticket?: Maybe<Scalars['uuid']>;
  ticket_expires_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Auth_Accounts_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  default_role?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  new_email?: Maybe<Scalars['citext']>;
  otp_secret?: Maybe<Scalars['String']>;
  password_hash?: Maybe<Scalars['String']>;
  ticket?: Maybe<Scalars['uuid']>;
  ticket_expires_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.accounts" */
export type Auth_Accounts_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  default_role?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  new_email?: Maybe<Order_By>;
  otp_secret?: Maybe<Order_By>;
  password_hash?: Maybe<Order_By>;
  ticket?: Maybe<Order_By>;
  ticket_expires_at?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Auth_Accounts_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  default_role?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  new_email?: Maybe<Scalars['citext']>;
  otp_secret?: Maybe<Scalars['String']>;
  password_hash?: Maybe<Scalars['String']>;
  ticket?: Maybe<Scalars['uuid']>;
  ticket_expires_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.accounts" */
export type Auth_Accounts_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  default_role?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  new_email?: Maybe<Order_By>;
  otp_secret?: Maybe<Order_By>;
  password_hash?: Maybe<Order_By>;
  ticket?: Maybe<Order_By>;
  ticket_expires_at?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "auth.accounts" */
export type Auth_Accounts_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Auth_Accounts>;
};

/** input type for inserting object relation for remote table "auth.accounts" */
export type Auth_Accounts_Obj_Rel_Insert_Input = {
  data: Auth_Accounts_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Auth_Accounts_On_Conflict>;
};

/** on_conflict condition type for table "auth.accounts" */
export type Auth_Accounts_On_Conflict = {
  constraint: Auth_Accounts_Constraint;
  update_columns?: Array<Auth_Accounts_Update_Column>;
  where?: Maybe<Auth_Accounts_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.accounts". */
export type Auth_Accounts_Order_By = {
  account_providers_aggregate?: Maybe<Auth_Account_Providers_Aggregate_Order_By>;
  account_roles_aggregate?: Maybe<Auth_Account_Roles_Aggregate_Order_By>;
  active?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  custom_register_data?: Maybe<Order_By>;
  default_role?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_anonymous?: Maybe<Order_By>;
  mfa_enabled?: Maybe<Order_By>;
  new_email?: Maybe<Order_By>;
  otp_secret?: Maybe<Order_By>;
  password_hash?: Maybe<Order_By>;
  refresh_tokens_aggregate?: Maybe<Auth_Refresh_Tokens_Aggregate_Order_By>;
  role?: Maybe<Auth_Roles_Order_By>;
  ticket?: Maybe<Order_By>;
  ticket_expires_at?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: auth.accounts */
export type Auth_Accounts_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Auth_Accounts_Prepend_Input = {
  custom_register_data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "auth.accounts" */
export const Auth_Accounts_Select_Column = {
  /** column name */
  Active: 'active',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  CustomRegisterData: 'custom_register_data',
  /** column name */
  DefaultRole: 'default_role',
  /** column name */
  Email: 'email',
  /** column name */
  Id: 'id',
  /** column name */
  IsAnonymous: 'is_anonymous',
  /** column name */
  MfaEnabled: 'mfa_enabled',
  /** column name */
  NewEmail: 'new_email',
  /** column name */
  OtpSecret: 'otp_secret',
  /** column name */
  PasswordHash: 'password_hash',
  /** column name */
  Ticket: 'ticket',
  /** column name */
  TicketExpiresAt: 'ticket_expires_at',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  UserId: 'user_id'
} as const;

export type Auth_Accounts_Select_Column = typeof Auth_Accounts_Select_Column[keyof typeof Auth_Accounts_Select_Column];
/** select "auth_accounts_aggregate_bool_exp_bool_and_arguments_columns" columns of table "auth.accounts" */
export const Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  Active: 'active',
  /** column name */
  IsAnonymous: 'is_anonymous',
  /** column name */
  MfaEnabled: 'mfa_enabled'
} as const;

export type Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "auth_accounts_aggregate_bool_exp_bool_or_arguments_columns" columns of table "auth.accounts" */
export const Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  Active: 'active',
  /** column name */
  IsAnonymous: 'is_anonymous',
  /** column name */
  MfaEnabled: 'mfa_enabled'
} as const;

export type Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Auth_Accounts_Select_Column_Auth_Accounts_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "auth.accounts" */
export type Auth_Accounts_Set_Input = {
  active?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  custom_register_data?: Maybe<Scalars['jsonb']>;
  default_role?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  is_anonymous?: Maybe<Scalars['Boolean']>;
  mfa_enabled?: Maybe<Scalars['Boolean']>;
  new_email?: Maybe<Scalars['citext']>;
  otp_secret?: Maybe<Scalars['String']>;
  password_hash?: Maybe<Scalars['String']>;
  ticket?: Maybe<Scalars['uuid']>;
  ticket_expires_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "auth_accounts" */
export type Auth_Accounts_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Auth_Accounts_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Auth_Accounts_Stream_Cursor_Value_Input = {
  active?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  custom_register_data?: Maybe<Scalars['jsonb']>;
  default_role?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  is_anonymous?: Maybe<Scalars['Boolean']>;
  mfa_enabled?: Maybe<Scalars['Boolean']>;
  new_email?: Maybe<Scalars['citext']>;
  otp_secret?: Maybe<Scalars['String']>;
  password_hash?: Maybe<Scalars['String']>;
  ticket?: Maybe<Scalars['uuid']>;
  ticket_expires_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "auth.accounts" */
export const Auth_Accounts_Update_Column = {
  /** column name */
  Active: 'active',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  CustomRegisterData: 'custom_register_data',
  /** column name */
  DefaultRole: 'default_role',
  /** column name */
  Email: 'email',
  /** column name */
  Id: 'id',
  /** column name */
  IsAnonymous: 'is_anonymous',
  /** column name */
  MfaEnabled: 'mfa_enabled',
  /** column name */
  NewEmail: 'new_email',
  /** column name */
  OtpSecret: 'otp_secret',
  /** column name */
  PasswordHash: 'password_hash',
  /** column name */
  Ticket: 'ticket',
  /** column name */
  TicketExpiresAt: 'ticket_expires_at',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  UserId: 'user_id'
} as const;

export type Auth_Accounts_Update_Column = typeof Auth_Accounts_Update_Column[keyof typeof Auth_Accounts_Update_Column];
export type Auth_Accounts_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Auth_Accounts_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Auth_Accounts_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Auth_Accounts_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Auth_Accounts_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Auth_Accounts_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Auth_Accounts_Set_Input>;
  /** filter the rows which have to be updated */
  where: Auth_Accounts_Bool_Exp;
};

/** columns and relationships of "auth.providers" */
export type Auth_Providers = {
  /** An array relationship */
  account_providers: Array<Auth_Account_Providers>;
  /** An aggregate relationship */
  account_providers_aggregate: Auth_Account_Providers_Aggregate;
  provider: Scalars['String'];
};


/** columns and relationships of "auth.providers" */
export type Auth_ProvidersAccount_ProvidersArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Providers_Order_By>>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};


/** columns and relationships of "auth.providers" */
export type Auth_ProvidersAccount_Providers_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Providers_Order_By>>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};

/** aggregated selection of "auth.providers" */
export type Auth_Providers_Aggregate = {
  aggregate?: Maybe<Auth_Providers_Aggregate_Fields>;
  nodes: Array<Auth_Providers>;
};

/** aggregate fields of "auth.providers" */
export type Auth_Providers_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Auth_Providers_Max_Fields>;
  min?: Maybe<Auth_Providers_Min_Fields>;
};


/** aggregate fields of "auth.providers" */
export type Auth_Providers_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Auth_Providers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'. */
export type Auth_Providers_Bool_Exp = {
  _and?: Maybe<Array<Auth_Providers_Bool_Exp>>;
  _not?: Maybe<Auth_Providers_Bool_Exp>;
  _or?: Maybe<Array<Auth_Providers_Bool_Exp>>;
  account_providers?: Maybe<Auth_Account_Providers_Bool_Exp>;
  account_providers_aggregate?: Maybe<Auth_Account_Providers_Aggregate_Bool_Exp>;
  provider?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.providers" */
export const Auth_Providers_Constraint = {
  /** unique or primary key constraint on columns "provider" */
  ProvidersPkey: 'providers_pkey'
} as const;

export type Auth_Providers_Constraint = typeof Auth_Providers_Constraint[keyof typeof Auth_Providers_Constraint];
/** input type for inserting data into table "auth.providers" */
export type Auth_Providers_Insert_Input = {
  account_providers?: Maybe<Auth_Account_Providers_Arr_Rel_Insert_Input>;
  provider?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Auth_Providers_Max_Fields = {
  provider?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Auth_Providers_Min_Fields = {
  provider?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "auth.providers" */
export type Auth_Providers_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Auth_Providers>;
};

/** input type for inserting object relation for remote table "auth.providers" */
export type Auth_Providers_Obj_Rel_Insert_Input = {
  data: Auth_Providers_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Auth_Providers_On_Conflict>;
};

/** on_conflict condition type for table "auth.providers" */
export type Auth_Providers_On_Conflict = {
  constraint: Auth_Providers_Constraint;
  update_columns?: Array<Auth_Providers_Update_Column>;
  where?: Maybe<Auth_Providers_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.providers". */
export type Auth_Providers_Order_By = {
  account_providers_aggregate?: Maybe<Auth_Account_Providers_Aggregate_Order_By>;
  provider?: Maybe<Order_By>;
};

/** primary key columns input for table: auth.providers */
export type Auth_Providers_Pk_Columns_Input = {
  provider: Scalars['String'];
};

/** select columns of table "auth.providers" */
export const Auth_Providers_Select_Column = {
  /** column name */
  Provider: 'provider'
} as const;

export type Auth_Providers_Select_Column = typeof Auth_Providers_Select_Column[keyof typeof Auth_Providers_Select_Column];
/** input type for updating data in table "auth.providers" */
export type Auth_Providers_Set_Input = {
  provider?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "auth_providers" */
export type Auth_Providers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Auth_Providers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Auth_Providers_Stream_Cursor_Value_Input = {
  provider?: Maybe<Scalars['String']>;
};

/** update columns of table "auth.providers" */
export const Auth_Providers_Update_Column = {
  /** column name */
  Provider: 'provider'
} as const;

export type Auth_Providers_Update_Column = typeof Auth_Providers_Update_Column[keyof typeof Auth_Providers_Update_Column];
export type Auth_Providers_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Auth_Providers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Auth_Providers_Bool_Exp;
};

/** columns and relationships of "auth.refresh_tokens" */
export type Auth_Refresh_Tokens = {
  /** An object relationship */
  account: Auth_Accounts;
  account_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  expires_at: Scalars['timestamptz'];
  refresh_token: Scalars['uuid'];
};

/** aggregated selection of "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Aggregate = {
  aggregate?: Maybe<Auth_Refresh_Tokens_Aggregate_Fields>;
  nodes: Array<Auth_Refresh_Tokens>;
};

export type Auth_Refresh_Tokens_Aggregate_Bool_Exp = {
  count?: Maybe<Auth_Refresh_Tokens_Aggregate_Bool_Exp_Count>;
};

export type Auth_Refresh_Tokens_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Auth_Refresh_Tokens_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Auth_Refresh_Tokens_Max_Fields>;
  min?: Maybe<Auth_Refresh_Tokens_Min_Fields>;
};


/** aggregate fields of "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Auth_Refresh_Tokens_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Auth_Refresh_Tokens_Max_Order_By>;
  min?: Maybe<Auth_Refresh_Tokens_Min_Order_By>;
};

/** input type for inserting array relation for remote table "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Arr_Rel_Insert_Input = {
  data: Array<Auth_Refresh_Tokens_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Auth_Refresh_Tokens_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'. */
export type Auth_Refresh_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Auth_Refresh_Tokens_Bool_Exp>>;
  _not?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Auth_Refresh_Tokens_Bool_Exp>>;
  account?: Maybe<Auth_Accounts_Bool_Exp>;
  account_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  expires_at?: Maybe<Timestamptz_Comparison_Exp>;
  refresh_token?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.refresh_tokens" */
export const Auth_Refresh_Tokens_Constraint = {
  /** unique or primary key constraint on columns "refresh_token" */
  RefreshTokensPkey: 'refresh_tokens_pkey'
} as const;

export type Auth_Refresh_Tokens_Constraint = typeof Auth_Refresh_Tokens_Constraint[keyof typeof Auth_Refresh_Tokens_Constraint];
/** input type for inserting data into table "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Insert_Input = {
  account?: Maybe<Auth_Accounts_Obj_Rel_Insert_Input>;
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  refresh_token?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Auth_Refresh_Tokens_Max_Fields = {
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  refresh_token?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Max_Order_By = {
  account_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  expires_at?: Maybe<Order_By>;
  refresh_token?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Auth_Refresh_Tokens_Min_Fields = {
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  refresh_token?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Min_Order_By = {
  account_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  expires_at?: Maybe<Order_By>;
  refresh_token?: Maybe<Order_By>;
};

/** response of any mutation on the table "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Auth_Refresh_Tokens>;
};

/** on_conflict condition type for table "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_On_Conflict = {
  constraint: Auth_Refresh_Tokens_Constraint;
  update_columns?: Array<Auth_Refresh_Tokens_Update_Column>;
  where?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.refresh_tokens". */
export type Auth_Refresh_Tokens_Order_By = {
  account?: Maybe<Auth_Accounts_Order_By>;
  account_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  expires_at?: Maybe<Order_By>;
  refresh_token?: Maybe<Order_By>;
};

/** primary key columns input for table: auth.refresh_tokens */
export type Auth_Refresh_Tokens_Pk_Columns_Input = {
  refresh_token: Scalars['uuid'];
};

/** select columns of table "auth.refresh_tokens" */
export const Auth_Refresh_Tokens_Select_Column = {
  /** column name */
  AccountId: 'account_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExpiresAt: 'expires_at',
  /** column name */
  RefreshToken: 'refresh_token'
} as const;

export type Auth_Refresh_Tokens_Select_Column = typeof Auth_Refresh_Tokens_Select_Column[keyof typeof Auth_Refresh_Tokens_Select_Column];
/** input type for updating data in table "auth.refresh_tokens" */
export type Auth_Refresh_Tokens_Set_Input = {
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  refresh_token?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "auth_refresh_tokens" */
export type Auth_Refresh_Tokens_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Auth_Refresh_Tokens_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Auth_Refresh_Tokens_Stream_Cursor_Value_Input = {
  account_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  refresh_token?: Maybe<Scalars['uuid']>;
};

/** update columns of table "auth.refresh_tokens" */
export const Auth_Refresh_Tokens_Update_Column = {
  /** column name */
  AccountId: 'account_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExpiresAt: 'expires_at',
  /** column name */
  RefreshToken: 'refresh_token'
} as const;

export type Auth_Refresh_Tokens_Update_Column = typeof Auth_Refresh_Tokens_Update_Column[keyof typeof Auth_Refresh_Tokens_Update_Column];
export type Auth_Refresh_Tokens_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Auth_Refresh_Tokens_Set_Input>;
  /** filter the rows which have to be updated */
  where: Auth_Refresh_Tokens_Bool_Exp;
};

/** columns and relationships of "auth.roles" */
export type Auth_Roles = {
  /** An array relationship */
  account_roles: Array<Auth_Account_Roles>;
  /** An aggregate relationship */
  account_roles_aggregate: Auth_Account_Roles_Aggregate;
  /** An array relationship */
  accounts: Array<Auth_Accounts>;
  /** An aggregate relationship */
  accounts_aggregate: Auth_Accounts_Aggregate;
  role: Scalars['String'];
};


/** columns and relationships of "auth.roles" */
export type Auth_RolesAccount_RolesArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Roles_Order_By>>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};


/** columns and relationships of "auth.roles" */
export type Auth_RolesAccount_Roles_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Roles_Order_By>>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};


/** columns and relationships of "auth.roles" */
export type Auth_RolesAccountsArgs = {
  distinct_on?: Maybe<Array<Auth_Accounts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Accounts_Order_By>>;
  where?: Maybe<Auth_Accounts_Bool_Exp>;
};


/** columns and relationships of "auth.roles" */
export type Auth_RolesAccounts_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Accounts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Accounts_Order_By>>;
  where?: Maybe<Auth_Accounts_Bool_Exp>;
};

/** aggregated selection of "auth.roles" */
export type Auth_Roles_Aggregate = {
  aggregate?: Maybe<Auth_Roles_Aggregate_Fields>;
  nodes: Array<Auth_Roles>;
};

/** aggregate fields of "auth.roles" */
export type Auth_Roles_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Auth_Roles_Max_Fields>;
  min?: Maybe<Auth_Roles_Min_Fields>;
};


/** aggregate fields of "auth.roles" */
export type Auth_Roles_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Auth_Roles_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'. */
export type Auth_Roles_Bool_Exp = {
  _and?: Maybe<Array<Auth_Roles_Bool_Exp>>;
  _not?: Maybe<Auth_Roles_Bool_Exp>;
  _or?: Maybe<Array<Auth_Roles_Bool_Exp>>;
  account_roles?: Maybe<Auth_Account_Roles_Bool_Exp>;
  account_roles_aggregate?: Maybe<Auth_Account_Roles_Aggregate_Bool_Exp>;
  accounts?: Maybe<Auth_Accounts_Bool_Exp>;
  accounts_aggregate?: Maybe<Auth_Accounts_Aggregate_Bool_Exp>;
  role?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.roles" */
export const Auth_Roles_Constraint = {
  /** unique or primary key constraint on columns "role" */
  RolesPkey: 'roles_pkey'
} as const;

export type Auth_Roles_Constraint = typeof Auth_Roles_Constraint[keyof typeof Auth_Roles_Constraint];
/** input type for inserting data into table "auth.roles" */
export type Auth_Roles_Insert_Input = {
  account_roles?: Maybe<Auth_Account_Roles_Arr_Rel_Insert_Input>;
  accounts?: Maybe<Auth_Accounts_Arr_Rel_Insert_Input>;
  role?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Auth_Roles_Max_Fields = {
  role?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Auth_Roles_Min_Fields = {
  role?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "auth.roles" */
export type Auth_Roles_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Auth_Roles>;
};

/** input type for inserting object relation for remote table "auth.roles" */
export type Auth_Roles_Obj_Rel_Insert_Input = {
  data: Auth_Roles_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Auth_Roles_On_Conflict>;
};

/** on_conflict condition type for table "auth.roles" */
export type Auth_Roles_On_Conflict = {
  constraint: Auth_Roles_Constraint;
  update_columns?: Array<Auth_Roles_Update_Column>;
  where?: Maybe<Auth_Roles_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.roles". */
export type Auth_Roles_Order_By = {
  account_roles_aggregate?: Maybe<Auth_Account_Roles_Aggregate_Order_By>;
  accounts_aggregate?: Maybe<Auth_Accounts_Aggregate_Order_By>;
  role?: Maybe<Order_By>;
};

/** primary key columns input for table: auth.roles */
export type Auth_Roles_Pk_Columns_Input = {
  role: Scalars['String'];
};

/** select columns of table "auth.roles" */
export const Auth_Roles_Select_Column = {
  /** column name */
  Role: 'role'
} as const;

export type Auth_Roles_Select_Column = typeof Auth_Roles_Select_Column[keyof typeof Auth_Roles_Select_Column];
/** input type for updating data in table "auth.roles" */
export type Auth_Roles_Set_Input = {
  role?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "auth_roles" */
export type Auth_Roles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Auth_Roles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Auth_Roles_Stream_Cursor_Value_Input = {
  role?: Maybe<Scalars['String']>;
};

/** update columns of table "auth.roles" */
export const Auth_Roles_Update_Column = {
  /** column name */
  Role: 'role'
} as const;

export type Auth_Roles_Update_Column = typeof Auth_Roles_Update_Column[keyof typeof Auth_Roles_Update_Column];
export type Auth_Roles_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Auth_Roles_Set_Input>;
  /** filter the rows which have to be updated */
  where: Auth_Roles_Bool_Exp;
};


/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: Maybe<Scalars['bigint']>;
  _gt?: Maybe<Scalars['bigint']>;
  _gte?: Maybe<Scalars['bigint']>;
  _in?: Maybe<Array<Scalars['bigint']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['bigint']>;
  _lte?: Maybe<Scalars['bigint']>;
  _neq?: Maybe<Scalars['bigint']>;
  _nin?: Maybe<Array<Scalars['bigint']>>;
};

/** columns and relationships of "carrier" */
export type Carrier = {
  carrier_account_credentials: Scalars['jsonb'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An array relationship */
  manifests: Array<Manifest>;
  /** An aggregate relationship */
  manifests_aggregate: Manifest_Aggregate;
  name: Scalars['String'];
  provider: Shipping_Provider_Enum;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  shipping_provider: Shipping_Provider;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "carrier" */
export type CarrierCarrier_Account_CredentialsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "carrier" */
export type CarrierManifestsArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


/** columns and relationships of "carrier" */
export type CarrierManifests_AggregateArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


/** columns and relationships of "carrier" */
export type CarrierShipping_Aggregator_IntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "carrier" */
export type Carrier_Aggregate = {
  aggregate?: Maybe<Carrier_Aggregate_Fields>;
  nodes: Array<Carrier>;
};

export type Carrier_Aggregate_Bool_Exp = {
  count?: Maybe<Carrier_Aggregate_Bool_Exp_Count>;
};

export type Carrier_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Carrier_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Carrier_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "carrier" */
export type Carrier_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Carrier_Max_Fields>;
  min?: Maybe<Carrier_Min_Fields>;
};


/** aggregate fields of "carrier" */
export type Carrier_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Carrier_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "carrier" */
export type Carrier_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Carrier_Max_Order_By>;
  min?: Maybe<Carrier_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Carrier_Append_Input = {
  carrier_account_credentials?: Maybe<Scalars['jsonb']>;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "carrier" */
export type Carrier_Arr_Rel_Insert_Input = {
  data: Array<Carrier_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Carrier_On_Conflict>;
};

/** Boolean expression to filter rows from the table "carrier". All fields are combined with a logical 'AND'. */
export type Carrier_Bool_Exp = {
  _and?: Maybe<Array<Carrier_Bool_Exp>>;
  _not?: Maybe<Carrier_Bool_Exp>;
  _or?: Maybe<Array<Carrier_Bool_Exp>>;
  carrier_account_credentials?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  manifests?: Maybe<Manifest_Bool_Exp>;
  manifests_aggregate?: Maybe<Manifest_Aggregate_Bool_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  provider?: Maybe<Shipping_Provider_Enum_Comparison_Exp>;
  shipping_aggregator_integrations?: Maybe<Jsonb_Comparison_Exp>;
  shipping_provider?: Maybe<Shipping_Provider_Bool_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "carrier" */
export const Carrier_Constraint = {
  /** unique or primary key constraint on columns "id" */
  CarrierPkey: 'carrier_pkey'
} as const;

export type Carrier_Constraint = typeof Carrier_Constraint[keyof typeof Carrier_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Carrier_Delete_At_Path_Input = {
  carrier_account_credentials?: Maybe<Array<Scalars['String']>>;
  shipping_aggregator_integrations?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Carrier_Delete_Elem_Input = {
  carrier_account_credentials?: Maybe<Scalars['Int']>;
  shipping_aggregator_integrations?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Carrier_Delete_Key_Input = {
  carrier_account_credentials?: Maybe<Scalars['String']>;
  shipping_aggregator_integrations?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "carrier" */
export type Carrier_Insert_Input = {
  carrier_account_credentials?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  manifests?: Maybe<Manifest_Arr_Rel_Insert_Input>;
  name?: Maybe<Scalars['String']>;
  provider?: Maybe<Shipping_Provider_Enum>;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
  shipping_provider?: Maybe<Shipping_Provider_Obj_Rel_Insert_Input>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Carrier_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "carrier" */
export type Carrier_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Carrier_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "carrier" */
export type Carrier_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "carrier" */
export type Carrier_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Carrier>;
};

/** input type for inserting object relation for remote table "carrier" */
export type Carrier_Obj_Rel_Insert_Input = {
  data: Carrier_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Carrier_On_Conflict>;
};

/** on_conflict condition type for table "carrier" */
export type Carrier_On_Conflict = {
  constraint: Carrier_Constraint;
  update_columns?: Array<Carrier_Update_Column>;
  where?: Maybe<Carrier_Bool_Exp>;
};

/** Ordering options when selecting data from "carrier". */
export type Carrier_Order_By = {
  carrier_account_credentials?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  manifests_aggregate?: Maybe<Manifest_Aggregate_Order_By>;
  name?: Maybe<Order_By>;
  provider?: Maybe<Order_By>;
  shipping_aggregator_integrations?: Maybe<Order_By>;
  shipping_provider?: Maybe<Shipping_Provider_Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: carrier */
export type Carrier_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Carrier_Prepend_Input = {
  carrier_account_credentials?: Maybe<Scalars['jsonb']>;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "carrier" */
export const Carrier_Select_Column = {
  /** column name */
  CarrierAccountCredentials: 'carrier_account_credentials',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  Provider: 'provider',
  /** column name */
  ShippingAggregatorIntegrations: 'shipping_aggregator_integrations',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Carrier_Select_Column = typeof Carrier_Select_Column[keyof typeof Carrier_Select_Column];
/** columns and relationships of "carrier_selection" */
export type Carrier_Selection = {
  /** An array relationship */
  stores: Array<Store>;
  /** An aggregate relationship */
  stores_aggregate: Store_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "carrier_selection" */
export type Carrier_SelectionStoresArgs = {
  distinct_on?: Maybe<Array<Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Order_By>>;
  where?: Maybe<Store_Bool_Exp>;
};


/** columns and relationships of "carrier_selection" */
export type Carrier_SelectionStores_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Order_By>>;
  where?: Maybe<Store_Bool_Exp>;
};

/** aggregated selection of "carrier_selection" */
export type Carrier_Selection_Aggregate = {
  aggregate?: Maybe<Carrier_Selection_Aggregate_Fields>;
  nodes: Array<Carrier_Selection>;
};

/** aggregate fields of "carrier_selection" */
export type Carrier_Selection_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Carrier_Selection_Max_Fields>;
  min?: Maybe<Carrier_Selection_Min_Fields>;
};


/** aggregate fields of "carrier_selection" */
export type Carrier_Selection_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Carrier_Selection_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "carrier_selection". All fields are combined with a logical 'AND'. */
export type Carrier_Selection_Bool_Exp = {
  _and?: Maybe<Array<Carrier_Selection_Bool_Exp>>;
  _not?: Maybe<Carrier_Selection_Bool_Exp>;
  _or?: Maybe<Array<Carrier_Selection_Bool_Exp>>;
  stores?: Maybe<Store_Bool_Exp>;
  stores_aggregate?: Maybe<Store_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "carrier_selection" */
export const Carrier_Selection_Constraint = {
  /** unique or primary key constraint on columns "value" */
  CarrierSelectionPkey: 'carrier_selection_pkey'
} as const;

export type Carrier_Selection_Constraint = typeof Carrier_Selection_Constraint[keyof typeof Carrier_Selection_Constraint];
export const Carrier_Selection_Enum = {
  CheapestAvailable: 'CHEAPEST_AVAILABLE',
  SmartAllocation: 'SMART_ALLOCATION'
} as const;

export type Carrier_Selection_Enum = typeof Carrier_Selection_Enum[keyof typeof Carrier_Selection_Enum];
/** Boolean expression to compare columns of type "carrier_selection_enum". All fields are combined with logical 'AND'. */
export type Carrier_Selection_Enum_Comparison_Exp = {
  _eq?: Maybe<Carrier_Selection_Enum>;
  _in?: Maybe<Array<Carrier_Selection_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Carrier_Selection_Enum>;
  _nin?: Maybe<Array<Carrier_Selection_Enum>>;
};

/** input type for inserting data into table "carrier_selection" */
export type Carrier_Selection_Insert_Input = {
  stores?: Maybe<Store_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Carrier_Selection_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Carrier_Selection_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "carrier_selection" */
export type Carrier_Selection_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Carrier_Selection>;
};

/** input type for inserting object relation for remote table "carrier_selection" */
export type Carrier_Selection_Obj_Rel_Insert_Input = {
  data: Carrier_Selection_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Carrier_Selection_On_Conflict>;
};

/** on_conflict condition type for table "carrier_selection" */
export type Carrier_Selection_On_Conflict = {
  constraint: Carrier_Selection_Constraint;
  update_columns?: Array<Carrier_Selection_Update_Column>;
  where?: Maybe<Carrier_Selection_Bool_Exp>;
};

/** Ordering options when selecting data from "carrier_selection". */
export type Carrier_Selection_Order_By = {
  stores_aggregate?: Maybe<Store_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: carrier_selection */
export type Carrier_Selection_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "carrier_selection" */
export const Carrier_Selection_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Carrier_Selection_Select_Column = typeof Carrier_Selection_Select_Column[keyof typeof Carrier_Selection_Select_Column];
/** input type for updating data in table "carrier_selection" */
export type Carrier_Selection_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "carrier_selection" */
export type Carrier_Selection_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Carrier_Selection_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Carrier_Selection_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "carrier_selection" */
export const Carrier_Selection_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Carrier_Selection_Update_Column = typeof Carrier_Selection_Update_Column[keyof typeof Carrier_Selection_Update_Column];
export type Carrier_Selection_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Carrier_Selection_Set_Input>;
  /** filter the rows which have to be updated */
  where: Carrier_Selection_Bool_Exp;
};

/** input type for updating data in table "carrier" */
export type Carrier_Set_Input = {
  carrier_account_credentials?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  provider?: Maybe<Shipping_Provider_Enum>;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "carrier" */
export type Carrier_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Carrier_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Carrier_Stream_Cursor_Value_Input = {
  carrier_account_credentials?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  provider?: Maybe<Shipping_Provider_Enum>;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "carrier" */
export const Carrier_Update_Column = {
  /** column name */
  CarrierAccountCredentials: 'carrier_account_credentials',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  Provider: 'provider',
  /** column name */
  ShippingAggregatorIntegrations: 'shipping_aggregator_integrations',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Carrier_Update_Column = typeof Carrier_Update_Column[keyof typeof Carrier_Update_Column];
export type Carrier_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Carrier_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Carrier_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Carrier_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Carrier_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Carrier_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Carrier_Set_Input>;
  /** filter the rows which have to be updated */
  where: Carrier_Bool_Exp;
};


/** Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'. */
export type Citext_Comparison_Exp = {
  _eq?: Maybe<Scalars['citext']>;
  _gt?: Maybe<Scalars['citext']>;
  _gte?: Maybe<Scalars['citext']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: Maybe<Scalars['citext']>;
  _in?: Maybe<Array<Scalars['citext']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: Maybe<Scalars['citext']>;
  _is_null?: Maybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: Maybe<Scalars['citext']>;
  _lt?: Maybe<Scalars['citext']>;
  _lte?: Maybe<Scalars['citext']>;
  _neq?: Maybe<Scalars['citext']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: Maybe<Scalars['citext']>;
  _nin?: Maybe<Array<Scalars['citext']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: Maybe<Scalars['citext']>;
  /** does the column NOT match the given pattern */
  _nlike?: Maybe<Scalars['citext']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: Maybe<Scalars['citext']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: Maybe<Scalars['citext']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: Maybe<Scalars['citext']>;
  /** does the column match the given SQL regular expression */
  _similar?: Maybe<Scalars['citext']>;
};

/** ordering argument of a cursor */
export const Cursor_Ordering = {
  /** ascending ordering of the cursor */
  Asc: 'ASC',
  /** descending ordering of the cursor */
  Desc: 'DESC'
} as const;

export type Cursor_Ordering = typeof Cursor_Ordering[keyof typeof Cursor_Ordering];
/** columns and relationships of "customer" */
export type Customer = {
  /** An object relationship */
  address?: Maybe<Address>;
  address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  first_name: Scalars['String'];
  id: Scalars['uuid'];
  integrations?: Maybe<Scalars['jsonb']>;
  last_name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  /** An array relationship */
  sales_orders: Array<Sales_Order>;
  /** An aggregate relationship */
  sales_orders_aggregate: Sales_Order_Aggregate;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "customer" */
export type CustomerIntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "customer" */
export type CustomerSales_OrdersArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "customer" */
export type CustomerSales_Orders_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};

/** aggregated selection of "customer" */
export type Customer_Aggregate = {
  aggregate?: Maybe<Customer_Aggregate_Fields>;
  nodes: Array<Customer>;
};

export type Customer_Aggregate_Bool_Exp = {
  count?: Maybe<Customer_Aggregate_Bool_Exp_Count>;
};

export type Customer_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Customer_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "customer" */
export type Customer_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Customer_Max_Fields>;
  min?: Maybe<Customer_Min_Fields>;
};


/** aggregate fields of "customer" */
export type Customer_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Customer_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "customer" */
export type Customer_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Customer_Max_Order_By>;
  min?: Maybe<Customer_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Customer_Append_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "customer" */
export type Customer_Arr_Rel_Insert_Input = {
  data: Array<Customer_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Customer_On_Conflict>;
};

/** Boolean expression to filter rows from the table "customer". All fields are combined with a logical 'AND'. */
export type Customer_Bool_Exp = {
  _and?: Maybe<Array<Customer_Bool_Exp>>;
  _not?: Maybe<Customer_Bool_Exp>;
  _or?: Maybe<Array<Customer_Bool_Exp>>;
  address?: Maybe<Address_Bool_Exp>;
  address_id?: Maybe<Uuid_Comparison_Exp>;
  contact_number?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  first_name?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  integrations?: Maybe<Jsonb_Comparison_Exp>;
  last_name?: Maybe<String_Comparison_Exp>;
  note?: Maybe<String_Comparison_Exp>;
  sales_orders?: Maybe<Sales_Order_Bool_Exp>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Bool_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "customer" */
export const Customer_Constraint = {
  /** unique or primary key constraint on columns "id" */
  CustomerPkey: 'customer_pkey'
} as const;

export type Customer_Constraint = typeof Customer_Constraint[keyof typeof Customer_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Customer_Delete_At_Path_Input = {
  integrations?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Customer_Delete_Elem_Input = {
  integrations?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Customer_Delete_Key_Input = {
  integrations?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "customer" */
export type Customer_Insert_Input = {
  address?: Maybe<Address_Obj_Rel_Insert_Input>;
  address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  last_name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  sales_orders?: Maybe<Sales_Order_Arr_Rel_Insert_Input>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Customer_Max_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "customer" */
export type Customer_Max_Order_By = {
  address_id?: Maybe<Order_By>;
  contact_number?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  first_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_name?: Maybe<Order_By>;
  note?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Customer_Min_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "customer" */
export type Customer_Min_Order_By = {
  address_id?: Maybe<Order_By>;
  contact_number?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  first_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_name?: Maybe<Order_By>;
  note?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "customer" */
export type Customer_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Customer>;
};

/** input type for inserting object relation for remote table "customer" */
export type Customer_Obj_Rel_Insert_Input = {
  data: Customer_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Customer_On_Conflict>;
};

/** on_conflict condition type for table "customer" */
export type Customer_On_Conflict = {
  constraint: Customer_Constraint;
  update_columns?: Array<Customer_Update_Column>;
  where?: Maybe<Customer_Bool_Exp>;
};

/** Ordering options when selecting data from "customer". */
export type Customer_Order_By = {
  address?: Maybe<Address_Order_By>;
  address_id?: Maybe<Order_By>;
  contact_number?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  first_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  integrations?: Maybe<Order_By>;
  last_name?: Maybe<Order_By>;
  note?: Maybe<Order_By>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: customer */
export type Customer_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Customer_Prepend_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "customer" */
export const Customer_Select_Column = {
  /** column name */
  AddressId: 'address_id',
  /** column name */
  ContactNumber: 'contact_number',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FirstName: 'first_name',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  LastName: 'last_name',
  /** column name */
  Note: 'note',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Customer_Select_Column = typeof Customer_Select_Column[keyof typeof Customer_Select_Column];
/** input type for updating data in table "customer" */
export type Customer_Set_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  last_name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "customer" */
export type Customer_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Customer_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Customer_Stream_Cursor_Value_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  last_name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "customer" */
export const Customer_Update_Column = {
  /** column name */
  AddressId: 'address_id',
  /** column name */
  ContactNumber: 'contact_number',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FirstName: 'first_name',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  LastName: 'last_name',
  /** column name */
  Note: 'note',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Customer_Update_Column = typeof Customer_Update_Column[keyof typeof Customer_Update_Column];
export type Customer_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Customer_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Customer_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Customer_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Customer_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Customer_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Customer_Set_Input>;
  /** filter the rows which have to be updated */
  where: Customer_Bool_Exp;
};


/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type Date_Comparison_Exp = {
  _eq?: Maybe<Scalars['date']>;
  _gt?: Maybe<Scalars['date']>;
  _gte?: Maybe<Scalars['date']>;
  _in?: Maybe<Array<Scalars['date']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['date']>;
  _lte?: Maybe<Scalars['date']>;
  _neq?: Maybe<Scalars['date']>;
  _nin?: Maybe<Array<Scalars['date']>>;
};

/** columns and relationships of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_age_verification_required?: Maybe<Scalars['Boolean']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_signature_required?: Maybe<Scalars['Boolean']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  /** An array relationship */
  fulfilment_shipment_parcels: Array<Fulfilment_Shipment_Parcel>;
  /** An aggregate relationship */
  fulfilment_shipment_parcels_aggregate: Fulfilment_Shipment_Parcel_Aggregate;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  rate_request?: Maybe<Rate_Request>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  selected_shipping_rate?: Maybe<Shipping_Rate>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  shipping_rates: Array<Shipping_Rate>;
  /** An aggregate relationship */
  shipping_rates_aggregate: Shipping_Rate_Aggregate;
  signature_upload_path?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  /** An object relationship */
  store?: Maybe<Store>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};


/** columns and relationships of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_ShipmentFulfilment_Shipment_ParcelsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


/** columns and relationships of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_ShipmentFulfilment_Shipment_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


/** columns and relationships of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_ShipmentIntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_ShipmentLabel_PathsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_ShipmentPhoto_Upload_PathsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_ShipmentShipping_RatesArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


/** columns and relationships of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_ShipmentShipping_Rates_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};

/** aggregated selection of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment_Aggregate = {
  aggregate?: Maybe<Draft_Fulfilment_Shipment_Aggregate_Fields>;
  nodes: Array<Draft_Fulfilment_Shipment>;
};

/** aggregate fields of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment_Aggregate_Fields = {
  avg?: Maybe<Draft_Fulfilment_Shipment_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Draft_Fulfilment_Shipment_Max_Fields>;
  min?: Maybe<Draft_Fulfilment_Shipment_Min_Fields>;
  stddev?: Maybe<Draft_Fulfilment_Shipment_Stddev_Fields>;
  stddev_pop?: Maybe<Draft_Fulfilment_Shipment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Draft_Fulfilment_Shipment_Stddev_Samp_Fields>;
  sum?: Maybe<Draft_Fulfilment_Shipment_Sum_Fields>;
  var_pop?: Maybe<Draft_Fulfilment_Shipment_Var_Pop_Fields>;
  var_samp?: Maybe<Draft_Fulfilment_Shipment_Var_Samp_Fields>;
  variance?: Maybe<Draft_Fulfilment_Shipment_Variance_Fields>;
};


/** aggregate fields of "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Draft_Fulfilment_Shipment_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Draft_Fulfilment_Shipment_Append_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Draft_Fulfilment_Shipment_Avg_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "draft_fulfilment_shipment". All fields are combined with a logical 'AND'. */
export type Draft_Fulfilment_Shipment_Bool_Exp = {
  _and?: Maybe<Array<Draft_Fulfilment_Shipment_Bool_Exp>>;
  _not?: Maybe<Draft_Fulfilment_Shipment_Bool_Exp>;
  _or?: Maybe<Array<Draft_Fulfilment_Shipment_Bool_Exp>>;
  address_id?: Maybe<Uuid_Comparison_Exp>;
  atl_age_verification_required?: Maybe<Boolean_Comparison_Exp>;
  atl_authority_to_leave?: Maybe<String_Comparison_Exp>;
  atl_signature_required?: Maybe<Boolean_Comparison_Exp>;
  atl_unattended_safety?: Maybe<String_Comparison_Exp>;
  base_cost?: Maybe<Int_Comparison_Exp>;
  carrier?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  delivered_at?: Maybe<Timestamptz_Comparison_Exp>;
  estimated_delivery_at?: Maybe<Timestamptz_Comparison_Exp>;
  fulfilment_service?: Maybe<String_Comparison_Exp>;
  fulfilment_shipment_parcels?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
  fulfilment_shipment_parcels_aggregate?: Maybe<Fulfilment_Shipment_Parcel_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  integrations?: Maybe<Jsonb_Comparison_Exp>;
  label_paths?: Maybe<Jsonb_Comparison_Exp>;
  manifest_id?: Maybe<Uuid_Comparison_Exp>;
  manifested_at?: Maybe<Date_Comparison_Exp>;
  photo_upload_paths?: Maybe<Jsonb_Comparison_Exp>;
  rate_request?: Maybe<Rate_Request_Bool_Exp>;
  rate_request_id?: Maybe<Uuid_Comparison_Exp>;
  sales_order_id?: Maybe<Uuid_Comparison_Exp>;
  selected_rate_id?: Maybe<Uuid_Comparison_Exp>;
  selected_shipping_rate?: Maybe<Shipping_Rate_Bool_Exp>;
  service_type?: Maybe<String_Comparison_Exp>;
  shipped_at?: Maybe<Timestamptz_Comparison_Exp>;
  shipping_margin_id?: Maybe<Uuid_Comparison_Exp>;
  shipping_rates?: Maybe<Shipping_Rate_Bool_Exp>;
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Bool_Exp>;
  signature_upload_path?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  total_cost?: Maybe<Int_Comparison_Exp>;
  total_margin?: Maybe<Int_Comparison_Exp>;
  tracking_number?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Draft_Fulfilment_Shipment_Delete_At_Path_Input = {
  integrations?: Maybe<Array<Scalars['String']>>;
  label_paths?: Maybe<Array<Scalars['String']>>;
  photo_upload_paths?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Draft_Fulfilment_Shipment_Delete_Elem_Input = {
  integrations?: Maybe<Scalars['Int']>;
  label_paths?: Maybe<Scalars['Int']>;
  photo_upload_paths?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Draft_Fulfilment_Shipment_Delete_Key_Input = {
  integrations?: Maybe<Scalars['String']>;
  label_paths?: Maybe<Scalars['String']>;
  photo_upload_paths?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment_Inc_Input = {
  base_cost?: Maybe<Scalars['Int']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment_Insert_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_age_verification_required?: Maybe<Scalars['Boolean']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_signature_required?: Maybe<Scalars['Boolean']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  fulfilment_shipment_parcels?: Maybe<Fulfilment_Shipment_Parcel_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
  rate_request?: Maybe<Rate_Request_Obj_Rel_Insert_Input>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  selected_shipping_rate?: Maybe<Shipping_Rate_Obj_Rel_Insert_Input>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  shipping_rates?: Maybe<Shipping_Rate_Arr_Rel_Insert_Input>;
  signature_upload_path?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Draft_Fulfilment_Shipment_Max_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  signature_upload_path?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Draft_Fulfilment_Shipment_Min_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  signature_upload_path?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Draft_Fulfilment_Shipment>;
};

/** input type for inserting object relation for remote table "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment_Obj_Rel_Insert_Input = {
  data: Draft_Fulfilment_Shipment_Insert_Input;
};

/** Ordering options when selecting data from "draft_fulfilment_shipment". */
export type Draft_Fulfilment_Shipment_Order_By = {
  address_id?: Maybe<Order_By>;
  atl_age_verification_required?: Maybe<Order_By>;
  atl_authority_to_leave?: Maybe<Order_By>;
  atl_signature_required?: Maybe<Order_By>;
  atl_unattended_safety?: Maybe<Order_By>;
  base_cost?: Maybe<Order_By>;
  carrier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  delivered_at?: Maybe<Order_By>;
  estimated_delivery_at?: Maybe<Order_By>;
  fulfilment_service?: Maybe<Order_By>;
  fulfilment_shipment_parcels_aggregate?: Maybe<Fulfilment_Shipment_Parcel_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  integrations?: Maybe<Order_By>;
  label_paths?: Maybe<Order_By>;
  manifest_id?: Maybe<Order_By>;
  manifested_at?: Maybe<Order_By>;
  photo_upload_paths?: Maybe<Order_By>;
  rate_request?: Maybe<Rate_Request_Order_By>;
  rate_request_id?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  selected_rate_id?: Maybe<Order_By>;
  selected_shipping_rate?: Maybe<Shipping_Rate_Order_By>;
  service_type?: Maybe<Order_By>;
  shipped_at?: Maybe<Order_By>;
  shipping_margin_id?: Maybe<Order_By>;
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Order_By>;
  signature_upload_path?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
  tracking_number?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Draft_Fulfilment_Shipment_Prepend_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "draft_fulfilment_shipment" */
export const Draft_Fulfilment_Shipment_Select_Column = {
  /** column name */
  AddressId: 'address_id',
  /** column name */
  AtlAgeVerificationRequired: 'atl_age_verification_required',
  /** column name */
  AtlAuthorityToLeave: 'atl_authority_to_leave',
  /** column name */
  AtlSignatureRequired: 'atl_signature_required',
  /** column name */
  AtlUnattendedSafety: 'atl_unattended_safety',
  /** column name */
  BaseCost: 'base_cost',
  /** column name */
  Carrier: 'carrier',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DeliveredAt: 'delivered_at',
  /** column name */
  EstimatedDeliveryAt: 'estimated_delivery_at',
  /** column name */
  FulfilmentService: 'fulfilment_service',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  LabelPaths: 'label_paths',
  /** column name */
  ManifestId: 'manifest_id',
  /** column name */
  ManifestedAt: 'manifested_at',
  /** column name */
  PhotoUploadPaths: 'photo_upload_paths',
  /** column name */
  RateRequestId: 'rate_request_id',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  SelectedRateId: 'selected_rate_id',
  /** column name */
  ServiceType: 'service_type',
  /** column name */
  ShippedAt: 'shipped_at',
  /** column name */
  ShippingMarginId: 'shipping_margin_id',
  /** column name */
  SignatureUploadPath: 'signature_upload_path',
  /** column name */
  Status: 'status',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  TotalCost: 'total_cost',
  /** column name */
  TotalMargin: 'total_margin',
  /** column name */
  TrackingNumber: 'tracking_number',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Draft_Fulfilment_Shipment_Select_Column = typeof Draft_Fulfilment_Shipment_Select_Column[keyof typeof Draft_Fulfilment_Shipment_Select_Column];
/** input type for updating data in table "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment_Set_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_age_verification_required?: Maybe<Scalars['Boolean']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_signature_required?: Maybe<Scalars['Boolean']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  signature_upload_path?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Draft_Fulfilment_Shipment_Stddev_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Draft_Fulfilment_Shipment_Stddev_Pop_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Draft_Fulfilment_Shipment_Stddev_Samp_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "draft_fulfilment_shipment" */
export type Draft_Fulfilment_Shipment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Draft_Fulfilment_Shipment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Draft_Fulfilment_Shipment_Stream_Cursor_Value_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_age_verification_required?: Maybe<Scalars['Boolean']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_signature_required?: Maybe<Scalars['Boolean']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  signature_upload_path?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Draft_Fulfilment_Shipment_Sum_Fields = {
  base_cost?: Maybe<Scalars['Int']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
};

export type Draft_Fulfilment_Shipment_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Draft_Fulfilment_Shipment_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Draft_Fulfilment_Shipment_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Draft_Fulfilment_Shipment_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Draft_Fulfilment_Shipment_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Draft_Fulfilment_Shipment_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Draft_Fulfilment_Shipment_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Draft_Fulfilment_Shipment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Draft_Fulfilment_Shipment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Draft_Fulfilment_Shipment_Var_Pop_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Draft_Fulfilment_Shipment_Var_Samp_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Draft_Fulfilment_Shipment_Variance_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "event_core.event_store" */
export type Event_Core_Event_Store = {
  created_at: Scalars['timestamptz'];
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id: Scalars['bigint'];
  metadata?: Maybe<Scalars['jsonb']>;
  payload?: Maybe<Scalars['jsonb']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  store?: Maybe<Store>;
  store_id?: Maybe<Scalars['uuid']>;
  type: Scalars['String'];
};


/** columns and relationships of "event_core.event_store" */
export type Event_Core_Event_StoreMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "event_core.event_store" */
export type Event_Core_Event_StorePayloadArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "event_core.event_store" */
export type Event_Core_Event_Store_Aggregate = {
  aggregate?: Maybe<Event_Core_Event_Store_Aggregate_Fields>;
  nodes: Array<Event_Core_Event_Store>;
};

/** aggregate fields of "event_core.event_store" */
export type Event_Core_Event_Store_Aggregate_Fields = {
  avg?: Maybe<Event_Core_Event_Store_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Event_Core_Event_Store_Max_Fields>;
  min?: Maybe<Event_Core_Event_Store_Min_Fields>;
  stddev?: Maybe<Event_Core_Event_Store_Stddev_Fields>;
  stddev_pop?: Maybe<Event_Core_Event_Store_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Event_Core_Event_Store_Stddev_Samp_Fields>;
  sum?: Maybe<Event_Core_Event_Store_Sum_Fields>;
  var_pop?: Maybe<Event_Core_Event_Store_Var_Pop_Fields>;
  var_samp?: Maybe<Event_Core_Event_Store_Var_Samp_Fields>;
  variance?: Maybe<Event_Core_Event_Store_Variance_Fields>;
};


/** aggregate fields of "event_core.event_store" */
export type Event_Core_Event_Store_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Event_Core_Event_Store_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Event_Core_Event_Store_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
  payload?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Event_Core_Event_Store_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "event_core.event_store". All fields are combined with a logical 'AND'. */
export type Event_Core_Event_Store_Bool_Exp = {
  _and?: Maybe<Array<Event_Core_Event_Store_Bool_Exp>>;
  _not?: Maybe<Event_Core_Event_Store_Bool_Exp>;
  _or?: Maybe<Array<Event_Core_Event_Store_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  fulfilment_shipment_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
  payload?: Maybe<Jsonb_Comparison_Exp>;
  sales_order_id?: Maybe<Uuid_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "event_core.event_store" */
export const Event_Core_Event_Store_Constraint = {
  /** unique or primary key constraint on columns "id" */
  EventStorePkey: 'event_store_pkey'
} as const;

export type Event_Core_Event_Store_Constraint = typeof Event_Core_Event_Store_Constraint[keyof typeof Event_Core_Event_Store_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Event_Core_Event_Store_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
  payload?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Event_Core_Event_Store_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
  payload?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Event_Core_Event_Store_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
  payload?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "event_core.event_store" */
export type Event_Core_Event_Store_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "event_core.event_store" */
export type Event_Core_Event_Store_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  metadata?: Maybe<Scalars['jsonb']>;
  payload?: Maybe<Scalars['jsonb']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Event_Core_Event_Store_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Event_Core_Event_Store_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_core.event_store" */
export type Event_Core_Event_Store_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Event_Core_Event_Store>;
};

/** on_conflict condition type for table "event_core.event_store" */
export type Event_Core_Event_Store_On_Conflict = {
  constraint: Event_Core_Event_Store_Constraint;
  update_columns?: Array<Event_Core_Event_Store_Update_Column>;
  where?: Maybe<Event_Core_Event_Store_Bool_Exp>;
};

/** Ordering options when selecting data from "event_core.event_store". */
export type Event_Core_Event_Store_Order_By = {
  created_at?: Maybe<Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  payload?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** primary key columns input for table: event_core.event_store */
export type Event_Core_Event_Store_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Event_Core_Event_Store_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
  payload?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "event_core.event_store" */
export const Event_Core_Event_Store_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  Id: 'id',
  /** column name */
  Metadata: 'metadata',
  /** column name */
  Payload: 'payload',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Type: 'type'
} as const;

export type Event_Core_Event_Store_Select_Column = typeof Event_Core_Event_Store_Select_Column[keyof typeof Event_Core_Event_Store_Select_Column];
/** input type for updating data in table "event_core.event_store" */
export type Event_Core_Event_Store_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  metadata?: Maybe<Scalars['jsonb']>;
  payload?: Maybe<Scalars['jsonb']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Event_Core_Event_Store_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Event_Core_Event_Store_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Event_Core_Event_Store_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "event_core_event_store" */
export type Event_Core_Event_Store_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Event_Core_Event_Store_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Event_Core_Event_Store_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  metadata?: Maybe<Scalars['jsonb']>;
  payload?: Maybe<Scalars['jsonb']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Event_Core_Event_Store_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "event_core.event_store" */
export const Event_Core_Event_Store_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  Id: 'id',
  /** column name */
  Metadata: 'metadata',
  /** column name */
  Payload: 'payload',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Type: 'type'
} as const;

export type Event_Core_Event_Store_Update_Column = typeof Event_Core_Event_Store_Update_Column[keyof typeof Event_Core_Event_Store_Update_Column];
export type Event_Core_Event_Store_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Event_Core_Event_Store_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Event_Core_Event_Store_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Event_Core_Event_Store_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Event_Core_Event_Store_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Event_Core_Event_Store_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Event_Core_Event_Store_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Event_Core_Event_Store_Set_Input>;
  /** filter the rows which have to be updated */
  where: Event_Core_Event_Store_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Event_Core_Event_Store_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Event_Core_Event_Store_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Event_Core_Event_Store_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "feature_flag" */
export type Feature_Flag = {
  /** An array relationship */
  store_feature_flags: Array<Store_Feature_Flag>;
  /** An aggregate relationship */
  store_feature_flags_aggregate: Store_Feature_Flag_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "feature_flag" */
export type Feature_FlagStore_Feature_FlagsArgs = {
  distinct_on?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Feature_Flag_Order_By>>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};


/** columns and relationships of "feature_flag" */
export type Feature_FlagStore_Feature_Flags_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Feature_Flag_Order_By>>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};

/** aggregated selection of "feature_flag" */
export type Feature_Flag_Aggregate = {
  aggregate?: Maybe<Feature_Flag_Aggregate_Fields>;
  nodes: Array<Feature_Flag>;
};

/** aggregate fields of "feature_flag" */
export type Feature_Flag_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Feature_Flag_Max_Fields>;
  min?: Maybe<Feature_Flag_Min_Fields>;
};


/** aggregate fields of "feature_flag" */
export type Feature_Flag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Feature_Flag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "feature_flag". All fields are combined with a logical 'AND'. */
export type Feature_Flag_Bool_Exp = {
  _and?: Maybe<Array<Feature_Flag_Bool_Exp>>;
  _not?: Maybe<Feature_Flag_Bool_Exp>;
  _or?: Maybe<Array<Feature_Flag_Bool_Exp>>;
  store_feature_flags?: Maybe<Store_Feature_Flag_Bool_Exp>;
  store_feature_flags_aggregate?: Maybe<Store_Feature_Flag_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "feature_flag" */
export const Feature_Flag_Constraint = {
  /** unique or primary key constraint on columns "value" */
  FeatureFlagPkey: 'feature_flag_pkey'
} as const;

export type Feature_Flag_Constraint = typeof Feature_Flag_Constraint[keyof typeof Feature_Flag_Constraint];
export const Feature_Flag_Enum = {
  BulkBooking: 'BULK_BOOKING',
  DisableFloralyWebhooks: 'DISABLE_FLORALY_WEBHOOKS',
  IsExternalPickupLocation: 'IS_EXTERNAL_PICKUP_LOCATION',
  RedesignReloaded: 'REDESIGN_RELOADED',
  RedesignReloadedLegacy: 'REDESIGN_RELOADED_LEGACY',
  ScheduledShipments: 'SCHEDULED_SHIPMENTS',
  TrackingEmailOnShipmentAssigned: 'TRACKING_EMAIL_ON_SHIPMENT_ASSIGNED',
  ViewInventory: 'VIEW_INVENTORY'
} as const;

export type Feature_Flag_Enum = typeof Feature_Flag_Enum[keyof typeof Feature_Flag_Enum];
/** Boolean expression to compare columns of type "feature_flag_enum". All fields are combined with logical 'AND'. */
export type Feature_Flag_Enum_Comparison_Exp = {
  _eq?: Maybe<Feature_Flag_Enum>;
  _in?: Maybe<Array<Feature_Flag_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Feature_Flag_Enum>;
  _nin?: Maybe<Array<Feature_Flag_Enum>>;
};

/** input type for inserting data into table "feature_flag" */
export type Feature_Flag_Insert_Input = {
  store_feature_flags?: Maybe<Store_Feature_Flag_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Feature_Flag_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Feature_Flag_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "feature_flag" */
export type Feature_Flag_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Feature_Flag>;
};

/** input type for inserting object relation for remote table "feature_flag" */
export type Feature_Flag_Obj_Rel_Insert_Input = {
  data: Feature_Flag_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Feature_Flag_On_Conflict>;
};

/** on_conflict condition type for table "feature_flag" */
export type Feature_Flag_On_Conflict = {
  constraint: Feature_Flag_Constraint;
  update_columns?: Array<Feature_Flag_Update_Column>;
  where?: Maybe<Feature_Flag_Bool_Exp>;
};

/** Ordering options when selecting data from "feature_flag". */
export type Feature_Flag_Order_By = {
  store_feature_flags_aggregate?: Maybe<Store_Feature_Flag_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: feature_flag */
export type Feature_Flag_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "feature_flag" */
export const Feature_Flag_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Feature_Flag_Select_Column = typeof Feature_Flag_Select_Column[keyof typeof Feature_Flag_Select_Column];
/** input type for updating data in table "feature_flag" */
export type Feature_Flag_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "feature_flag" */
export type Feature_Flag_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Feature_Flag_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Feature_Flag_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "feature_flag" */
export const Feature_Flag_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Feature_Flag_Update_Column = typeof Feature_Flag_Update_Column[keyof typeof Feature_Flag_Update_Column];
export type Feature_Flag_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Feature_Flag_Set_Input>;
  /** filter the rows which have to be updated */
  where: Feature_Flag_Bool_Exp;
};


/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq?: Maybe<Scalars['float8']>;
  _gt?: Maybe<Scalars['float8']>;
  _gte?: Maybe<Scalars['float8']>;
  _in?: Maybe<Array<Scalars['float8']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['float8']>;
  _lte?: Maybe<Scalars['float8']>;
  _neq?: Maybe<Scalars['float8']>;
  _nin?: Maybe<Array<Scalars['float8']>>;
};

/** columns and relationships of "fulfilment_center" */
export type Fulfilment_Center = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at: Scalars['timestamptz'];
  /** An array relationship */
  fulfilment_center_carriers: Array<Fulfilment_Center_Carrier>;
  /** An aggregate relationship */
  fulfilment_center_carriers_aggregate: Fulfilment_Center_Carrier_Aggregate;
  id: Scalars['bigint'];
  name: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "fulfilment_center" */
export type Fulfilment_CenterFulfilment_Center_CarriersArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Carrier_Order_By>>;
  where?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
};


/** columns and relationships of "fulfilment_center" */
export type Fulfilment_CenterFulfilment_Center_Carriers_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Carrier_Order_By>>;
  where?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
};

/** aggregated selection of "fulfilment_center" */
export type Fulfilment_Center_Aggregate = {
  aggregate?: Maybe<Fulfilment_Center_Aggregate_Fields>;
  nodes: Array<Fulfilment_Center>;
};

/** aggregate fields of "fulfilment_center" */
export type Fulfilment_Center_Aggregate_Fields = {
  avg?: Maybe<Fulfilment_Center_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Fulfilment_Center_Max_Fields>;
  min?: Maybe<Fulfilment_Center_Min_Fields>;
  stddev?: Maybe<Fulfilment_Center_Stddev_Fields>;
  stddev_pop?: Maybe<Fulfilment_Center_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Fulfilment_Center_Stddev_Samp_Fields>;
  sum?: Maybe<Fulfilment_Center_Sum_Fields>;
  var_pop?: Maybe<Fulfilment_Center_Var_Pop_Fields>;
  var_samp?: Maybe<Fulfilment_Center_Var_Samp_Fields>;
  variance?: Maybe<Fulfilment_Center_Variance_Fields>;
};


/** aggregate fields of "fulfilment_center" */
export type Fulfilment_Center_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Fulfilment_Center_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Fulfilment_Center_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "fulfilment_center". All fields are combined with a logical 'AND'. */
export type Fulfilment_Center_Bool_Exp = {
  _and?: Maybe<Array<Fulfilment_Center_Bool_Exp>>;
  _not?: Maybe<Fulfilment_Center_Bool_Exp>;
  _or?: Maybe<Array<Fulfilment_Center_Bool_Exp>>;
  address_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  fulfilment_center_carriers?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
  fulfilment_center_carriers_aggregate?: Maybe<Fulfilment_Center_Carrier_Aggregate_Bool_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** columns and relationships of "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier = {
  created_at: Scalars['timestamptz'];
  fulfilment_center_id: Scalars['bigint'];
  id: Scalars['bigint'];
  name: Scalars['String'];
  provider: Shipping_Provider_Enum;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "fulfilment_center_carrier" */
export type Fulfilment_Center_CarrierShipping_Aggregator_IntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Aggregate = {
  aggregate?: Maybe<Fulfilment_Center_Carrier_Aggregate_Fields>;
  nodes: Array<Fulfilment_Center_Carrier>;
};

export type Fulfilment_Center_Carrier_Aggregate_Bool_Exp = {
  count?: Maybe<Fulfilment_Center_Carrier_Aggregate_Bool_Exp_Count>;
};

export type Fulfilment_Center_Carrier_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Fulfilment_Center_Carrier_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Aggregate_Fields = {
  avg?: Maybe<Fulfilment_Center_Carrier_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Fulfilment_Center_Carrier_Max_Fields>;
  min?: Maybe<Fulfilment_Center_Carrier_Min_Fields>;
  stddev?: Maybe<Fulfilment_Center_Carrier_Stddev_Fields>;
  stddev_pop?: Maybe<Fulfilment_Center_Carrier_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Fulfilment_Center_Carrier_Stddev_Samp_Fields>;
  sum?: Maybe<Fulfilment_Center_Carrier_Sum_Fields>;
  var_pop?: Maybe<Fulfilment_Center_Carrier_Var_Pop_Fields>;
  var_samp?: Maybe<Fulfilment_Center_Carrier_Var_Samp_Fields>;
  variance?: Maybe<Fulfilment_Center_Carrier_Variance_Fields>;
};


/** aggregate fields of "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Fulfilment_Center_Carrier_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Aggregate_Order_By = {
  avg?: Maybe<Fulfilment_Center_Carrier_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Fulfilment_Center_Carrier_Max_Order_By>;
  min?: Maybe<Fulfilment_Center_Carrier_Min_Order_By>;
  stddev?: Maybe<Fulfilment_Center_Carrier_Stddev_Order_By>;
  stddev_pop?: Maybe<Fulfilment_Center_Carrier_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Fulfilment_Center_Carrier_Stddev_Samp_Order_By>;
  sum?: Maybe<Fulfilment_Center_Carrier_Sum_Order_By>;
  var_pop?: Maybe<Fulfilment_Center_Carrier_Var_Pop_Order_By>;
  var_samp?: Maybe<Fulfilment_Center_Carrier_Var_Samp_Order_By>;
  variance?: Maybe<Fulfilment_Center_Carrier_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Fulfilment_Center_Carrier_Append_Input = {
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Arr_Rel_Insert_Input = {
  data: Array<Fulfilment_Center_Carrier_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Fulfilment_Center_Carrier_On_Conflict>;
};

/** aggregate avg on columns */
export type Fulfilment_Center_Carrier_Avg_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Avg_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "fulfilment_center_carrier". All fields are combined with a logical 'AND'. */
export type Fulfilment_Center_Carrier_Bool_Exp = {
  _and?: Maybe<Array<Fulfilment_Center_Carrier_Bool_Exp>>;
  _not?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
  _or?: Maybe<Array<Fulfilment_Center_Carrier_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  fulfilment_center_id?: Maybe<Bigint_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  provider?: Maybe<Shipping_Provider_Enum_Comparison_Exp>;
  shipping_aggregator_integrations?: Maybe<Jsonb_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "fulfilment_center_carrier" */
export const Fulfilment_Center_Carrier_Constraint = {
  /** unique or primary key constraint on columns "id" */
  FulfilmentCenterCarrierPk: 'fulfilment_center_carrier_pk'
} as const;

export type Fulfilment_Center_Carrier_Constraint = typeof Fulfilment_Center_Carrier_Constraint[keyof typeof Fulfilment_Center_Carrier_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Fulfilment_Center_Carrier_Delete_At_Path_Input = {
  shipping_aggregator_integrations?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Fulfilment_Center_Carrier_Delete_Elem_Input = {
  shipping_aggregator_integrations?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Fulfilment_Center_Carrier_Delete_Key_Input = {
  shipping_aggregator_integrations?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Inc_Input = {
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  provider?: Maybe<Shipping_Provider_Enum>;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Fulfilment_Center_Carrier_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Fulfilment_Center_Carrier_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Fulfilment_Center_Carrier>;
};

/** input type for inserting object relation for remote table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Obj_Rel_Insert_Input = {
  data: Fulfilment_Center_Carrier_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Fulfilment_Center_Carrier_On_Conflict>;
};

/** on_conflict condition type for table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_On_Conflict = {
  constraint: Fulfilment_Center_Carrier_Constraint;
  update_columns?: Array<Fulfilment_Center_Carrier_Update_Column>;
  where?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
};

/** Ordering options when selecting data from "fulfilment_center_carrier". */
export type Fulfilment_Center_Carrier_Order_By = {
  created_at?: Maybe<Order_By>;
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  provider?: Maybe<Order_By>;
  shipping_aggregator_integrations?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: fulfilment_center_carrier */
export type Fulfilment_Center_Carrier_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Fulfilment_Center_Carrier_Prepend_Input = {
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "fulfilment_center_carrier" */
export const Fulfilment_Center_Carrier_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FulfilmentCenterId: 'fulfilment_center_id',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  Provider: 'provider',
  /** column name */
  ShippingAggregatorIntegrations: 'shipping_aggregator_integrations',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Fulfilment_Center_Carrier_Select_Column = typeof Fulfilment_Center_Carrier_Select_Column[keyof typeof Fulfilment_Center_Carrier_Select_Column];
/** input type for updating data in table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  provider?: Maybe<Shipping_Provider_Enum>;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Fulfilment_Center_Carrier_Stddev_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Stddev_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Fulfilment_Center_Carrier_Stddev_Pop_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Stddev_Pop_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Fulfilment_Center_Carrier_Stddev_Samp_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Stddev_Samp_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fulfilment_Center_Carrier_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fulfilment_Center_Carrier_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  provider?: Maybe<Shipping_Provider_Enum>;
  shipping_aggregator_integrations?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Fulfilment_Center_Carrier_Sum_Fields = {
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Sum_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** update columns of table "fulfilment_center_carrier" */
export const Fulfilment_Center_Carrier_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FulfilmentCenterId: 'fulfilment_center_id',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  Provider: 'provider',
  /** column name */
  ShippingAggregatorIntegrations: 'shipping_aggregator_integrations',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Fulfilment_Center_Carrier_Update_Column = typeof Fulfilment_Center_Carrier_Update_Column[keyof typeof Fulfilment_Center_Carrier_Update_Column];
export type Fulfilment_Center_Carrier_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Fulfilment_Center_Carrier_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Fulfilment_Center_Carrier_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Fulfilment_Center_Carrier_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Fulfilment_Center_Carrier_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Fulfilment_Center_Carrier_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Fulfilment_Center_Carrier_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Fulfilment_Center_Carrier_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fulfilment_Center_Carrier_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fulfilment_Center_Carrier_Var_Pop_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Var_Pop_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Fulfilment_Center_Carrier_Var_Samp_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Var_Samp_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Fulfilment_Center_Carrier_Variance_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "fulfilment_center_carrier" */
export type Fulfilment_Center_Carrier_Variance_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** unique or primary key constraints on table "fulfilment_center" */
export const Fulfilment_Center_Constraint = {
  /** unique or primary key constraint on columns "id" */
  FulfilmentCenterPk: 'fulfilment_center_pk'
} as const;

export type Fulfilment_Center_Constraint = typeof Fulfilment_Center_Constraint[keyof typeof Fulfilment_Center_Constraint];
/** input type for incrementing numeric columns in table "fulfilment_center" */
export type Fulfilment_Center_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "fulfilment_center" */
export type Fulfilment_Center_Insert_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_carriers?: Maybe<Fulfilment_Center_Carrier_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Fulfilment_Center_Max_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Fulfilment_Center_Min_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "fulfilment_center" */
export type Fulfilment_Center_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Fulfilment_Center>;
};

/** input type for inserting object relation for remote table "fulfilment_center" */
export type Fulfilment_Center_Obj_Rel_Insert_Input = {
  data: Fulfilment_Center_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Fulfilment_Center_On_Conflict>;
};

/** on_conflict condition type for table "fulfilment_center" */
export type Fulfilment_Center_On_Conflict = {
  constraint: Fulfilment_Center_Constraint;
  update_columns?: Array<Fulfilment_Center_Update_Column>;
  where?: Maybe<Fulfilment_Center_Bool_Exp>;
};

/** Ordering options when selecting data from "fulfilment_center". */
export type Fulfilment_Center_Order_By = {
  address_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fulfilment_center_carriers_aggregate?: Maybe<Fulfilment_Center_Carrier_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: fulfilment_center */
export type Fulfilment_Center_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "fulfilment_center" */
export const Fulfilment_Center_Select_Column = {
  /** column name */
  AddressId: 'address_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Fulfilment_Center_Select_Column = typeof Fulfilment_Center_Select_Column[keyof typeof Fulfilment_Center_Select_Column];
/** input type for updating data in table "fulfilment_center" */
export type Fulfilment_Center_Set_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Fulfilment_Center_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Fulfilment_Center_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Fulfilment_Center_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "fulfilment_center" */
export type Fulfilment_Center_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fulfilment_Center_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fulfilment_Center_Stream_Cursor_Value_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Fulfilment_Center_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "fulfilment_center" */
export const Fulfilment_Center_Update_Column = {
  /** column name */
  AddressId: 'address_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Fulfilment_Center_Update_Column = typeof Fulfilment_Center_Update_Column[keyof typeof Fulfilment_Center_Update_Column];
export type Fulfilment_Center_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Fulfilment_Center_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Fulfilment_Center_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fulfilment_Center_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fulfilment_Center_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Fulfilment_Center_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Fulfilment_Center_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_Shipment = {
  /** An object relationship */
  address?: Maybe<Address>;
  address_id?: Maybe<Scalars['uuid']>;
  atl_age_verification_required?: Maybe<Scalars['Boolean']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_signature_required?: Maybe<Scalars['Boolean']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  delivered_at?: Maybe<Scalars['timestamptz']>;
  error?: Maybe<Scalars['jsonb']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  /** An array relationship */
  fulfilment_shipment_line_items: Array<Fulfilment_Shipment_Line_Item>;
  /** An aggregate relationship */
  fulfilment_shipment_line_items_aggregate: Fulfilment_Shipment_Line_Item_Aggregate;
  /** An array relationship */
  fulfilment_shipment_parcels: Array<Fulfilment_Shipment_Parcel>;
  /** An aggregate relationship */
  fulfilment_shipment_parcels_aggregate: Fulfilment_Shipment_Parcel_Aggregate;
  /** A computed field, executes function "get_fulfilment_shipment_gross_weight" */
  gross_weight_gram?: Maybe<Scalars['Int']>;
  id: Scalars['uuid'];
  integrations?: Maybe<Scalars['jsonb']>;
  label_booked_at?: Maybe<Scalars['timestamptz']>;
  label_last_downloaded_at?: Maybe<Scalars['timestamptz']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  location?: Maybe<Location>;
  location_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  manifest?: Maybe<Manifest>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  packing_slip_document_path?: Maybe<Scalars['String']>;
  photo_upload_paths: Scalars['jsonb'];
  /** An object relationship */
  rate_request?: Maybe<Rate_Request>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  sales_order: Sales_Order;
  sales_order_id: Scalars['uuid'];
  scheduled_pickup_date?: Maybe<Scalars['date']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  selected_shipping_rate?: Maybe<Shipping_Rate>;
  service_type?: Maybe<Scalars['String']>;
  /** An object relationship */
  shipment_source: Shipment_Source;
  /** An object relationship */
  shipment_status: Shipment_Status;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  shipping_margin?: Maybe<Shipping_Margin>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  shipping_rates: Array<Shipping_Rate>;
  /** An aggregate relationship */
  shipping_rates_aggregate: Shipping_Rate_Aggregate;
  signature_upload_path?: Maybe<Scalars['String']>;
  source: Shipment_Source_Enum;
  status: Shipment_Status_Enum;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentErrorArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentFulfilment_Shipment_Line_ItemsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Line_Item_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentFulfilment_Shipment_Line_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Line_Item_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentFulfilment_Shipment_ParcelsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentFulfilment_Shipment_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentIntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentLabel_PathsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentPhoto_Upload_PathsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentShipping_RatesArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


/** columns and relationships of "fulfilment_shipment" */
export type Fulfilment_ShipmentShipping_Rates_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};

/** aggregated selection of "fulfilment_shipment" */
export type Fulfilment_Shipment_Aggregate = {
  aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Fields>;
  nodes: Array<Fulfilment_Shipment>;
};

export type Fulfilment_Shipment_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp_Count>;
};

export type Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_And = {
  arguments: Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Fulfilment_Shipment_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "fulfilment_shipment" */
export type Fulfilment_Shipment_Aggregate_Fields = {
  avg?: Maybe<Fulfilment_Shipment_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Fulfilment_Shipment_Max_Fields>;
  min?: Maybe<Fulfilment_Shipment_Min_Fields>;
  stddev?: Maybe<Fulfilment_Shipment_Stddev_Fields>;
  stddev_pop?: Maybe<Fulfilment_Shipment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Fulfilment_Shipment_Stddev_Samp_Fields>;
  sum?: Maybe<Fulfilment_Shipment_Sum_Fields>;
  var_pop?: Maybe<Fulfilment_Shipment_Var_Pop_Fields>;
  var_samp?: Maybe<Fulfilment_Shipment_Var_Samp_Fields>;
  variance?: Maybe<Fulfilment_Shipment_Variance_Fields>;
};


/** aggregate fields of "fulfilment_shipment" */
export type Fulfilment_Shipment_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Aggregate_Order_By = {
  avg?: Maybe<Fulfilment_Shipment_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Fulfilment_Shipment_Max_Order_By>;
  min?: Maybe<Fulfilment_Shipment_Min_Order_By>;
  stddev?: Maybe<Fulfilment_Shipment_Stddev_Order_By>;
  stddev_pop?: Maybe<Fulfilment_Shipment_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Fulfilment_Shipment_Stddev_Samp_Order_By>;
  sum?: Maybe<Fulfilment_Shipment_Sum_Order_By>;
  var_pop?: Maybe<Fulfilment_Shipment_Var_Pop_Order_By>;
  var_samp?: Maybe<Fulfilment_Shipment_Var_Samp_Order_By>;
  variance?: Maybe<Fulfilment_Shipment_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Fulfilment_Shipment_Append_Input = {
  error?: Maybe<Scalars['jsonb']>;
  integrations?: Maybe<Scalars['jsonb']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "fulfilment_shipment" */
export type Fulfilment_Shipment_Arr_Rel_Insert_Input = {
  data: Array<Fulfilment_Shipment_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Fulfilment_Shipment_On_Conflict>;
};

/** aggregate avg on columns */
export type Fulfilment_Shipment_Avg_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Avg_Order_By = {
  base_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "fulfilment_shipment". All fields are combined with a logical 'AND'. */
export type Fulfilment_Shipment_Bool_Exp = {
  _and?: Maybe<Array<Fulfilment_Shipment_Bool_Exp>>;
  _not?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  _or?: Maybe<Array<Fulfilment_Shipment_Bool_Exp>>;
  address?: Maybe<Address_Bool_Exp>;
  address_id?: Maybe<Uuid_Comparison_Exp>;
  atl_age_verification_required?: Maybe<Boolean_Comparison_Exp>;
  atl_authority_to_leave?: Maybe<String_Comparison_Exp>;
  atl_signature_required?: Maybe<Boolean_Comparison_Exp>;
  atl_unattended_safety?: Maybe<String_Comparison_Exp>;
  base_cost?: Maybe<Int_Comparison_Exp>;
  carrier?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  delivered_at?: Maybe<Timestamptz_Comparison_Exp>;
  error?: Maybe<Jsonb_Comparison_Exp>;
  estimated_delivery_at?: Maybe<Timestamptz_Comparison_Exp>;
  fulfilment_service?: Maybe<String_Comparison_Exp>;
  fulfilment_shipment_line_items?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
  fulfilment_shipment_line_items_aggregate?: Maybe<Fulfilment_Shipment_Line_Item_Aggregate_Bool_Exp>;
  fulfilment_shipment_parcels?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
  fulfilment_shipment_parcels_aggregate?: Maybe<Fulfilment_Shipment_Parcel_Aggregate_Bool_Exp>;
  gross_weight_gram?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  integrations?: Maybe<Jsonb_Comparison_Exp>;
  label_booked_at?: Maybe<Timestamptz_Comparison_Exp>;
  label_last_downloaded_at?: Maybe<Timestamptz_Comparison_Exp>;
  label_paths?: Maybe<Jsonb_Comparison_Exp>;
  location?: Maybe<Location_Bool_Exp>;
  location_id?: Maybe<Uuid_Comparison_Exp>;
  manifest?: Maybe<Manifest_Bool_Exp>;
  manifest_id?: Maybe<Uuid_Comparison_Exp>;
  manifested_at?: Maybe<Date_Comparison_Exp>;
  packing_slip_document_path?: Maybe<String_Comparison_Exp>;
  photo_upload_paths?: Maybe<Jsonb_Comparison_Exp>;
  rate_request?: Maybe<Rate_Request_Bool_Exp>;
  rate_request_id?: Maybe<Uuid_Comparison_Exp>;
  sales_order?: Maybe<Sales_Order_Bool_Exp>;
  sales_order_id?: Maybe<Uuid_Comparison_Exp>;
  scheduled_pickup_date?: Maybe<Date_Comparison_Exp>;
  selected_rate_id?: Maybe<Uuid_Comparison_Exp>;
  selected_shipping_rate?: Maybe<Shipping_Rate_Bool_Exp>;
  service_type?: Maybe<String_Comparison_Exp>;
  shipment_source?: Maybe<Shipment_Source_Bool_Exp>;
  shipment_status?: Maybe<Shipment_Status_Bool_Exp>;
  shipped_at?: Maybe<Timestamptz_Comparison_Exp>;
  shipping_margin?: Maybe<Shipping_Margin_Bool_Exp>;
  shipping_margin_id?: Maybe<Uuid_Comparison_Exp>;
  shipping_rates?: Maybe<Shipping_Rate_Bool_Exp>;
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Bool_Exp>;
  signature_upload_path?: Maybe<String_Comparison_Exp>;
  source?: Maybe<Shipment_Source_Enum_Comparison_Exp>;
  status?: Maybe<Shipment_Status_Enum_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  total_cost?: Maybe<Int_Comparison_Exp>;
  total_margin?: Maybe<Int_Comparison_Exp>;
  tracking_number?: Maybe<String_Comparison_Exp>;
  tracking_url?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "fulfilment_shipment" */
export const Fulfilment_Shipment_Constraint = {
  /** unique or primary key constraint on columns "id" */
  FulfilmentShipmentPkey: 'fulfilment_shipment_pkey',
  /** unique or primary key constraint on columns "rate_request_id" */
  FulfilmentShipmentRateRequestIdKey: 'fulfilment_shipment_rate_request_id_key'
} as const;

export type Fulfilment_Shipment_Constraint = typeof Fulfilment_Shipment_Constraint[keyof typeof Fulfilment_Shipment_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Fulfilment_Shipment_Delete_At_Path_Input = {
  error?: Maybe<Array<Scalars['String']>>;
  integrations?: Maybe<Array<Scalars['String']>>;
  label_paths?: Maybe<Array<Scalars['String']>>;
  photo_upload_paths?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Fulfilment_Shipment_Delete_Elem_Input = {
  error?: Maybe<Scalars['Int']>;
  integrations?: Maybe<Scalars['Int']>;
  label_paths?: Maybe<Scalars['Int']>;
  photo_upload_paths?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Fulfilment_Shipment_Delete_Key_Input = {
  error?: Maybe<Scalars['String']>;
  integrations?: Maybe<Scalars['String']>;
  label_paths?: Maybe<Scalars['String']>;
  photo_upload_paths?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "fulfilment_shipment" */
export type Fulfilment_Shipment_Inc_Input = {
  base_cost?: Maybe<Scalars['Int']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "fulfilment_shipment" */
export type Fulfilment_Shipment_Insert_Input = {
  address?: Maybe<Address_Obj_Rel_Insert_Input>;
  address_id?: Maybe<Scalars['uuid']>;
  atl_age_verification_required?: Maybe<Scalars['Boolean']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_signature_required?: Maybe<Scalars['Boolean']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  error?: Maybe<Scalars['jsonb']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  fulfilment_shipment_line_items?: Maybe<Fulfilment_Shipment_Line_Item_Arr_Rel_Insert_Input>;
  fulfilment_shipment_parcels?: Maybe<Fulfilment_Shipment_Parcel_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  label_booked_at?: Maybe<Scalars['timestamptz']>;
  label_last_downloaded_at?: Maybe<Scalars['timestamptz']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  location?: Maybe<Location_Obj_Rel_Insert_Input>;
  location_id?: Maybe<Scalars['uuid']>;
  manifest?: Maybe<Manifest_Obj_Rel_Insert_Input>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  packing_slip_document_path?: Maybe<Scalars['String']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
  rate_request?: Maybe<Rate_Request_Obj_Rel_Insert_Input>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order?: Maybe<Sales_Order_Obj_Rel_Insert_Input>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  scheduled_pickup_date?: Maybe<Scalars['date']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  selected_shipping_rate?: Maybe<Shipping_Rate_Obj_Rel_Insert_Input>;
  service_type?: Maybe<Scalars['String']>;
  shipment_source?: Maybe<Shipment_Source_Obj_Rel_Insert_Input>;
  shipment_status?: Maybe<Shipment_Status_Obj_Rel_Insert_Input>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin?: Maybe<Shipping_Margin_Obj_Rel_Insert_Input>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  shipping_rates?: Maybe<Shipping_Rate_Arr_Rel_Insert_Input>;
  signature_upload_path?: Maybe<Scalars['String']>;
  source?: Maybe<Shipment_Source_Enum>;
  status?: Maybe<Shipment_Status_Enum>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item = {
  barcode?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  fulfilment_shipment: Fulfilment_Shipment;
  fulfilment_shipment_id: Scalars['uuid'];
  fulfilment_shipment_parcel_id?: Maybe<Scalars['uuid']>;
  id: Scalars['bigint'];
  name?: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
  /** An object relationship */
  sales_order_line_item?: Maybe<Sales_Order_Line_Item>;
  sales_order_line_item_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Aggregate = {
  aggregate?: Maybe<Fulfilment_Shipment_Line_Item_Aggregate_Fields>;
  nodes: Array<Fulfilment_Shipment_Line_Item>;
};

export type Fulfilment_Shipment_Line_Item_Aggregate_Bool_Exp = {
  count?: Maybe<Fulfilment_Shipment_Line_Item_Aggregate_Bool_Exp_Count>;
};

export type Fulfilment_Shipment_Line_Item_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Fulfilment_Shipment_Line_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Aggregate_Fields = {
  avg?: Maybe<Fulfilment_Shipment_Line_Item_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Fulfilment_Shipment_Line_Item_Max_Fields>;
  min?: Maybe<Fulfilment_Shipment_Line_Item_Min_Fields>;
  stddev?: Maybe<Fulfilment_Shipment_Line_Item_Stddev_Fields>;
  stddev_pop?: Maybe<Fulfilment_Shipment_Line_Item_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Fulfilment_Shipment_Line_Item_Stddev_Samp_Fields>;
  sum?: Maybe<Fulfilment_Shipment_Line_Item_Sum_Fields>;
  var_pop?: Maybe<Fulfilment_Shipment_Line_Item_Var_Pop_Fields>;
  var_samp?: Maybe<Fulfilment_Shipment_Line_Item_Var_Samp_Fields>;
  variance?: Maybe<Fulfilment_Shipment_Line_Item_Variance_Fields>;
};


/** aggregate fields of "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Fulfilment_Shipment_Line_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Aggregate_Order_By = {
  avg?: Maybe<Fulfilment_Shipment_Line_Item_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Fulfilment_Shipment_Line_Item_Max_Order_By>;
  min?: Maybe<Fulfilment_Shipment_Line_Item_Min_Order_By>;
  stddev?: Maybe<Fulfilment_Shipment_Line_Item_Stddev_Order_By>;
  stddev_pop?: Maybe<Fulfilment_Shipment_Line_Item_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Fulfilment_Shipment_Line_Item_Stddev_Samp_Order_By>;
  sum?: Maybe<Fulfilment_Shipment_Line_Item_Sum_Order_By>;
  var_pop?: Maybe<Fulfilment_Shipment_Line_Item_Var_Pop_Order_By>;
  var_samp?: Maybe<Fulfilment_Shipment_Line_Item_Var_Samp_Order_By>;
  variance?: Maybe<Fulfilment_Shipment_Line_Item_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Arr_Rel_Insert_Input = {
  data: Array<Fulfilment_Shipment_Line_Item_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Fulfilment_Shipment_Line_Item_On_Conflict>;
};

/** aggregate avg on columns */
export type Fulfilment_Shipment_Line_Item_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Avg_Order_By = {
  id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "fulfilment_shipment_line_item". All fields are combined with a logical 'AND'. */
export type Fulfilment_Shipment_Line_Item_Bool_Exp = {
  _and?: Maybe<Array<Fulfilment_Shipment_Line_Item_Bool_Exp>>;
  _not?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
  _or?: Maybe<Array<Fulfilment_Shipment_Line_Item_Bool_Exp>>;
  barcode?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipment_id?: Maybe<Uuid_Comparison_Exp>;
  fulfilment_shipment_parcel_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  quantity?: Maybe<Int_Comparison_Exp>;
  sales_order_line_item?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
  sales_order_line_item_id?: Maybe<Uuid_Comparison_Exp>;
  sku?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "fulfilment_shipment_line_item" */
export const Fulfilment_Shipment_Line_Item_Constraint = {
  /** unique or primary key constraint on columns "id" */
  FulfilmentShipmentLineItemPkey: 'fulfilment_shipment_line_item_pkey'
} as const;

export type Fulfilment_Shipment_Line_Item_Constraint = typeof Fulfilment_Shipment_Line_Item_Constraint[keyof typeof Fulfilment_Shipment_Line_Item_Constraint];
/** input type for incrementing numeric columns in table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Insert_Input = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment_Obj_Rel_Insert_Input>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  fulfilment_shipment_parcel_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  sales_order_line_item?: Maybe<Sales_Order_Line_Item_Obj_Rel_Insert_Input>;
  sales_order_line_item_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Fulfilment_Shipment_Line_Item_Max_Fields = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  fulfilment_shipment_parcel_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  sales_order_line_item_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Max_Order_By = {
  barcode?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  fulfilment_shipment_parcel_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  sales_order_line_item_id?: Maybe<Order_By>;
  sku?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Fulfilment_Shipment_Line_Item_Min_Fields = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  fulfilment_shipment_parcel_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  sales_order_line_item_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Min_Order_By = {
  barcode?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  fulfilment_shipment_parcel_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  sales_order_line_item_id?: Maybe<Order_By>;
  sku?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Fulfilment_Shipment_Line_Item>;
};

/** on_conflict condition type for table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_On_Conflict = {
  constraint: Fulfilment_Shipment_Line_Item_Constraint;
  update_columns?: Array<Fulfilment_Shipment_Line_Item_Update_Column>;
  where?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
};

/** Ordering options when selecting data from "fulfilment_shipment_line_item". */
export type Fulfilment_Shipment_Line_Item_Order_By = {
  barcode?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment_Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  fulfilment_shipment_parcel_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  sales_order_line_item?: Maybe<Sales_Order_Line_Item_Order_By>;
  sales_order_line_item_id?: Maybe<Order_By>;
  sku?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: fulfilment_shipment_line_item */
export type Fulfilment_Shipment_Line_Item_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "fulfilment_shipment_line_item" */
export const Fulfilment_Shipment_Line_Item_Select_Column = {
  /** column name */
  Barcode: 'barcode',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  FulfilmentShipmentParcelId: 'fulfilment_shipment_parcel_id',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  Quantity: 'quantity',
  /** column name */
  SalesOrderLineItemId: 'sales_order_line_item_id',
  /** column name */
  Sku: 'sku',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Fulfilment_Shipment_Line_Item_Select_Column = typeof Fulfilment_Shipment_Line_Item_Select_Column[keyof typeof Fulfilment_Shipment_Line_Item_Select_Column];
/** input type for updating data in table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Set_Input = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  fulfilment_shipment_parcel_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  sales_order_line_item_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Fulfilment_Shipment_Line_Item_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Fulfilment_Shipment_Line_Item_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Fulfilment_Shipment_Line_Item_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
};

/** Streaming cursor of the table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fulfilment_Shipment_Line_Item_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fulfilment_Shipment_Line_Item_Stream_Cursor_Value_Input = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  fulfilment_shipment_parcel_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  sales_order_line_item_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Fulfilment_Shipment_Line_Item_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Sum_Order_By = {
  id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
};

/** update columns of table "fulfilment_shipment_line_item" */
export const Fulfilment_Shipment_Line_Item_Update_Column = {
  /** column name */
  Barcode: 'barcode',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  FulfilmentShipmentParcelId: 'fulfilment_shipment_parcel_id',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  Quantity: 'quantity',
  /** column name */
  SalesOrderLineItemId: 'sales_order_line_item_id',
  /** column name */
  Sku: 'sku',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Fulfilment_Shipment_Line_Item_Update_Column = typeof Fulfilment_Shipment_Line_Item_Update_Column[keyof typeof Fulfilment_Shipment_Line_Item_Update_Column];
export type Fulfilment_Shipment_Line_Item_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Fulfilment_Shipment_Line_Item_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Fulfilment_Shipment_Line_Item_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fulfilment_Shipment_Line_Item_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fulfilment_Shipment_Line_Item_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Fulfilment_Shipment_Line_Item_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Fulfilment_Shipment_Line_Item_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "fulfilment_shipment_line_item" */
export type Fulfilment_Shipment_Line_Item_Variance_Order_By = {
  id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
};

/** aggregate max on columns */
export type Fulfilment_Shipment_Max_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  label_booked_at?: Maybe<Scalars['timestamptz']>;
  label_last_downloaded_at?: Maybe<Scalars['timestamptz']>;
  location_id?: Maybe<Scalars['uuid']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  packing_slip_document_path?: Maybe<Scalars['String']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  scheduled_pickup_date?: Maybe<Scalars['date']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  signature_upload_path?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Max_Order_By = {
  address_id?: Maybe<Order_By>;
  atl_authority_to_leave?: Maybe<Order_By>;
  atl_unattended_safety?: Maybe<Order_By>;
  base_cost?: Maybe<Order_By>;
  carrier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  delivered_at?: Maybe<Order_By>;
  estimated_delivery_at?: Maybe<Order_By>;
  fulfilment_service?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  label_booked_at?: Maybe<Order_By>;
  label_last_downloaded_at?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  manifest_id?: Maybe<Order_By>;
  manifested_at?: Maybe<Order_By>;
  packing_slip_document_path?: Maybe<Order_By>;
  rate_request_id?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  scheduled_pickup_date?: Maybe<Order_By>;
  selected_rate_id?: Maybe<Order_By>;
  service_type?: Maybe<Order_By>;
  shipped_at?: Maybe<Order_By>;
  shipping_margin_id?: Maybe<Order_By>;
  signature_upload_path?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
  tracking_number?: Maybe<Order_By>;
  tracking_url?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Fulfilment_Shipment_Min_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  label_booked_at?: Maybe<Scalars['timestamptz']>;
  label_last_downloaded_at?: Maybe<Scalars['timestamptz']>;
  location_id?: Maybe<Scalars['uuid']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  packing_slip_document_path?: Maybe<Scalars['String']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  scheduled_pickup_date?: Maybe<Scalars['date']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  signature_upload_path?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Min_Order_By = {
  address_id?: Maybe<Order_By>;
  atl_authority_to_leave?: Maybe<Order_By>;
  atl_unattended_safety?: Maybe<Order_By>;
  base_cost?: Maybe<Order_By>;
  carrier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  delivered_at?: Maybe<Order_By>;
  estimated_delivery_at?: Maybe<Order_By>;
  fulfilment_service?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  label_booked_at?: Maybe<Order_By>;
  label_last_downloaded_at?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  manifest_id?: Maybe<Order_By>;
  manifested_at?: Maybe<Order_By>;
  packing_slip_document_path?: Maybe<Order_By>;
  rate_request_id?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  scheduled_pickup_date?: Maybe<Order_By>;
  selected_rate_id?: Maybe<Order_By>;
  service_type?: Maybe<Order_By>;
  shipped_at?: Maybe<Order_By>;
  shipping_margin_id?: Maybe<Order_By>;
  signature_upload_path?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
  tracking_number?: Maybe<Order_By>;
  tracking_url?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "fulfilment_shipment" */
export type Fulfilment_Shipment_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Fulfilment_Shipment>;
};

/** input type for inserting object relation for remote table "fulfilment_shipment" */
export type Fulfilment_Shipment_Obj_Rel_Insert_Input = {
  data: Fulfilment_Shipment_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Fulfilment_Shipment_On_Conflict>;
};

/** on_conflict condition type for table "fulfilment_shipment" */
export type Fulfilment_Shipment_On_Conflict = {
  constraint: Fulfilment_Shipment_Constraint;
  update_columns?: Array<Fulfilment_Shipment_Update_Column>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};

/** Ordering options when selecting data from "fulfilment_shipment". */
export type Fulfilment_Shipment_Order_By = {
  address?: Maybe<Address_Order_By>;
  address_id?: Maybe<Order_By>;
  atl_age_verification_required?: Maybe<Order_By>;
  atl_authority_to_leave?: Maybe<Order_By>;
  atl_signature_required?: Maybe<Order_By>;
  atl_unattended_safety?: Maybe<Order_By>;
  base_cost?: Maybe<Order_By>;
  carrier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  delivered_at?: Maybe<Order_By>;
  error?: Maybe<Order_By>;
  estimated_delivery_at?: Maybe<Order_By>;
  fulfilment_service?: Maybe<Order_By>;
  fulfilment_shipment_line_items_aggregate?: Maybe<Fulfilment_Shipment_Line_Item_Aggregate_Order_By>;
  fulfilment_shipment_parcels_aggregate?: Maybe<Fulfilment_Shipment_Parcel_Aggregate_Order_By>;
  gross_weight_gram?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  integrations?: Maybe<Order_By>;
  label_booked_at?: Maybe<Order_By>;
  label_last_downloaded_at?: Maybe<Order_By>;
  label_paths?: Maybe<Order_By>;
  location?: Maybe<Location_Order_By>;
  location_id?: Maybe<Order_By>;
  manifest?: Maybe<Manifest_Order_By>;
  manifest_id?: Maybe<Order_By>;
  manifested_at?: Maybe<Order_By>;
  packing_slip_document_path?: Maybe<Order_By>;
  photo_upload_paths?: Maybe<Order_By>;
  rate_request?: Maybe<Rate_Request_Order_By>;
  rate_request_id?: Maybe<Order_By>;
  sales_order?: Maybe<Sales_Order_Order_By>;
  sales_order_id?: Maybe<Order_By>;
  scheduled_pickup_date?: Maybe<Order_By>;
  selected_rate_id?: Maybe<Order_By>;
  selected_shipping_rate?: Maybe<Shipping_Rate_Order_By>;
  service_type?: Maybe<Order_By>;
  shipment_source?: Maybe<Shipment_Source_Order_By>;
  shipment_status?: Maybe<Shipment_Status_Order_By>;
  shipped_at?: Maybe<Order_By>;
  shipping_margin?: Maybe<Shipping_Margin_Order_By>;
  shipping_margin_id?: Maybe<Order_By>;
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Order_By>;
  signature_upload_path?: Maybe<Order_By>;
  source?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
  tracking_number?: Maybe<Order_By>;
  tracking_url?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** columns and relationships of "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel = {
  created_at: Scalars['timestamptz'];
  empty_weight_gram?: Maybe<Scalars['Int']>;
  /** An object relationship */
  fulfilment_shipment: Fulfilment_Shipment;
  fulfilment_shipment_id: Scalars['uuid'];
  height_mm: Scalars['Int'];
  id: Scalars['uuid'];
  length_mm: Scalars['Int'];
  max_weight_gram?: Maybe<Scalars['Int']>;
  min_weight_gram?: Maybe<Scalars['Int']>;
  /** An object relationship */
  parcel_type?: Maybe<Parcel_Type>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  type: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  weight_gram: Scalars['Int'];
  width_mm: Scalars['Int'];
};

/** aggregated selection of "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Aggregate = {
  aggregate?: Maybe<Fulfilment_Shipment_Parcel_Aggregate_Fields>;
  nodes: Array<Fulfilment_Shipment_Parcel>;
};

export type Fulfilment_Shipment_Parcel_Aggregate_Bool_Exp = {
  count?: Maybe<Fulfilment_Shipment_Parcel_Aggregate_Bool_Exp_Count>;
};

export type Fulfilment_Shipment_Parcel_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Aggregate_Fields = {
  avg?: Maybe<Fulfilment_Shipment_Parcel_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Fulfilment_Shipment_Parcel_Max_Fields>;
  min?: Maybe<Fulfilment_Shipment_Parcel_Min_Fields>;
  stddev?: Maybe<Fulfilment_Shipment_Parcel_Stddev_Fields>;
  stddev_pop?: Maybe<Fulfilment_Shipment_Parcel_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Fulfilment_Shipment_Parcel_Stddev_Samp_Fields>;
  sum?: Maybe<Fulfilment_Shipment_Parcel_Sum_Fields>;
  var_pop?: Maybe<Fulfilment_Shipment_Parcel_Var_Pop_Fields>;
  var_samp?: Maybe<Fulfilment_Shipment_Parcel_Var_Samp_Fields>;
  variance?: Maybe<Fulfilment_Shipment_Parcel_Variance_Fields>;
};


/** aggregate fields of "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Aggregate_Order_By = {
  avg?: Maybe<Fulfilment_Shipment_Parcel_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Fulfilment_Shipment_Parcel_Max_Order_By>;
  min?: Maybe<Fulfilment_Shipment_Parcel_Min_Order_By>;
  stddev?: Maybe<Fulfilment_Shipment_Parcel_Stddev_Order_By>;
  stddev_pop?: Maybe<Fulfilment_Shipment_Parcel_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Fulfilment_Shipment_Parcel_Stddev_Samp_Order_By>;
  sum?: Maybe<Fulfilment_Shipment_Parcel_Sum_Order_By>;
  var_pop?: Maybe<Fulfilment_Shipment_Parcel_Var_Pop_Order_By>;
  var_samp?: Maybe<Fulfilment_Shipment_Parcel_Var_Samp_Order_By>;
  variance?: Maybe<Fulfilment_Shipment_Parcel_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Arr_Rel_Insert_Input = {
  data: Array<Fulfilment_Shipment_Parcel_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Fulfilment_Shipment_Parcel_On_Conflict>;
};

/** aggregate avg on columns */
export type Fulfilment_Shipment_Parcel_Avg_Fields = {
  empty_weight_gram?: Maybe<Scalars['Float']>;
  height_mm?: Maybe<Scalars['Float']>;
  length_mm?: Maybe<Scalars['Float']>;
  max_weight_gram?: Maybe<Scalars['Float']>;
  min_weight_gram?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
  width_mm?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Avg_Order_By = {
  empty_weight_gram?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "fulfilment_shipment_parcel". All fields are combined with a logical 'AND'. */
export type Fulfilment_Shipment_Parcel_Bool_Exp = {
  _and?: Maybe<Array<Fulfilment_Shipment_Parcel_Bool_Exp>>;
  _not?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
  _or?: Maybe<Array<Fulfilment_Shipment_Parcel_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  empty_weight_gram?: Maybe<Int_Comparison_Exp>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipment_id?: Maybe<Uuid_Comparison_Exp>;
  height_mm?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  length_mm?: Maybe<Int_Comparison_Exp>;
  max_weight_gram?: Maybe<Int_Comparison_Exp>;
  min_weight_gram?: Maybe<Int_Comparison_Exp>;
  parcel_type?: Maybe<Parcel_Type_Bool_Exp>;
  parcel_type_id?: Maybe<Uuid_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  weight_gram?: Maybe<Int_Comparison_Exp>;
  width_mm?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "fulfilment_shipment_parcel" */
export const Fulfilment_Shipment_Parcel_Constraint = {
  /** unique or primary key constraint on columns "id" */
  FulfilmentShipmentParcelPkey: 'fulfilment_shipment_parcel_pkey'
} as const;

export type Fulfilment_Shipment_Parcel_Constraint = typeof Fulfilment_Shipment_Parcel_Constraint[keyof typeof Fulfilment_Shipment_Parcel_Constraint];
/** input type for incrementing numeric columns in table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Inc_Input = {
  empty_weight_gram?: Maybe<Scalars['Int']>;
  height_mm?: Maybe<Scalars['Int']>;
  length_mm?: Maybe<Scalars['Int']>;
  max_weight_gram?: Maybe<Scalars['Int']>;
  min_weight_gram?: Maybe<Scalars['Int']>;
  weight_gram?: Maybe<Scalars['Int']>;
  width_mm?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  empty_weight_gram?: Maybe<Scalars['Int']>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment_Obj_Rel_Insert_Input>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  height_mm?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  length_mm?: Maybe<Scalars['Int']>;
  max_weight_gram?: Maybe<Scalars['Int']>;
  min_weight_gram?: Maybe<Scalars['Int']>;
  parcel_type?: Maybe<Parcel_Type_Obj_Rel_Insert_Input>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
  width_mm?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Fulfilment_Shipment_Parcel_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  empty_weight_gram?: Maybe<Scalars['Int']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  height_mm?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  length_mm?: Maybe<Scalars['Int']>;
  max_weight_gram?: Maybe<Scalars['Int']>;
  min_weight_gram?: Maybe<Scalars['Int']>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
  width_mm?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  empty_weight_gram?: Maybe<Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  parcel_type_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Fulfilment_Shipment_Parcel_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  empty_weight_gram?: Maybe<Scalars['Int']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  height_mm?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  length_mm?: Maybe<Scalars['Int']>;
  max_weight_gram?: Maybe<Scalars['Int']>;
  min_weight_gram?: Maybe<Scalars['Int']>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
  width_mm?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  empty_weight_gram?: Maybe<Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  parcel_type_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** response of any mutation on the table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Fulfilment_Shipment_Parcel>;
};

/** on_conflict condition type for table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_On_Conflict = {
  constraint: Fulfilment_Shipment_Parcel_Constraint;
  update_columns?: Array<Fulfilment_Shipment_Parcel_Update_Column>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};

/** Ordering options when selecting data from "fulfilment_shipment_parcel". */
export type Fulfilment_Shipment_Parcel_Order_By = {
  created_at?: Maybe<Order_By>;
  empty_weight_gram?: Maybe<Order_By>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment_Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  parcel_type?: Maybe<Parcel_Type_Order_By>;
  parcel_type_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** primary key columns input for table: fulfilment_shipment_parcel */
export type Fulfilment_Shipment_Parcel_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "fulfilment_shipment_parcel" */
export const Fulfilment_Shipment_Parcel_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  EmptyWeightGram: 'empty_weight_gram',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  HeightMm: 'height_mm',
  /** column name */
  Id: 'id',
  /** column name */
  LengthMm: 'length_mm',
  /** column name */
  MaxWeightGram: 'max_weight_gram',
  /** column name */
  MinWeightGram: 'min_weight_gram',
  /** column name */
  ParcelTypeId: 'parcel_type_id',
  /** column name */
  Type: 'type',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  WeightGram: 'weight_gram',
  /** column name */
  WidthMm: 'width_mm'
} as const;

export type Fulfilment_Shipment_Parcel_Select_Column = typeof Fulfilment_Shipment_Parcel_Select_Column[keyof typeof Fulfilment_Shipment_Parcel_Select_Column];
/** input type for updating data in table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  empty_weight_gram?: Maybe<Scalars['Int']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  height_mm?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  length_mm?: Maybe<Scalars['Int']>;
  max_weight_gram?: Maybe<Scalars['Int']>;
  min_weight_gram?: Maybe<Scalars['Int']>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
  width_mm?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Fulfilment_Shipment_Parcel_Stddev_Fields = {
  empty_weight_gram?: Maybe<Scalars['Float']>;
  height_mm?: Maybe<Scalars['Float']>;
  length_mm?: Maybe<Scalars['Float']>;
  max_weight_gram?: Maybe<Scalars['Float']>;
  min_weight_gram?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
  width_mm?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Stddev_Order_By = {
  empty_weight_gram?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Fulfilment_Shipment_Parcel_Stddev_Pop_Fields = {
  empty_weight_gram?: Maybe<Scalars['Float']>;
  height_mm?: Maybe<Scalars['Float']>;
  length_mm?: Maybe<Scalars['Float']>;
  max_weight_gram?: Maybe<Scalars['Float']>;
  min_weight_gram?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
  width_mm?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Stddev_Pop_Order_By = {
  empty_weight_gram?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Fulfilment_Shipment_Parcel_Stddev_Samp_Fields = {
  empty_weight_gram?: Maybe<Scalars['Float']>;
  height_mm?: Maybe<Scalars['Float']>;
  length_mm?: Maybe<Scalars['Float']>;
  max_weight_gram?: Maybe<Scalars['Float']>;
  min_weight_gram?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
  width_mm?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Stddev_Samp_Order_By = {
  empty_weight_gram?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** Streaming cursor of the table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fulfilment_Shipment_Parcel_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fulfilment_Shipment_Parcel_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  empty_weight_gram?: Maybe<Scalars['Int']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  height_mm?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  length_mm?: Maybe<Scalars['Int']>;
  max_weight_gram?: Maybe<Scalars['Int']>;
  min_weight_gram?: Maybe<Scalars['Int']>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
  width_mm?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Fulfilment_Shipment_Parcel_Sum_Fields = {
  empty_weight_gram?: Maybe<Scalars['Int']>;
  height_mm?: Maybe<Scalars['Int']>;
  length_mm?: Maybe<Scalars['Int']>;
  max_weight_gram?: Maybe<Scalars['Int']>;
  min_weight_gram?: Maybe<Scalars['Int']>;
  weight_gram?: Maybe<Scalars['Int']>;
  width_mm?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Sum_Order_By = {
  empty_weight_gram?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** update columns of table "fulfilment_shipment_parcel" */
export const Fulfilment_Shipment_Parcel_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  EmptyWeightGram: 'empty_weight_gram',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  HeightMm: 'height_mm',
  /** column name */
  Id: 'id',
  /** column name */
  LengthMm: 'length_mm',
  /** column name */
  MaxWeightGram: 'max_weight_gram',
  /** column name */
  MinWeightGram: 'min_weight_gram',
  /** column name */
  ParcelTypeId: 'parcel_type_id',
  /** column name */
  Type: 'type',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  WeightGram: 'weight_gram',
  /** column name */
  WidthMm: 'width_mm'
} as const;

export type Fulfilment_Shipment_Parcel_Update_Column = typeof Fulfilment_Shipment_Parcel_Update_Column[keyof typeof Fulfilment_Shipment_Parcel_Update_Column];
export type Fulfilment_Shipment_Parcel_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Fulfilment_Shipment_Parcel_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Fulfilment_Shipment_Parcel_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fulfilment_Shipment_Parcel_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fulfilment_Shipment_Parcel_Var_Pop_Fields = {
  empty_weight_gram?: Maybe<Scalars['Float']>;
  height_mm?: Maybe<Scalars['Float']>;
  length_mm?: Maybe<Scalars['Float']>;
  max_weight_gram?: Maybe<Scalars['Float']>;
  min_weight_gram?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
  width_mm?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Var_Pop_Order_By = {
  empty_weight_gram?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Fulfilment_Shipment_Parcel_Var_Samp_Fields = {
  empty_weight_gram?: Maybe<Scalars['Float']>;
  height_mm?: Maybe<Scalars['Float']>;
  length_mm?: Maybe<Scalars['Float']>;
  max_weight_gram?: Maybe<Scalars['Float']>;
  min_weight_gram?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
  width_mm?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Var_Samp_Order_By = {
  empty_weight_gram?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Fulfilment_Shipment_Parcel_Variance_Fields = {
  empty_weight_gram?: Maybe<Scalars['Float']>;
  height_mm?: Maybe<Scalars['Float']>;
  length_mm?: Maybe<Scalars['Float']>;
  max_weight_gram?: Maybe<Scalars['Float']>;
  min_weight_gram?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
  width_mm?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "fulfilment_shipment_parcel" */
export type Fulfilment_Shipment_Parcel_Variance_Order_By = {
  empty_weight_gram?: Maybe<Order_By>;
  height_mm?: Maybe<Order_By>;
  length_mm?: Maybe<Order_By>;
  max_weight_gram?: Maybe<Order_By>;
  min_weight_gram?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
  width_mm?: Maybe<Order_By>;
};

/** primary key columns input for table: fulfilment_shipment */
export type Fulfilment_Shipment_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Fulfilment_Shipment_Prepend_Input = {
  error?: Maybe<Scalars['jsonb']>;
  integrations?: Maybe<Scalars['jsonb']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "fulfilment_shipment" */
export const Fulfilment_Shipment_Select_Column = {
  /** column name */
  AddressId: 'address_id',
  /** column name */
  AtlAgeVerificationRequired: 'atl_age_verification_required',
  /** column name */
  AtlAuthorityToLeave: 'atl_authority_to_leave',
  /** column name */
  AtlSignatureRequired: 'atl_signature_required',
  /** column name */
  AtlUnattendedSafety: 'atl_unattended_safety',
  /** column name */
  BaseCost: 'base_cost',
  /** column name */
  Carrier: 'carrier',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DeliveredAt: 'delivered_at',
  /** column name */
  Error: 'error',
  /** column name */
  EstimatedDeliveryAt: 'estimated_delivery_at',
  /** column name */
  FulfilmentService: 'fulfilment_service',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  LabelBookedAt: 'label_booked_at',
  /** column name */
  LabelLastDownloadedAt: 'label_last_downloaded_at',
  /** column name */
  LabelPaths: 'label_paths',
  /** column name */
  LocationId: 'location_id',
  /** column name */
  ManifestId: 'manifest_id',
  /** column name */
  ManifestedAt: 'manifested_at',
  /** column name */
  PackingSlipDocumentPath: 'packing_slip_document_path',
  /** column name */
  PhotoUploadPaths: 'photo_upload_paths',
  /** column name */
  RateRequestId: 'rate_request_id',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  ScheduledPickupDate: 'scheduled_pickup_date',
  /** column name */
  SelectedRateId: 'selected_rate_id',
  /** column name */
  ServiceType: 'service_type',
  /** column name */
  ShippedAt: 'shipped_at',
  /** column name */
  ShippingMarginId: 'shipping_margin_id',
  /** column name */
  SignatureUploadPath: 'signature_upload_path',
  /** column name */
  Source: 'source',
  /** column name */
  Status: 'status',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  TotalCost: 'total_cost',
  /** column name */
  TotalMargin: 'total_margin',
  /** column name */
  TrackingNumber: 'tracking_number',
  /** column name */
  TrackingUrl: 'tracking_url',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Fulfilment_Shipment_Select_Column = typeof Fulfilment_Shipment_Select_Column[keyof typeof Fulfilment_Shipment_Select_Column];
/** select "fulfilment_shipment_aggregate_bool_exp_bool_and_arguments_columns" columns of table "fulfilment_shipment" */
export const Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  AtlAgeVerificationRequired: 'atl_age_verification_required',
  /** column name */
  AtlSignatureRequired: 'atl_signature_required'
} as const;

export type Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "fulfilment_shipment_aggregate_bool_exp_bool_or_arguments_columns" columns of table "fulfilment_shipment" */
export const Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  AtlAgeVerificationRequired: 'atl_age_verification_required',
  /** column name */
  AtlSignatureRequired: 'atl_signature_required'
} as const;

export type Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Fulfilment_Shipment_Select_Column_Fulfilment_Shipment_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "fulfilment_shipment" */
export type Fulfilment_Shipment_Set_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_age_verification_required?: Maybe<Scalars['Boolean']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_signature_required?: Maybe<Scalars['Boolean']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  error?: Maybe<Scalars['jsonb']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  label_booked_at?: Maybe<Scalars['timestamptz']>;
  label_last_downloaded_at?: Maybe<Scalars['timestamptz']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  location_id?: Maybe<Scalars['uuid']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  packing_slip_document_path?: Maybe<Scalars['String']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  scheduled_pickup_date?: Maybe<Scalars['date']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  signature_upload_path?: Maybe<Scalars['String']>;
  source?: Maybe<Shipment_Source_Enum>;
  status?: Maybe<Shipment_Status_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Fulfilment_Shipment_Stddev_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Stddev_Order_By = {
  base_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Fulfilment_Shipment_Stddev_Pop_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Stddev_Pop_Order_By = {
  base_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Fulfilment_Shipment_Stddev_Samp_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Stddev_Samp_Order_By = {
  base_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
};

/** Streaming cursor of the table "fulfilment_shipment" */
export type Fulfilment_Shipment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fulfilment_Shipment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fulfilment_Shipment_Stream_Cursor_Value_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  atl_age_verification_required?: Maybe<Scalars['Boolean']>;
  atl_authority_to_leave?: Maybe<Scalars['String']>;
  atl_signature_required?: Maybe<Scalars['Boolean']>;
  atl_unattended_safety?: Maybe<Scalars['String']>;
  base_cost?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  delivered_at?: Maybe<Scalars['timestamptz']>;
  error?: Maybe<Scalars['jsonb']>;
  estimated_delivery_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  label_booked_at?: Maybe<Scalars['timestamptz']>;
  label_last_downloaded_at?: Maybe<Scalars['timestamptz']>;
  label_paths?: Maybe<Scalars['jsonb']>;
  location_id?: Maybe<Scalars['uuid']>;
  manifest_id?: Maybe<Scalars['uuid']>;
  manifested_at?: Maybe<Scalars['date']>;
  packing_slip_document_path?: Maybe<Scalars['String']>;
  photo_upload_paths?: Maybe<Scalars['jsonb']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  scheduled_pickup_date?: Maybe<Scalars['date']>;
  selected_rate_id?: Maybe<Scalars['uuid']>;
  service_type?: Maybe<Scalars['String']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  shipping_margin_id?: Maybe<Scalars['uuid']>;
  signature_upload_path?: Maybe<Scalars['String']>;
  source?: Maybe<Shipment_Source_Enum>;
  status?: Maybe<Shipment_Status_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Fulfilment_Shipment_Sum_Fields = {
  base_cost?: Maybe<Scalars['Int']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_margin?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Sum_Order_By = {
  base_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
};

/** update columns of table "fulfilment_shipment" */
export const Fulfilment_Shipment_Update_Column = {
  /** column name */
  AddressId: 'address_id',
  /** column name */
  AtlAgeVerificationRequired: 'atl_age_verification_required',
  /** column name */
  AtlAuthorityToLeave: 'atl_authority_to_leave',
  /** column name */
  AtlSignatureRequired: 'atl_signature_required',
  /** column name */
  AtlUnattendedSafety: 'atl_unattended_safety',
  /** column name */
  BaseCost: 'base_cost',
  /** column name */
  Carrier: 'carrier',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DeliveredAt: 'delivered_at',
  /** column name */
  Error: 'error',
  /** column name */
  EstimatedDeliveryAt: 'estimated_delivery_at',
  /** column name */
  FulfilmentService: 'fulfilment_service',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  LabelBookedAt: 'label_booked_at',
  /** column name */
  LabelLastDownloadedAt: 'label_last_downloaded_at',
  /** column name */
  LabelPaths: 'label_paths',
  /** column name */
  LocationId: 'location_id',
  /** column name */
  ManifestId: 'manifest_id',
  /** column name */
  ManifestedAt: 'manifested_at',
  /** column name */
  PackingSlipDocumentPath: 'packing_slip_document_path',
  /** column name */
  PhotoUploadPaths: 'photo_upload_paths',
  /** column name */
  RateRequestId: 'rate_request_id',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  ScheduledPickupDate: 'scheduled_pickup_date',
  /** column name */
  SelectedRateId: 'selected_rate_id',
  /** column name */
  ServiceType: 'service_type',
  /** column name */
  ShippedAt: 'shipped_at',
  /** column name */
  ShippingMarginId: 'shipping_margin_id',
  /** column name */
  SignatureUploadPath: 'signature_upload_path',
  /** column name */
  Source: 'source',
  /** column name */
  Status: 'status',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  TotalCost: 'total_cost',
  /** column name */
  TotalMargin: 'total_margin',
  /** column name */
  TrackingNumber: 'tracking_number',
  /** column name */
  TrackingUrl: 'tracking_url',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Fulfilment_Shipment_Update_Column = typeof Fulfilment_Shipment_Update_Column[keyof typeof Fulfilment_Shipment_Update_Column];
export type Fulfilment_Shipment_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Fulfilment_Shipment_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Fulfilment_Shipment_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Fulfilment_Shipment_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Fulfilment_Shipment_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Fulfilment_Shipment_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Fulfilment_Shipment_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Fulfilment_Shipment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fulfilment_Shipment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fulfilment_Shipment_Var_Pop_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Var_Pop_Order_By = {
  base_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Fulfilment_Shipment_Var_Samp_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Var_Samp_Order_By = {
  base_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Fulfilment_Shipment_Variance_Fields = {
  base_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_margin?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "fulfilment_shipment" */
export type Fulfilment_Shipment_Variance_Order_By = {
  base_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_margin?: Maybe<Order_By>;
};

/** ecommerce platform integration */
export type Integration = {
  created_at: Scalars['timestamptz'];
  id: Scalars['bigint'];
  /** An array relationship */
  inventory_sync_jobs: Array<Inventory_Sync_Job>;
  /** An aggregate relationship */
  inventory_sync_jobs_aggregate: Inventory_Sync_Job_Aggregate;
  /** An array relationship */
  product_variants: Array<Product_Variant>;
  /** An aggregate relationship */
  product_variants_aggregate: Product_Variant_Aggregate;
  /** An array relationship */
  products: Array<Product>;
  /** An aggregate relationship */
  products_aggregate: Product_Aggregate;
  /** An object relationship */
  shopify_integration?: Maybe<Shopify_Integration>;
  shopify_integration_id?: Maybe<Scalars['uuid']>;
  source: Integration_Source_Enum;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};


/** ecommerce platform integration */
export type IntegrationInventory_Sync_JobsArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


/** ecommerce platform integration */
export type IntegrationInventory_Sync_Jobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


/** ecommerce platform integration */
export type IntegrationProduct_VariantsArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


/** ecommerce platform integration */
export type IntegrationProduct_Variants_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


/** ecommerce platform integration */
export type IntegrationProductsArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};


/** ecommerce platform integration */
export type IntegrationProducts_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};

/** aggregated selection of "integration" */
export type Integration_Aggregate = {
  aggregate?: Maybe<Integration_Aggregate_Fields>;
  nodes: Array<Integration>;
};

/** aggregate fields of "integration" */
export type Integration_Aggregate_Fields = {
  avg?: Maybe<Integration_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Integration_Max_Fields>;
  min?: Maybe<Integration_Min_Fields>;
  stddev?: Maybe<Integration_Stddev_Fields>;
  stddev_pop?: Maybe<Integration_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Integration_Stddev_Samp_Fields>;
  sum?: Maybe<Integration_Sum_Fields>;
  var_pop?: Maybe<Integration_Var_Pop_Fields>;
  var_samp?: Maybe<Integration_Var_Samp_Fields>;
  variance?: Maybe<Integration_Variance_Fields>;
};


/** aggregate fields of "integration" */
export type Integration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Integration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Integration_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "integration". All fields are combined with a logical 'AND'. */
export type Integration_Bool_Exp = {
  _and?: Maybe<Array<Integration_Bool_Exp>>;
  _not?: Maybe<Integration_Bool_Exp>;
  _or?: Maybe<Array<Integration_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  inventory_sync_jobs?: Maybe<Inventory_Sync_Job_Bool_Exp>;
  inventory_sync_jobs_aggregate?: Maybe<Inventory_Sync_Job_Aggregate_Bool_Exp>;
  product_variants?: Maybe<Product_Variant_Bool_Exp>;
  product_variants_aggregate?: Maybe<Product_Variant_Aggregate_Bool_Exp>;
  products?: Maybe<Product_Bool_Exp>;
  products_aggregate?: Maybe<Product_Aggregate_Bool_Exp>;
  shopify_integration?: Maybe<Shopify_Integration_Bool_Exp>;
  shopify_integration_id?: Maybe<Uuid_Comparison_Exp>;
  source?: Maybe<Integration_Source_Enum_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "integration" */
export const Integration_Constraint = {
  /** unique or primary key constraint on columns "id" */
  IntegrationPk: 'integration_pk',
  /** unique or primary key constraint on columns "store_id", "shopify_integration_id" */
  IntegrationStoreIdShopifyIntegrationIdNotNull: 'integration_store_id_shopify_integration_id_not_null'
} as const;

export type Integration_Constraint = typeof Integration_Constraint[keyof typeof Integration_Constraint];
/** input type for incrementing numeric columns in table "integration" */
export type Integration_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "integration" */
export type Integration_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  inventory_sync_jobs?: Maybe<Inventory_Sync_Job_Arr_Rel_Insert_Input>;
  product_variants?: Maybe<Product_Variant_Arr_Rel_Insert_Input>;
  products?: Maybe<Product_Arr_Rel_Insert_Input>;
  shopify_integration?: Maybe<Shopify_Integration_Obj_Rel_Insert_Input>;
  shopify_integration_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Integration_Source_Enum>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Integration_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  shopify_integration_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Integration_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  shopify_integration_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "integration" */
export type Integration_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Integration>;
};

/** input type for inserting object relation for remote table "integration" */
export type Integration_Obj_Rel_Insert_Input = {
  data: Integration_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Integration_On_Conflict>;
};

/** on_conflict condition type for table "integration" */
export type Integration_On_Conflict = {
  constraint: Integration_Constraint;
  update_columns?: Array<Integration_Update_Column>;
  where?: Maybe<Integration_Bool_Exp>;
};

/** Ordering options when selecting data from "integration". */
export type Integration_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  inventory_sync_jobs_aggregate?: Maybe<Inventory_Sync_Job_Aggregate_Order_By>;
  product_variants_aggregate?: Maybe<Product_Variant_Aggregate_Order_By>;
  products_aggregate?: Maybe<Product_Aggregate_Order_By>;
  shopify_integration?: Maybe<Shopify_Integration_Order_By>;
  shopify_integration_id?: Maybe<Order_By>;
  source?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: integration */
export type Integration_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "integration" */
export const Integration_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  ShopifyIntegrationId: 'shopify_integration_id',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Integration_Select_Column = typeof Integration_Select_Column[keyof typeof Integration_Select_Column];
/** input type for updating data in table "integration" */
export type Integration_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  shopify_integration_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Integration_Source_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "integration_source" */
export type Integration_Source = {
  /** An array relationship */
  product_variants: Array<Product_Variant>;
  /** An aggregate relationship */
  product_variants_aggregate: Product_Variant_Aggregate;
  /** An array relationship */
  products: Array<Product>;
  /** An aggregate relationship */
  products_aggregate: Product_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "integration_source" */
export type Integration_SourceProduct_VariantsArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


/** columns and relationships of "integration_source" */
export type Integration_SourceProduct_Variants_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


/** columns and relationships of "integration_source" */
export type Integration_SourceProductsArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};


/** columns and relationships of "integration_source" */
export type Integration_SourceProducts_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};

/** aggregated selection of "integration_source" */
export type Integration_Source_Aggregate = {
  aggregate?: Maybe<Integration_Source_Aggregate_Fields>;
  nodes: Array<Integration_Source>;
};

/** aggregate fields of "integration_source" */
export type Integration_Source_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Integration_Source_Max_Fields>;
  min?: Maybe<Integration_Source_Min_Fields>;
};


/** aggregate fields of "integration_source" */
export type Integration_Source_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Integration_Source_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "integration_source". All fields are combined with a logical 'AND'. */
export type Integration_Source_Bool_Exp = {
  _and?: Maybe<Array<Integration_Source_Bool_Exp>>;
  _not?: Maybe<Integration_Source_Bool_Exp>;
  _or?: Maybe<Array<Integration_Source_Bool_Exp>>;
  product_variants?: Maybe<Product_Variant_Bool_Exp>;
  product_variants_aggregate?: Maybe<Product_Variant_Aggregate_Bool_Exp>;
  products?: Maybe<Product_Bool_Exp>;
  products_aggregate?: Maybe<Product_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "integration_source" */
export const Integration_Source_Constraint = {
  /** unique or primary key constraint on columns "value" */
  IntegrationSourcePkey: 'integration_source_pkey'
} as const;

export type Integration_Source_Constraint = typeof Integration_Source_Constraint[keyof typeof Integration_Source_Constraint];
export const Integration_Source_Enum = {
  Shopify: 'SHOPIFY'
} as const;

export type Integration_Source_Enum = typeof Integration_Source_Enum[keyof typeof Integration_Source_Enum];
/** Boolean expression to compare columns of type "integration_source_enum". All fields are combined with logical 'AND'. */
export type Integration_Source_Enum_Comparison_Exp = {
  _eq?: Maybe<Integration_Source_Enum>;
  _in?: Maybe<Array<Integration_Source_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Integration_Source_Enum>;
  _nin?: Maybe<Array<Integration_Source_Enum>>;
};

/** input type for inserting data into table "integration_source" */
export type Integration_Source_Insert_Input = {
  product_variants?: Maybe<Product_Variant_Arr_Rel_Insert_Input>;
  products?: Maybe<Product_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Integration_Source_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Integration_Source_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "integration_source" */
export type Integration_Source_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Integration_Source>;
};

/** input type for inserting object relation for remote table "integration_source" */
export type Integration_Source_Obj_Rel_Insert_Input = {
  data: Integration_Source_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Integration_Source_On_Conflict>;
};

/** on_conflict condition type for table "integration_source" */
export type Integration_Source_On_Conflict = {
  constraint: Integration_Source_Constraint;
  update_columns?: Array<Integration_Source_Update_Column>;
  where?: Maybe<Integration_Source_Bool_Exp>;
};

/** Ordering options when selecting data from "integration_source". */
export type Integration_Source_Order_By = {
  product_variants_aggregate?: Maybe<Product_Variant_Aggregate_Order_By>;
  products_aggregate?: Maybe<Product_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: integration_source */
export type Integration_Source_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "integration_source" */
export const Integration_Source_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Integration_Source_Select_Column = typeof Integration_Source_Select_Column[keyof typeof Integration_Source_Select_Column];
/** input type for updating data in table "integration_source" */
export type Integration_Source_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "integration_source" */
export type Integration_Source_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Integration_Source_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Integration_Source_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "integration_source" */
export const Integration_Source_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Integration_Source_Update_Column = typeof Integration_Source_Update_Column[keyof typeof Integration_Source_Update_Column];
export type Integration_Source_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Integration_Source_Set_Input>;
  /** filter the rows which have to be updated */
  where: Integration_Source_Bool_Exp;
};

/** aggregate stddev on columns */
export type Integration_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Integration_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Integration_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "integration" */
export type Integration_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Integration_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Integration_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  shopify_integration_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Integration_Source_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Integration_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "integration" */
export const Integration_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  ShopifyIntegrationId: 'shopify_integration_id',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Integration_Update_Column = typeof Integration_Update_Column[keyof typeof Integration_Update_Column];
export type Integration_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Integration_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Integration_Set_Input>;
  /** filter the rows which have to be updated */
  where: Integration_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Integration_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Integration_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Integration_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "inventory_item" */
export type Inventory_Item = {
  created_at: Scalars['timestamptz'];
  id: Scalars['bigint'];
  /** An array relationship */
  inventory_item_quantities: Array<Inventory_Item_Quantity>;
  /** An aggregate relationship */
  inventory_item_quantities_aggregate: Inventory_Item_Quantity_Aggregate;
  /** An object relationship */
  retail_unit: Retail_Unit;
  retail_unit_id: Scalars['bigint'];
  /** An array relationship */
  stock_transfer_items: Array<Stock_Transfer_Item>;
  /** An aggregate relationship */
  stock_transfer_items_aggregate: Stock_Transfer_Item_Aggregate;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "inventory_item" */
export type Inventory_ItemInventory_Item_QuantitiesArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


/** columns and relationships of "inventory_item" */
export type Inventory_ItemInventory_Item_Quantities_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


/** columns and relationships of "inventory_item" */
export type Inventory_ItemStock_Transfer_ItemsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


/** columns and relationships of "inventory_item" */
export type Inventory_ItemStock_Transfer_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};

/** aggregated selection of "inventory_item" */
export type Inventory_Item_Aggregate = {
  aggregate?: Maybe<Inventory_Item_Aggregate_Fields>;
  nodes: Array<Inventory_Item>;
};

export type Inventory_Item_Aggregate_Bool_Exp = {
  count?: Maybe<Inventory_Item_Aggregate_Bool_Exp_Count>;
};

export type Inventory_Item_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Inventory_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Inventory_Item_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "inventory_item" */
export type Inventory_Item_Aggregate_Fields = {
  avg?: Maybe<Inventory_Item_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Inventory_Item_Max_Fields>;
  min?: Maybe<Inventory_Item_Min_Fields>;
  stddev?: Maybe<Inventory_Item_Stddev_Fields>;
  stddev_pop?: Maybe<Inventory_Item_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Inventory_Item_Stddev_Samp_Fields>;
  sum?: Maybe<Inventory_Item_Sum_Fields>;
  var_pop?: Maybe<Inventory_Item_Var_Pop_Fields>;
  var_samp?: Maybe<Inventory_Item_Var_Samp_Fields>;
  variance?: Maybe<Inventory_Item_Variance_Fields>;
};


/** aggregate fields of "inventory_item" */
export type Inventory_Item_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Inventory_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "inventory_item" */
export type Inventory_Item_Aggregate_Order_By = {
  avg?: Maybe<Inventory_Item_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Inventory_Item_Max_Order_By>;
  min?: Maybe<Inventory_Item_Min_Order_By>;
  stddev?: Maybe<Inventory_Item_Stddev_Order_By>;
  stddev_pop?: Maybe<Inventory_Item_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Inventory_Item_Stddev_Samp_Order_By>;
  sum?: Maybe<Inventory_Item_Sum_Order_By>;
  var_pop?: Maybe<Inventory_Item_Var_Pop_Order_By>;
  var_samp?: Maybe<Inventory_Item_Var_Samp_Order_By>;
  variance?: Maybe<Inventory_Item_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "inventory_item" */
export type Inventory_Item_Arr_Rel_Insert_Input = {
  data: Array<Inventory_Item_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Inventory_Item_On_Conflict>;
};

/** aggregate avg on columns */
export type Inventory_Item_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  retail_unit_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "inventory_item" */
export type Inventory_Item_Avg_Order_By = {
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "inventory_item". All fields are combined with a logical 'AND'. */
export type Inventory_Item_Bool_Exp = {
  _and?: Maybe<Array<Inventory_Item_Bool_Exp>>;
  _not?: Maybe<Inventory_Item_Bool_Exp>;
  _or?: Maybe<Array<Inventory_Item_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  inventory_item_quantities?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
  inventory_item_quantities_aggregate?: Maybe<Inventory_Item_Quantity_Aggregate_Bool_Exp>;
  retail_unit?: Maybe<Retail_Unit_Bool_Exp>;
  retail_unit_id?: Maybe<Bigint_Comparison_Exp>;
  stock_transfer_items?: Maybe<Stock_Transfer_Item_Bool_Exp>;
  stock_transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Bool_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "inventory_item" */
export const Inventory_Item_Constraint = {
  /** unique or primary key constraint on columns "id" */
  InventoryItemPk: 'inventory_item_pk'
} as const;

export type Inventory_Item_Constraint = typeof Inventory_Item_Constraint[keyof typeof Inventory_Item_Constraint];
/** input type for incrementing numeric columns in table "inventory_item" */
export type Inventory_Item_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  retail_unit_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "inventory_item" */
export type Inventory_Item_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  inventory_item_quantities?: Maybe<Inventory_Item_Quantity_Arr_Rel_Insert_Input>;
  retail_unit?: Maybe<Retail_Unit_Obj_Rel_Insert_Input>;
  retail_unit_id?: Maybe<Scalars['bigint']>;
  stock_transfer_items?: Maybe<Stock_Transfer_Item_Arr_Rel_Insert_Input>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Inventory_Item_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  retail_unit_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "inventory_item" */
export type Inventory_Item_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Inventory_Item_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  retail_unit_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "inventory_item" */
export type Inventory_Item_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "inventory_item" */
export type Inventory_Item_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Inventory_Item>;
};

/** input type for inserting object relation for remote table "inventory_item" */
export type Inventory_Item_Obj_Rel_Insert_Input = {
  data: Inventory_Item_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Inventory_Item_On_Conflict>;
};

/** on_conflict condition type for table "inventory_item" */
export type Inventory_Item_On_Conflict = {
  constraint: Inventory_Item_Constraint;
  update_columns?: Array<Inventory_Item_Update_Column>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};

/** Ordering options when selecting data from "inventory_item". */
export type Inventory_Item_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  inventory_item_quantities_aggregate?: Maybe<Inventory_Item_Quantity_Aggregate_Order_By>;
  retail_unit?: Maybe<Retail_Unit_Order_By>;
  retail_unit_id?: Maybe<Order_By>;
  stock_transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: inventory_item */
export type Inventory_Item_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** columns and relationships of "inventory_item_quantity" */
export type Inventory_Item_Quantity = {
  allocated?: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  id: Scalars['bigint'];
  incoming?: Maybe<Scalars['Int']>;
  /** An object relationship */
  inventory_item: Inventory_Item;
  inventory_item_id: Scalars['bigint'];
  /** An object relationship */
  location: Location;
  location_id: Scalars['uuid'];
  on_hand?: Maybe<Scalars['Int']>;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "inventory_item_quantity" */
export type Inventory_Item_Quantity_Aggregate = {
  aggregate?: Maybe<Inventory_Item_Quantity_Aggregate_Fields>;
  nodes: Array<Inventory_Item_Quantity>;
};

export type Inventory_Item_Quantity_Aggregate_Bool_Exp = {
  count?: Maybe<Inventory_Item_Quantity_Aggregate_Bool_Exp_Count>;
};

export type Inventory_Item_Quantity_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "inventory_item_quantity" */
export type Inventory_Item_Quantity_Aggregate_Fields = {
  avg?: Maybe<Inventory_Item_Quantity_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Inventory_Item_Quantity_Max_Fields>;
  min?: Maybe<Inventory_Item_Quantity_Min_Fields>;
  stddev?: Maybe<Inventory_Item_Quantity_Stddev_Fields>;
  stddev_pop?: Maybe<Inventory_Item_Quantity_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Inventory_Item_Quantity_Stddev_Samp_Fields>;
  sum?: Maybe<Inventory_Item_Quantity_Sum_Fields>;
  var_pop?: Maybe<Inventory_Item_Quantity_Var_Pop_Fields>;
  var_samp?: Maybe<Inventory_Item_Quantity_Var_Samp_Fields>;
  variance?: Maybe<Inventory_Item_Quantity_Variance_Fields>;
};


/** aggregate fields of "inventory_item_quantity" */
export type Inventory_Item_Quantity_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Aggregate_Order_By = {
  avg?: Maybe<Inventory_Item_Quantity_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Inventory_Item_Quantity_Max_Order_By>;
  min?: Maybe<Inventory_Item_Quantity_Min_Order_By>;
  stddev?: Maybe<Inventory_Item_Quantity_Stddev_Order_By>;
  stddev_pop?: Maybe<Inventory_Item_Quantity_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Inventory_Item_Quantity_Stddev_Samp_Order_By>;
  sum?: Maybe<Inventory_Item_Quantity_Sum_Order_By>;
  var_pop?: Maybe<Inventory_Item_Quantity_Var_Pop_Order_By>;
  var_samp?: Maybe<Inventory_Item_Quantity_Var_Samp_Order_By>;
  variance?: Maybe<Inventory_Item_Quantity_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Arr_Rel_Insert_Input = {
  data: Array<Inventory_Item_Quantity_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Inventory_Item_Quantity_On_Conflict>;
};

/** aggregate avg on columns */
export type Inventory_Item_Quantity_Avg_Fields = {
  allocated?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  incoming?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  on_hand?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Avg_Order_By = {
  allocated?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "inventory_item_quantity". All fields are combined with a logical 'AND'. */
export type Inventory_Item_Quantity_Bool_Exp = {
  _and?: Maybe<Array<Inventory_Item_Quantity_Bool_Exp>>;
  _not?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
  _or?: Maybe<Array<Inventory_Item_Quantity_Bool_Exp>>;
  allocated?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  incoming?: Maybe<Int_Comparison_Exp>;
  inventory_item?: Maybe<Inventory_Item_Bool_Exp>;
  inventory_item_id?: Maybe<Bigint_Comparison_Exp>;
  location?: Maybe<Location_Bool_Exp>;
  location_id?: Maybe<Uuid_Comparison_Exp>;
  on_hand?: Maybe<Int_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "inventory_item_quantity" */
export const Inventory_Item_Quantity_Constraint = {
  /** unique or primary key constraint on columns "inventory_item_id", "location_id" */
  InventoryItemQuantityInventoryItemIdLocationId: 'inventory_item_quantity_inventory_item_id_location_id',
  /** unique or primary key constraint on columns "id" */
  InventoryItemQuantityPk: 'inventory_item_quantity_pk'
} as const;

export type Inventory_Item_Quantity_Constraint = typeof Inventory_Item_Quantity_Constraint[keyof typeof Inventory_Item_Quantity_Constraint];
/** input type for incrementing numeric columns in table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Inc_Input = {
  allocated?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  incoming?: Maybe<Scalars['Int']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  on_hand?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Insert_Input = {
  allocated?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  incoming?: Maybe<Scalars['Int']>;
  inventory_item?: Maybe<Inventory_Item_Obj_Rel_Insert_Input>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  location?: Maybe<Location_Obj_Rel_Insert_Input>;
  location_id?: Maybe<Scalars['uuid']>;
  on_hand?: Maybe<Scalars['Int']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Inventory_Item_Quantity_Max_Fields = {
  allocated?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  incoming?: Maybe<Scalars['Int']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  location_id?: Maybe<Scalars['uuid']>;
  on_hand?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Max_Order_By = {
  allocated?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Inventory_Item_Quantity_Min_Fields = {
  allocated?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  incoming?: Maybe<Scalars['Int']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  location_id?: Maybe<Scalars['uuid']>;
  on_hand?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Min_Order_By = {
  allocated?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Inventory_Item_Quantity>;
};

/** on_conflict condition type for table "inventory_item_quantity" */
export type Inventory_Item_Quantity_On_Conflict = {
  constraint: Inventory_Item_Quantity_Constraint;
  update_columns?: Array<Inventory_Item_Quantity_Update_Column>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};

/** Ordering options when selecting data from "inventory_item_quantity". */
export type Inventory_Item_Quantity_Order_By = {
  allocated?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item?: Maybe<Inventory_Item_Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  location?: Maybe<Location_Order_By>;
  location_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: inventory_item_quantity */
export type Inventory_Item_Quantity_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "inventory_item_quantity" */
export const Inventory_Item_Quantity_Select_Column = {
  /** column name */
  Allocated: 'allocated',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Incoming: 'incoming',
  /** column name */
  InventoryItemId: 'inventory_item_id',
  /** column name */
  LocationId: 'location_id',
  /** column name */
  OnHand: 'on_hand',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Inventory_Item_Quantity_Select_Column = typeof Inventory_Item_Quantity_Select_Column[keyof typeof Inventory_Item_Quantity_Select_Column];
/** input type for updating data in table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Set_Input = {
  allocated?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  incoming?: Maybe<Scalars['Int']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  location_id?: Maybe<Scalars['uuid']>;
  on_hand?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Inventory_Item_Quantity_Stddev_Fields = {
  allocated?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  incoming?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  on_hand?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Stddev_Order_By = {
  allocated?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Inventory_Item_Quantity_Stddev_Pop_Fields = {
  allocated?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  incoming?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  on_hand?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Stddev_Pop_Order_By = {
  allocated?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Inventory_Item_Quantity_Stddev_Samp_Fields = {
  allocated?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  incoming?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  on_hand?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Stddev_Samp_Order_By = {
  allocated?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
};

/** Streaming cursor of the table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inventory_Item_Quantity_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inventory_Item_Quantity_Stream_Cursor_Value_Input = {
  allocated?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  incoming?: Maybe<Scalars['Int']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  location_id?: Maybe<Scalars['uuid']>;
  on_hand?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Inventory_Item_Quantity_Sum_Fields = {
  allocated?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  incoming?: Maybe<Scalars['Int']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  on_hand?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Sum_Order_By = {
  allocated?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
};

/** update columns of table "inventory_item_quantity" */
export const Inventory_Item_Quantity_Update_Column = {
  /** column name */
  Allocated: 'allocated',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Incoming: 'incoming',
  /** column name */
  InventoryItemId: 'inventory_item_id',
  /** column name */
  LocationId: 'location_id',
  /** column name */
  OnHand: 'on_hand',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Inventory_Item_Quantity_Update_Column = typeof Inventory_Item_Quantity_Update_Column[keyof typeof Inventory_Item_Quantity_Update_Column];
export type Inventory_Item_Quantity_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Inventory_Item_Quantity_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Inventory_Item_Quantity_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inventory_Item_Quantity_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Inventory_Item_Quantity_Var_Pop_Fields = {
  allocated?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  incoming?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  on_hand?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Var_Pop_Order_By = {
  allocated?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Inventory_Item_Quantity_Var_Samp_Fields = {
  allocated?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  incoming?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  on_hand?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Var_Samp_Order_By = {
  allocated?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Inventory_Item_Quantity_Variance_Fields = {
  allocated?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  incoming?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  on_hand?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "inventory_item_quantity" */
export type Inventory_Item_Quantity_Variance_Order_By = {
  allocated?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  incoming?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  on_hand?: Maybe<Order_By>;
};

/** select columns of table "inventory_item" */
export const Inventory_Item_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  RetailUnitId: 'retail_unit_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Inventory_Item_Select_Column = typeof Inventory_Item_Select_Column[keyof typeof Inventory_Item_Select_Column];
/** input type for updating data in table "inventory_item" */
export type Inventory_Item_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  retail_unit_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Inventory_Item_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  retail_unit_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "inventory_item" */
export type Inventory_Item_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Inventory_Item_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  retail_unit_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "inventory_item" */
export type Inventory_Item_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Inventory_Item_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  retail_unit_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "inventory_item" */
export type Inventory_Item_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "inventory_item" */
export type Inventory_Item_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inventory_Item_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inventory_Item_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  retail_unit_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Inventory_Item_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  retail_unit_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "inventory_item" */
export type Inventory_Item_Sum_Order_By = {
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
};

/** update columns of table "inventory_item" */
export const Inventory_Item_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  RetailUnitId: 'retail_unit_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Inventory_Item_Update_Column = typeof Inventory_Item_Update_Column[keyof typeof Inventory_Item_Update_Column];
export type Inventory_Item_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Inventory_Item_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Inventory_Item_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inventory_Item_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Inventory_Item_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  retail_unit_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "inventory_item" */
export type Inventory_Item_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Inventory_Item_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  retail_unit_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "inventory_item" */
export type Inventory_Item_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Inventory_Item_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  retail_unit_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "inventory_item" */
export type Inventory_Item_Variance_Order_By = {
  id?: Maybe<Order_By>;
  retail_unit_id?: Maybe<Order_By>;
};

/** columns and relationships of "inventory_sync_job" */
export type Inventory_Sync_Job = {
  completed_at?: Maybe<Scalars['timestamptz']>;
  created_at: Scalars['timestamptz'];
  duplicated_barcode_products?: Maybe<Scalars['jsonb']>;
  duplicated_sku_products?: Maybe<Scalars['jsonb']>;
  error_message?: Maybe<Scalars['String']>;
  external_entity_id: Scalars['String'];
  id: Scalars['bigint'];
  /** An object relationship */
  integration: Integration;
  integration_id: Scalars['bigint'];
  /** An object relationship */
  inventory_sync_job_status: Inventory_Sync_Job_Status;
  missing_barcode_products?: Maybe<Scalars['jsonb']>;
  missing_sku_products?: Maybe<Scalars['jsonb']>;
  product_count: Scalars['Int'];
  status: Inventory_Sync_Job_Status_Enum;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
};


/** columns and relationships of "inventory_sync_job" */
export type Inventory_Sync_JobDuplicated_Barcode_ProductsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "inventory_sync_job" */
export type Inventory_Sync_JobDuplicated_Sku_ProductsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "inventory_sync_job" */
export type Inventory_Sync_JobMissing_Barcode_ProductsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "inventory_sync_job" */
export type Inventory_Sync_JobMissing_Sku_ProductsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "inventory_sync_job" */
export type Inventory_Sync_Job_Aggregate = {
  aggregate?: Maybe<Inventory_Sync_Job_Aggregate_Fields>;
  nodes: Array<Inventory_Sync_Job>;
};

export type Inventory_Sync_Job_Aggregate_Bool_Exp = {
  count?: Maybe<Inventory_Sync_Job_Aggregate_Bool_Exp_Count>;
};

export type Inventory_Sync_Job_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Inventory_Sync_Job_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "inventory_sync_job" */
export type Inventory_Sync_Job_Aggregate_Fields = {
  avg?: Maybe<Inventory_Sync_Job_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Inventory_Sync_Job_Max_Fields>;
  min?: Maybe<Inventory_Sync_Job_Min_Fields>;
  stddev?: Maybe<Inventory_Sync_Job_Stddev_Fields>;
  stddev_pop?: Maybe<Inventory_Sync_Job_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Inventory_Sync_Job_Stddev_Samp_Fields>;
  sum?: Maybe<Inventory_Sync_Job_Sum_Fields>;
  var_pop?: Maybe<Inventory_Sync_Job_Var_Pop_Fields>;
  var_samp?: Maybe<Inventory_Sync_Job_Var_Samp_Fields>;
  variance?: Maybe<Inventory_Sync_Job_Variance_Fields>;
};


/** aggregate fields of "inventory_sync_job" */
export type Inventory_Sync_Job_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "inventory_sync_job" */
export type Inventory_Sync_Job_Aggregate_Order_By = {
  avg?: Maybe<Inventory_Sync_Job_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Inventory_Sync_Job_Max_Order_By>;
  min?: Maybe<Inventory_Sync_Job_Min_Order_By>;
  stddev?: Maybe<Inventory_Sync_Job_Stddev_Order_By>;
  stddev_pop?: Maybe<Inventory_Sync_Job_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Inventory_Sync_Job_Stddev_Samp_Order_By>;
  sum?: Maybe<Inventory_Sync_Job_Sum_Order_By>;
  var_pop?: Maybe<Inventory_Sync_Job_Var_Pop_Order_By>;
  var_samp?: Maybe<Inventory_Sync_Job_Var_Samp_Order_By>;
  variance?: Maybe<Inventory_Sync_Job_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Inventory_Sync_Job_Append_Input = {
  duplicated_barcode_products?: Maybe<Scalars['jsonb']>;
  duplicated_sku_products?: Maybe<Scalars['jsonb']>;
  missing_barcode_products?: Maybe<Scalars['jsonb']>;
  missing_sku_products?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "inventory_sync_job" */
export type Inventory_Sync_Job_Arr_Rel_Insert_Input = {
  data: Array<Inventory_Sync_Job_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Inventory_Sync_Job_On_Conflict>;
};

/** aggregate avg on columns */
export type Inventory_Sync_Job_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_count?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Avg_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "inventory_sync_job". All fields are combined with a logical 'AND'. */
export type Inventory_Sync_Job_Bool_Exp = {
  _and?: Maybe<Array<Inventory_Sync_Job_Bool_Exp>>;
  _not?: Maybe<Inventory_Sync_Job_Bool_Exp>;
  _or?: Maybe<Array<Inventory_Sync_Job_Bool_Exp>>;
  completed_at?: Maybe<Timestamptz_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  duplicated_barcode_products?: Maybe<Jsonb_Comparison_Exp>;
  duplicated_sku_products?: Maybe<Jsonb_Comparison_Exp>;
  error_message?: Maybe<String_Comparison_Exp>;
  external_entity_id?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  integration?: Maybe<Integration_Bool_Exp>;
  integration_id?: Maybe<Bigint_Comparison_Exp>;
  inventory_sync_job_status?: Maybe<Inventory_Sync_Job_Status_Bool_Exp>;
  missing_barcode_products?: Maybe<Jsonb_Comparison_Exp>;
  missing_sku_products?: Maybe<Jsonb_Comparison_Exp>;
  product_count?: Maybe<Int_Comparison_Exp>;
  status?: Maybe<Inventory_Sync_Job_Status_Enum_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "inventory_sync_job" */
export const Inventory_Sync_Job_Constraint = {
  /** unique or primary key constraint on columns "id" */
  InventorySyncJobPk: 'inventory_sync_job_pk'
} as const;

export type Inventory_Sync_Job_Constraint = typeof Inventory_Sync_Job_Constraint[keyof typeof Inventory_Sync_Job_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Inventory_Sync_Job_Delete_At_Path_Input = {
  duplicated_barcode_products?: Maybe<Array<Scalars['String']>>;
  duplicated_sku_products?: Maybe<Array<Scalars['String']>>;
  missing_barcode_products?: Maybe<Array<Scalars['String']>>;
  missing_sku_products?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Inventory_Sync_Job_Delete_Elem_Input = {
  duplicated_barcode_products?: Maybe<Scalars['Int']>;
  duplicated_sku_products?: Maybe<Scalars['Int']>;
  missing_barcode_products?: Maybe<Scalars['Int']>;
  missing_sku_products?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Inventory_Sync_Job_Delete_Key_Input = {
  duplicated_barcode_products?: Maybe<Scalars['String']>;
  duplicated_sku_products?: Maybe<Scalars['String']>;
  missing_barcode_products?: Maybe<Scalars['String']>;
  missing_sku_products?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "inventory_sync_job" */
export type Inventory_Sync_Job_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  product_count?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "inventory_sync_job" */
export type Inventory_Sync_Job_Insert_Input = {
  completed_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  duplicated_barcode_products?: Maybe<Scalars['jsonb']>;
  duplicated_sku_products?: Maybe<Scalars['jsonb']>;
  error_message?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration?: Maybe<Integration_Obj_Rel_Insert_Input>;
  integration_id?: Maybe<Scalars['bigint']>;
  inventory_sync_job_status?: Maybe<Inventory_Sync_Job_Status_Obj_Rel_Insert_Input>;
  missing_barcode_products?: Maybe<Scalars['jsonb']>;
  missing_sku_products?: Maybe<Scalars['jsonb']>;
  product_count?: Maybe<Scalars['Int']>;
  status?: Maybe<Inventory_Sync_Job_Status_Enum>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Inventory_Sync_Job_Max_Fields = {
  completed_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  error_message?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  product_count?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Max_Order_By = {
  completed_at?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  error_message?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Inventory_Sync_Job_Min_Fields = {
  completed_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  error_message?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  product_count?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Min_Order_By = {
  completed_at?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  error_message?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "inventory_sync_job" */
export type Inventory_Sync_Job_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Inventory_Sync_Job>;
};

/** on_conflict condition type for table "inventory_sync_job" */
export type Inventory_Sync_Job_On_Conflict = {
  constraint: Inventory_Sync_Job_Constraint;
  update_columns?: Array<Inventory_Sync_Job_Update_Column>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};

/** Ordering options when selecting data from "inventory_sync_job". */
export type Inventory_Sync_Job_Order_By = {
  completed_at?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  duplicated_barcode_products?: Maybe<Order_By>;
  duplicated_sku_products?: Maybe<Order_By>;
  error_message?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  integration?: Maybe<Integration_Order_By>;
  integration_id?: Maybe<Order_By>;
  inventory_sync_job_status?: Maybe<Inventory_Sync_Job_Status_Order_By>;
  missing_barcode_products?: Maybe<Order_By>;
  missing_sku_products?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
};

/** primary key columns input for table: inventory_sync_job */
export type Inventory_Sync_Job_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Inventory_Sync_Job_Prepend_Input = {
  duplicated_barcode_products?: Maybe<Scalars['jsonb']>;
  duplicated_sku_products?: Maybe<Scalars['jsonb']>;
  missing_barcode_products?: Maybe<Scalars['jsonb']>;
  missing_sku_products?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "inventory_sync_job" */
export const Inventory_Sync_Job_Select_Column = {
  /** column name */
  CompletedAt: 'completed_at',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DuplicatedBarcodeProducts: 'duplicated_barcode_products',
  /** column name */
  DuplicatedSkuProducts: 'duplicated_sku_products',
  /** column name */
  ErrorMessage: 'error_message',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  IntegrationId: 'integration_id',
  /** column name */
  MissingBarcodeProducts: 'missing_barcode_products',
  /** column name */
  MissingSkuProducts: 'missing_sku_products',
  /** column name */
  ProductCount: 'product_count',
  /** column name */
  Status: 'status',
  /** column name */
  StoreId: 'store_id'
} as const;

export type Inventory_Sync_Job_Select_Column = typeof Inventory_Sync_Job_Select_Column[keyof typeof Inventory_Sync_Job_Select_Column];
/** input type for updating data in table "inventory_sync_job" */
export type Inventory_Sync_Job_Set_Input = {
  completed_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  duplicated_barcode_products?: Maybe<Scalars['jsonb']>;
  duplicated_sku_products?: Maybe<Scalars['jsonb']>;
  error_message?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  missing_barcode_products?: Maybe<Scalars['jsonb']>;
  missing_sku_products?: Maybe<Scalars['jsonb']>;
  product_count?: Maybe<Scalars['Int']>;
  status?: Maybe<Inventory_Sync_Job_Status_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status = {
  /** An array relationship */
  inventory_sync_jobs: Array<Inventory_Sync_Job>;
  /** An aggregate relationship */
  inventory_sync_jobs_aggregate: Inventory_Sync_Job_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "inventory_sync_job_status" */
export type Inventory_Sync_Job_StatusInventory_Sync_JobsArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


/** columns and relationships of "inventory_sync_job_status" */
export type Inventory_Sync_Job_StatusInventory_Sync_Jobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};

/** aggregated selection of "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status_Aggregate = {
  aggregate?: Maybe<Inventory_Sync_Job_Status_Aggregate_Fields>;
  nodes: Array<Inventory_Sync_Job_Status>;
};

/** aggregate fields of "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Inventory_Sync_Job_Status_Max_Fields>;
  min?: Maybe<Inventory_Sync_Job_Status_Min_Fields>;
};


/** aggregate fields of "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Inventory_Sync_Job_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "inventory_sync_job_status". All fields are combined with a logical 'AND'. */
export type Inventory_Sync_Job_Status_Bool_Exp = {
  _and?: Maybe<Array<Inventory_Sync_Job_Status_Bool_Exp>>;
  _not?: Maybe<Inventory_Sync_Job_Status_Bool_Exp>;
  _or?: Maybe<Array<Inventory_Sync_Job_Status_Bool_Exp>>;
  inventory_sync_jobs?: Maybe<Inventory_Sync_Job_Bool_Exp>;
  inventory_sync_jobs_aggregate?: Maybe<Inventory_Sync_Job_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "inventory_sync_job_status" */
export const Inventory_Sync_Job_Status_Constraint = {
  /** unique or primary key constraint on columns "value" */
  InventorySyncJobStatusPk: 'inventory_sync_job_status_pk'
} as const;

export type Inventory_Sync_Job_Status_Constraint = typeof Inventory_Sync_Job_Status_Constraint[keyof typeof Inventory_Sync_Job_Status_Constraint];
export const Inventory_Sync_Job_Status_Enum = {
  Completed: 'COMPLETED',
  CompletedWithErrors: 'COMPLETED_WITH_ERRORS',
  Error: 'ERROR',
  Syncing: 'SYNCING'
} as const;

export type Inventory_Sync_Job_Status_Enum = typeof Inventory_Sync_Job_Status_Enum[keyof typeof Inventory_Sync_Job_Status_Enum];
/** Boolean expression to compare columns of type "inventory_sync_job_status_enum". All fields are combined with logical 'AND'. */
export type Inventory_Sync_Job_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Inventory_Sync_Job_Status_Enum>;
  _in?: Maybe<Array<Inventory_Sync_Job_Status_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Inventory_Sync_Job_Status_Enum>;
  _nin?: Maybe<Array<Inventory_Sync_Job_Status_Enum>>;
};

/** input type for inserting data into table "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status_Insert_Input = {
  inventory_sync_jobs?: Maybe<Inventory_Sync_Job_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Inventory_Sync_Job_Status_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Inventory_Sync_Job_Status_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Inventory_Sync_Job_Status>;
};

/** input type for inserting object relation for remote table "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status_Obj_Rel_Insert_Input = {
  data: Inventory_Sync_Job_Status_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Inventory_Sync_Job_Status_On_Conflict>;
};

/** on_conflict condition type for table "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status_On_Conflict = {
  constraint: Inventory_Sync_Job_Status_Constraint;
  update_columns?: Array<Inventory_Sync_Job_Status_Update_Column>;
  where?: Maybe<Inventory_Sync_Job_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "inventory_sync_job_status". */
export type Inventory_Sync_Job_Status_Order_By = {
  inventory_sync_jobs_aggregate?: Maybe<Inventory_Sync_Job_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: inventory_sync_job_status */
export type Inventory_Sync_Job_Status_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "inventory_sync_job_status" */
export const Inventory_Sync_Job_Status_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Inventory_Sync_Job_Status_Select_Column = typeof Inventory_Sync_Job_Status_Select_Column[keyof typeof Inventory_Sync_Job_Status_Select_Column];
/** input type for updating data in table "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "inventory_sync_job_status" */
export type Inventory_Sync_Job_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inventory_Sync_Job_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inventory_Sync_Job_Status_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "inventory_sync_job_status" */
export const Inventory_Sync_Job_Status_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Inventory_Sync_Job_Status_Update_Column = typeof Inventory_Sync_Job_Status_Update_Column[keyof typeof Inventory_Sync_Job_Status_Update_Column];
export type Inventory_Sync_Job_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Inventory_Sync_Job_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inventory_Sync_Job_Status_Bool_Exp;
};

/** aggregate stddev on columns */
export type Inventory_Sync_Job_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_count?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Inventory_Sync_Job_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_count?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Inventory_Sync_Job_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_count?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
};

/** Streaming cursor of the table "inventory_sync_job" */
export type Inventory_Sync_Job_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inventory_Sync_Job_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inventory_Sync_Job_Stream_Cursor_Value_Input = {
  completed_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  duplicated_barcode_products?: Maybe<Scalars['jsonb']>;
  duplicated_sku_products?: Maybe<Scalars['jsonb']>;
  error_message?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  missing_barcode_products?: Maybe<Scalars['jsonb']>;
  missing_sku_products?: Maybe<Scalars['jsonb']>;
  product_count?: Maybe<Scalars['Int']>;
  status?: Maybe<Inventory_Sync_Job_Status_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Inventory_Sync_Job_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  product_count?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Sum_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
};

/** update columns of table "inventory_sync_job" */
export const Inventory_Sync_Job_Update_Column = {
  /** column name */
  CompletedAt: 'completed_at',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DuplicatedBarcodeProducts: 'duplicated_barcode_products',
  /** column name */
  DuplicatedSkuProducts: 'duplicated_sku_products',
  /** column name */
  ErrorMessage: 'error_message',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  IntegrationId: 'integration_id',
  /** column name */
  MissingBarcodeProducts: 'missing_barcode_products',
  /** column name */
  MissingSkuProducts: 'missing_sku_products',
  /** column name */
  ProductCount: 'product_count',
  /** column name */
  Status: 'status',
  /** column name */
  StoreId: 'store_id'
} as const;

export type Inventory_Sync_Job_Update_Column = typeof Inventory_Sync_Job_Update_Column[keyof typeof Inventory_Sync_Job_Update_Column];
export type Inventory_Sync_Job_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Inventory_Sync_Job_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Inventory_Sync_Job_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Inventory_Sync_Job_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Inventory_Sync_Job_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Inventory_Sync_Job_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Inventory_Sync_Job_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Inventory_Sync_Job_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inventory_Sync_Job_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Inventory_Sync_Job_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_count?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Inventory_Sync_Job_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_count?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Inventory_Sync_Job_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_count?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "inventory_sync_job" */
export type Inventory_Sync_Job_Variance_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_count?: Maybe<Order_By>;
};



export type Jsonb_Cast_Exp = {
  String?: Maybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast?: Maybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in?: Maybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains?: Maybe<Scalars['jsonb']>;
  _eq?: Maybe<Scalars['jsonb']>;
  _gt?: Maybe<Scalars['jsonb']>;
  _gte?: Maybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: Maybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: Maybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: Maybe<Array<Scalars['String']>>;
  _in?: Maybe<Array<Scalars['jsonb']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['jsonb']>;
  _lte?: Maybe<Scalars['jsonb']>;
  _neq?: Maybe<Scalars['jsonb']>;
  _nin?: Maybe<Array<Scalars['jsonb']>>;
};

/** columns and relationships of "location" */
export type Location = {
  /** An object relationship */
  address?: Maybe<Address>;
  address_id?: Maybe<Scalars['uuid']>;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  fulfilment_center?: Maybe<Fulfilment_Center>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id: Scalars['uuid'];
  integrations?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  inventory_item_quantities: Array<Inventory_Item_Quantity>;
  /** An aggregate relationship */
  inventory_item_quantities_aggregate: Inventory_Item_Quantity_Aggregate;
  is_default: Scalars['Boolean'];
  is_skutopia_fc: Scalars['Boolean'];
  is_virtual: Scalars['Boolean'];
  /** An array relationship */
  manifests: Array<Manifest>;
  /** An aggregate relationship */
  manifests_aggregate: Manifest_Aggregate;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  title: Scalars['String'];
  /** An array relationship */
  transfer_items: Array<Stock_Transfer_Item>;
  /** An aggregate relationship */
  transfer_items_aggregate: Stock_Transfer_Item_Aggregate;
  /** An array relationship */
  transfer_shipments: Array<Stock_Transfer_Shipment>;
  /** An aggregate relationship */
  transfer_shipments_aggregate: Stock_Transfer_Shipment_Aggregate;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "location" */
export type LocationIntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "location" */
export type LocationInventory_Item_QuantitiesArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


/** columns and relationships of "location" */
export type LocationInventory_Item_Quantities_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


/** columns and relationships of "location" */
export type LocationManifestsArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


/** columns and relationships of "location" */
export type LocationManifests_AggregateArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


/** columns and relationships of "location" */
export type LocationTransfer_ItemsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


/** columns and relationships of "location" */
export type LocationTransfer_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


/** columns and relationships of "location" */
export type LocationTransfer_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};


/** columns and relationships of "location" */
export type LocationTransfer_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};

/** aggregated selection of "location" */
export type Location_Aggregate = {
  aggregate?: Maybe<Location_Aggregate_Fields>;
  nodes: Array<Location>;
};

export type Location_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Location_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Location_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Location_Aggregate_Bool_Exp_Count>;
};

export type Location_Aggregate_Bool_Exp_Bool_And = {
  arguments: Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Location_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Location_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Location_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Location_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Location_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Location_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "location" */
export type Location_Aggregate_Fields = {
  avg?: Maybe<Location_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Location_Max_Fields>;
  min?: Maybe<Location_Min_Fields>;
  stddev?: Maybe<Location_Stddev_Fields>;
  stddev_pop?: Maybe<Location_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Location_Stddev_Samp_Fields>;
  sum?: Maybe<Location_Sum_Fields>;
  var_pop?: Maybe<Location_Var_Pop_Fields>;
  var_samp?: Maybe<Location_Var_Samp_Fields>;
  variance?: Maybe<Location_Variance_Fields>;
};


/** aggregate fields of "location" */
export type Location_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Location_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "location" */
export type Location_Aggregate_Order_By = {
  avg?: Maybe<Location_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Location_Max_Order_By>;
  min?: Maybe<Location_Min_Order_By>;
  stddev?: Maybe<Location_Stddev_Order_By>;
  stddev_pop?: Maybe<Location_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Location_Stddev_Samp_Order_By>;
  sum?: Maybe<Location_Sum_Order_By>;
  var_pop?: Maybe<Location_Var_Pop_Order_By>;
  var_samp?: Maybe<Location_Var_Samp_Order_By>;
  variance?: Maybe<Location_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Location_Append_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "location" */
export type Location_Arr_Rel_Insert_Input = {
  data: Array<Location_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Location_On_Conflict>;
};

/** aggregate avg on columns */
export type Location_Avg_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "location" */
export type Location_Avg_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "location". All fields are combined with a logical 'AND'. */
export type Location_Bool_Exp = {
  _and?: Maybe<Array<Location_Bool_Exp>>;
  _not?: Maybe<Location_Bool_Exp>;
  _or?: Maybe<Array<Location_Bool_Exp>>;
  address?: Maybe<Address_Bool_Exp>;
  address_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  fulfilment_center?: Maybe<Fulfilment_Center_Bool_Exp>;
  fulfilment_center_id?: Maybe<Bigint_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  integrations?: Maybe<Jsonb_Comparison_Exp>;
  inventory_item_quantities?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
  inventory_item_quantities_aggregate?: Maybe<Inventory_Item_Quantity_Aggregate_Bool_Exp>;
  is_default?: Maybe<Boolean_Comparison_Exp>;
  is_skutopia_fc?: Maybe<Boolean_Comparison_Exp>;
  is_virtual?: Maybe<Boolean_Comparison_Exp>;
  manifests?: Maybe<Manifest_Bool_Exp>;
  manifests_aggregate?: Maybe<Manifest_Aggregate_Bool_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  title?: Maybe<String_Comparison_Exp>;
  transfer_items?: Maybe<Stock_Transfer_Item_Bool_Exp>;
  transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Bool_Exp>;
  transfer_shipments?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
  transfer_shipments_aggregate?: Maybe<Stock_Transfer_Shipment_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "location" */
export const Location_Constraint = {
  /** unique or primary key constraint on columns "id" */
  LocationPkey: 'location_pkey',
  /** unique or primary key constraint on columns  */
  LocationShopifyLocationId: 'location_shopify_location_id',
  /** unique or primary key constraint on columns "store_id" */
  LocationStoreIdIsDefaultTrueKey: 'location_store_id_is_default_true_key'
} as const;

export type Location_Constraint = typeof Location_Constraint[keyof typeof Location_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Location_Delete_At_Path_Input = {
  integrations?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Location_Delete_Elem_Input = {
  integrations?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Location_Delete_Key_Input = {
  integrations?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "location" */
export type Location_Inc_Input = {
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "location" */
export type Location_Insert_Input = {
  address?: Maybe<Address_Obj_Rel_Insert_Input>;
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center?: Maybe<Fulfilment_Center_Obj_Rel_Insert_Input>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  inventory_item_quantities?: Maybe<Inventory_Item_Quantity_Arr_Rel_Insert_Input>;
  is_default?: Maybe<Scalars['Boolean']>;
  is_skutopia_fc?: Maybe<Scalars['Boolean']>;
  is_virtual?: Maybe<Scalars['Boolean']>;
  manifests?: Maybe<Manifest_Arr_Rel_Insert_Input>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  transfer_items?: Maybe<Stock_Transfer_Item_Arr_Rel_Insert_Input>;
  transfer_shipments?: Maybe<Stock_Transfer_Shipment_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Location_Max_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "location" */
export type Location_Max_Order_By = {
  address_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Location_Min_Fields = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "location" */
export type Location_Min_Order_By = {
  address_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "location" */
export type Location_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Location>;
};

/** input type for inserting object relation for remote table "location" */
export type Location_Obj_Rel_Insert_Input = {
  data: Location_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Location_On_Conflict>;
};

/** on_conflict condition type for table "location" */
export type Location_On_Conflict = {
  constraint: Location_Constraint;
  update_columns?: Array<Location_Update_Column>;
  where?: Maybe<Location_Bool_Exp>;
};

/** Ordering options when selecting data from "location". */
export type Location_Order_By = {
  address?: Maybe<Address_Order_By>;
  address_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fulfilment_center?: Maybe<Fulfilment_Center_Order_By>;
  fulfilment_center_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  integrations?: Maybe<Order_By>;
  inventory_item_quantities_aggregate?: Maybe<Inventory_Item_Quantity_Aggregate_Order_By>;
  is_default?: Maybe<Order_By>;
  is_skutopia_fc?: Maybe<Order_By>;
  is_virtual?: Maybe<Order_By>;
  manifests_aggregate?: Maybe<Manifest_Aggregate_Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Order_By>;
  transfer_shipments_aggregate?: Maybe<Stock_Transfer_Shipment_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: location */
export type Location_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Location_Prepend_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "location" */
export const Location_Select_Column = {
  /** column name */
  AddressId: 'address_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FulfilmentCenterId: 'fulfilment_center_id',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  IsSkutopiaFc: 'is_skutopia_fc',
  /** column name */
  IsVirtual: 'is_virtual',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Title: 'title',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Location_Select_Column = typeof Location_Select_Column[keyof typeof Location_Select_Column];
/** select "location_aggregate_bool_exp_bool_and_arguments_columns" columns of table "location" */
export const Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  IsSkutopiaFc: 'is_skutopia_fc',
  /** column name */
  IsVirtual: 'is_virtual'
} as const;

export type Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "location_aggregate_bool_exp_bool_or_arguments_columns" columns of table "location" */
export const Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  IsSkutopiaFc: 'is_skutopia_fc',
  /** column name */
  IsVirtual: 'is_virtual'
} as const;

export type Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Location_Select_Column_Location_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "location" */
export type Location_Set_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  is_default?: Maybe<Scalars['Boolean']>;
  is_skutopia_fc?: Maybe<Scalars['Boolean']>;
  is_virtual?: Maybe<Scalars['Boolean']>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Location_Stddev_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "location" */
export type Location_Stddev_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Location_Stddev_Pop_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "location" */
export type Location_Stddev_Pop_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Location_Stddev_Samp_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "location" */
export type Location_Stddev_Samp_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "location" */
export type Location_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Location_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Location_Stream_Cursor_Value_Input = {
  address_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  is_default?: Maybe<Scalars['Boolean']>;
  is_skutopia_fc?: Maybe<Scalars['Boolean']>;
  is_virtual?: Maybe<Scalars['Boolean']>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Location_Sum_Fields = {
  fulfilment_center_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "location" */
export type Location_Sum_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
};

/** update columns of table "location" */
export const Location_Update_Column = {
  /** column name */
  AddressId: 'address_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FulfilmentCenterId: 'fulfilment_center_id',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  IsSkutopiaFc: 'is_skutopia_fc',
  /** column name */
  IsVirtual: 'is_virtual',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Title: 'title',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Location_Update_Column = typeof Location_Update_Column[keyof typeof Location_Update_Column];
export type Location_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Location_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Location_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Location_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Location_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Location_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Location_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Location_Set_Input>;
  /** filter the rows which have to be updated */
  where: Location_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Location_Var_Pop_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "location" */
export type Location_Var_Pop_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Location_Var_Samp_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "location" */
export type Location_Var_Samp_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Location_Variance_Fields = {
  fulfilment_center_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "location" */
export type Location_Variance_Order_By = {
  fulfilment_center_id?: Maybe<Order_By>;
};

/** columns and relationships of "manifest" */
export type Manifest = {
  /** An object relationship */
  carrier?: Maybe<Carrier>;
  carrier_id?: Maybe<Scalars['uuid']>;
  /** The id of the manifest used by the specific carrier. ShipEngine's submission_id. */
  carrier_reference_id?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  /** Array of paths to the manifest document. Generally a PDF file */
  document_paths: Scalars['jsonb'];
  /** An object relationship */
  fc_carrier?: Maybe<Fulfilment_Center_Carrier>;
  fc_carrier_id?: Maybe<Scalars['bigint']>;
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  id: Scalars['uuid'];
  integrations?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  location?: Maybe<Location>;
  location_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "manifest" */
export type ManifestDocument_PathsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "manifest" */
export type ManifestFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "manifest" */
export type ManifestFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "manifest" */
export type ManifestIntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "manifest" */
export type Manifest_Aggregate = {
  aggregate?: Maybe<Manifest_Aggregate_Fields>;
  nodes: Array<Manifest>;
};

export type Manifest_Aggregate_Bool_Exp = {
  count?: Maybe<Manifest_Aggregate_Bool_Exp_Count>;
};

export type Manifest_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Manifest_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Manifest_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "manifest" */
export type Manifest_Aggregate_Fields = {
  avg?: Maybe<Manifest_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Manifest_Max_Fields>;
  min?: Maybe<Manifest_Min_Fields>;
  stddev?: Maybe<Manifest_Stddev_Fields>;
  stddev_pop?: Maybe<Manifest_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Manifest_Stddev_Samp_Fields>;
  sum?: Maybe<Manifest_Sum_Fields>;
  var_pop?: Maybe<Manifest_Var_Pop_Fields>;
  var_samp?: Maybe<Manifest_Var_Samp_Fields>;
  variance?: Maybe<Manifest_Variance_Fields>;
};


/** aggregate fields of "manifest" */
export type Manifest_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Manifest_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "manifest" */
export type Manifest_Aggregate_Order_By = {
  avg?: Maybe<Manifest_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Manifest_Max_Order_By>;
  min?: Maybe<Manifest_Min_Order_By>;
  stddev?: Maybe<Manifest_Stddev_Order_By>;
  stddev_pop?: Maybe<Manifest_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Manifest_Stddev_Samp_Order_By>;
  sum?: Maybe<Manifest_Sum_Order_By>;
  var_pop?: Maybe<Manifest_Var_Pop_Order_By>;
  var_samp?: Maybe<Manifest_Var_Samp_Order_By>;
  variance?: Maybe<Manifest_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Manifest_Append_Input = {
  /** Array of paths to the manifest document. Generally a PDF file */
  document_paths?: Maybe<Scalars['jsonb']>;
  integrations?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "manifest" */
export type Manifest_Arr_Rel_Insert_Input = {
  data: Array<Manifest_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Manifest_On_Conflict>;
};

/** aggregate avg on columns */
export type Manifest_Avg_Fields = {
  fc_carrier_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "manifest" */
export type Manifest_Avg_Order_By = {
  fc_carrier_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "manifest". All fields are combined with a logical 'AND'. */
export type Manifest_Bool_Exp = {
  _and?: Maybe<Array<Manifest_Bool_Exp>>;
  _not?: Maybe<Manifest_Bool_Exp>;
  _or?: Maybe<Array<Manifest_Bool_Exp>>;
  carrier?: Maybe<Carrier_Bool_Exp>;
  carrier_id?: Maybe<Uuid_Comparison_Exp>;
  carrier_reference_id?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  document_paths?: Maybe<Jsonb_Comparison_Exp>;
  fc_carrier?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
  fc_carrier_id?: Maybe<Bigint_Comparison_Exp>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  integrations?: Maybe<Jsonb_Comparison_Exp>;
  location?: Maybe<Location_Bool_Exp>;
  location_id?: Maybe<Uuid_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "manifest" */
export const Manifest_Constraint = {
  /** unique or primary key constraint on columns "id" */
  ManifestPkey: 'manifest_pkey'
} as const;

export type Manifest_Constraint = typeof Manifest_Constraint[keyof typeof Manifest_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Manifest_Delete_At_Path_Input = {
  /** Array of paths to the manifest document. Generally a PDF file */
  document_paths?: Maybe<Array<Scalars['String']>>;
  integrations?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Manifest_Delete_Elem_Input = {
  /** Array of paths to the manifest document. Generally a PDF file */
  document_paths?: Maybe<Scalars['Int']>;
  integrations?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Manifest_Delete_Key_Input = {
  /** Array of paths to the manifest document. Generally a PDF file */
  document_paths?: Maybe<Scalars['String']>;
  integrations?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "manifest" */
export type Manifest_Inc_Input = {
  fc_carrier_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "manifest" */
export type Manifest_Insert_Input = {
  carrier?: Maybe<Carrier_Obj_Rel_Insert_Input>;
  carrier_id?: Maybe<Scalars['uuid']>;
  /** The id of the manifest used by the specific carrier. ShipEngine's submission_id. */
  carrier_reference_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** Array of paths to the manifest document. Generally a PDF file */
  document_paths?: Maybe<Scalars['jsonb']>;
  fc_carrier?: Maybe<Fulfilment_Center_Carrier_Obj_Rel_Insert_Input>;
  fc_carrier_id?: Maybe<Scalars['bigint']>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  location?: Maybe<Location_Obj_Rel_Insert_Input>;
  location_id?: Maybe<Scalars['uuid']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Manifest_Max_Fields = {
  carrier_id?: Maybe<Scalars['uuid']>;
  /** The id of the manifest used by the specific carrier. ShipEngine's submission_id. */
  carrier_reference_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fc_carrier_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  location_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "manifest" */
export type Manifest_Max_Order_By = {
  carrier_id?: Maybe<Order_By>;
  /** The id of the manifest used by the specific carrier. ShipEngine's submission_id. */
  carrier_reference_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fc_carrier_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Manifest_Min_Fields = {
  carrier_id?: Maybe<Scalars['uuid']>;
  /** The id of the manifest used by the specific carrier. ShipEngine's submission_id. */
  carrier_reference_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fc_carrier_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  location_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "manifest" */
export type Manifest_Min_Order_By = {
  carrier_id?: Maybe<Order_By>;
  /** The id of the manifest used by the specific carrier. ShipEngine's submission_id. */
  carrier_reference_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fc_carrier_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "manifest" */
export type Manifest_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Manifest>;
};

/** input type for inserting object relation for remote table "manifest" */
export type Manifest_Obj_Rel_Insert_Input = {
  data: Manifest_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Manifest_On_Conflict>;
};

/** on_conflict condition type for table "manifest" */
export type Manifest_On_Conflict = {
  constraint: Manifest_Constraint;
  update_columns?: Array<Manifest_Update_Column>;
  where?: Maybe<Manifest_Bool_Exp>;
};

/** Ordering options when selecting data from "manifest". */
export type Manifest_Order_By = {
  carrier?: Maybe<Carrier_Order_By>;
  carrier_id?: Maybe<Order_By>;
  carrier_reference_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  document_paths?: Maybe<Order_By>;
  fc_carrier?: Maybe<Fulfilment_Center_Carrier_Order_By>;
  fc_carrier_id?: Maybe<Order_By>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  integrations?: Maybe<Order_By>;
  location?: Maybe<Location_Order_By>;
  location_id?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: manifest */
export type Manifest_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Manifest_Prepend_Input = {
  /** Array of paths to the manifest document. Generally a PDF file */
  document_paths?: Maybe<Scalars['jsonb']>;
  integrations?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "manifest" */
export const Manifest_Select_Column = {
  /** column name */
  CarrierId: 'carrier_id',
  /** column name */
  CarrierReferenceId: 'carrier_reference_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DocumentPaths: 'document_paths',
  /** column name */
  FcCarrierId: 'fc_carrier_id',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  LocationId: 'location_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Manifest_Select_Column = typeof Manifest_Select_Column[keyof typeof Manifest_Select_Column];
/** input type for updating data in table "manifest" */
export type Manifest_Set_Input = {
  carrier_id?: Maybe<Scalars['uuid']>;
  /** The id of the manifest used by the specific carrier. ShipEngine's submission_id. */
  carrier_reference_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** Array of paths to the manifest document. Generally a PDF file */
  document_paths?: Maybe<Scalars['jsonb']>;
  fc_carrier_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  location_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Manifest_Stddev_Fields = {
  fc_carrier_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "manifest" */
export type Manifest_Stddev_Order_By = {
  fc_carrier_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Manifest_Stddev_Pop_Fields = {
  fc_carrier_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "manifest" */
export type Manifest_Stddev_Pop_Order_By = {
  fc_carrier_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Manifest_Stddev_Samp_Fields = {
  fc_carrier_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "manifest" */
export type Manifest_Stddev_Samp_Order_By = {
  fc_carrier_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "manifest" */
export type Manifest_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Manifest_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Manifest_Stream_Cursor_Value_Input = {
  carrier_id?: Maybe<Scalars['uuid']>;
  /** The id of the manifest used by the specific carrier. ShipEngine's submission_id. */
  carrier_reference_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** Array of paths to the manifest document. Generally a PDF file */
  document_paths?: Maybe<Scalars['jsonb']>;
  fc_carrier_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  location_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Manifest_Sum_Fields = {
  fc_carrier_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "manifest" */
export type Manifest_Sum_Order_By = {
  fc_carrier_id?: Maybe<Order_By>;
};

/** update columns of table "manifest" */
export const Manifest_Update_Column = {
  /** column name */
  CarrierId: 'carrier_id',
  /** column name */
  CarrierReferenceId: 'carrier_reference_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DocumentPaths: 'document_paths',
  /** column name */
  FcCarrierId: 'fc_carrier_id',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  LocationId: 'location_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Manifest_Update_Column = typeof Manifest_Update_Column[keyof typeof Manifest_Update_Column];
export type Manifest_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Manifest_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Manifest_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Manifest_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Manifest_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Manifest_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Manifest_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Manifest_Set_Input>;
  /** filter the rows which have to be updated */
  where: Manifest_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Manifest_Var_Pop_Fields = {
  fc_carrier_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "manifest" */
export type Manifest_Var_Pop_Order_By = {
  fc_carrier_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Manifest_Var_Samp_Fields = {
  fc_carrier_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "manifest" */
export type Manifest_Var_Samp_Order_By = {
  fc_carrier_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Manifest_Variance_Fields = {
  fc_carrier_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "manifest" */
export type Manifest_Variance_Order_By = {
  fc_carrier_id?: Maybe<Order_By>;
};

/** mutation root */
export type Mutation_Root = {
  add_parcel_types?: Maybe<AddParcelTypesOutput>;
  add_shopify_store?: Maybe<AddShopifyStoreOutput>;
  /** Command handler for carrier setting commands */
  command_carrier_setting: CarrierSettingCommandOutput;
  /** Action handler for fulfilment shipments */
  command_fulfilment_shipment?: Maybe<FulfilmentShipmentCommandOutput>;
  command_fulfilment_shipments?: Maybe<FulfilmentShipmentsCommandOutput>;
  /** Command handler for sales order commands */
  command_sales_order?: Maybe<SalesOrderCommandOutput>;
  command_sales_orders?: Maybe<SalesOrdersCommandOutput>;
  /** Command handler for stock transfer commands */
  command_stock_transfer?: Maybe<StockTransferCommandOutput>;
  command_test_order?: Maybe<TestOrderCommandOutput>;
  /** This mutation is used in shop-front application (server/actions/src/actions/shopify) */
  connect_shopify_store?: Maybe<ConnectShopifyStoreOutput>;
  create_manifest?: Maybe<Array<Maybe<CreateManifestOutput>>>;
  /** delete data from the table: "address_type" */
  delete_address_types?: Maybe<Address_Type_Mutation_Response>;
  /** delete single row from the table: "address_type" */
  delete_address_types_by_pk?: Maybe<Address_Type>;
  /** delete data from the table: "address" */
  delete_addresses?: Maybe<Address_Mutation_Response>;
  /** delete single row from the table: "address" */
  delete_addresses_by_pk?: Maybe<Address>;
  /** delete data from the table: "auth.account_providers" */
  delete_auth_account_providers?: Maybe<Auth_Account_Providers_Mutation_Response>;
  /** delete single row from the table: "auth.account_providers" */
  delete_auth_account_providers_by_pk?: Maybe<Auth_Account_Providers>;
  /** delete data from the table: "auth.account_roles" */
  delete_auth_account_roles?: Maybe<Auth_Account_Roles_Mutation_Response>;
  /** delete single row from the table: "auth.account_roles" */
  delete_auth_account_roles_by_pk?: Maybe<Auth_Account_Roles>;
  /** delete data from the table: "auth.accounts" */
  delete_auth_accounts?: Maybe<Auth_Accounts_Mutation_Response>;
  /** delete single row from the table: "auth.accounts" */
  delete_auth_accounts_by_pk?: Maybe<Auth_Accounts>;
  /** delete data from the table: "auth.providers" */
  delete_auth_providers?: Maybe<Auth_Providers_Mutation_Response>;
  /** delete single row from the table: "auth.providers" */
  delete_auth_providers_by_pk?: Maybe<Auth_Providers>;
  /** delete data from the table: "auth.refresh_tokens" */
  delete_auth_refresh_tokens?: Maybe<Auth_Refresh_Tokens_Mutation_Response>;
  /** delete single row from the table: "auth.refresh_tokens" */
  delete_auth_refresh_tokens_by_pk?: Maybe<Auth_Refresh_Tokens>;
  /** delete data from the table: "auth.roles" */
  delete_auth_roles?: Maybe<Auth_Roles_Mutation_Response>;
  /** delete single row from the table: "auth.roles" */
  delete_auth_roles_by_pk?: Maybe<Auth_Roles>;
  /** delete data from the table: "carrier_selection" */
  delete_carrier_selection?: Maybe<Carrier_Selection_Mutation_Response>;
  /** delete single row from the table: "carrier_selection" */
  delete_carrier_selection_by_pk?: Maybe<Carrier_Selection>;
  /** delete data from the table: "carrier" */
  delete_carriers?: Maybe<Carrier_Mutation_Response>;
  /** delete single row from the table: "carrier" */
  delete_carriers_by_pk?: Maybe<Carrier>;
  /** delete data from the table: "customer" */
  delete_customers?: Maybe<Customer_Mutation_Response>;
  /** delete single row from the table: "customer" */
  delete_customers_by_pk?: Maybe<Customer>;
  /** delete data from the table: "draft_fulfilment_shipment" */
  delete_draft_fulfilment_shipment?: Maybe<Draft_Fulfilment_Shipment_Mutation_Response>;
  /** delete data from the table: "event_core.event_store" */
  delete_event_core_event_store?: Maybe<Event_Core_Event_Store_Mutation_Response>;
  /** delete single row from the table: "event_core.event_store" */
  delete_event_core_event_store_by_pk?: Maybe<Event_Core_Event_Store>;
  /** delete data from the table: "feature_flag" */
  delete_feature_flags?: Maybe<Feature_Flag_Mutation_Response>;
  /** delete single row from the table: "feature_flag" */
  delete_feature_flags_by_pk?: Maybe<Feature_Flag>;
  /** delete data from the table: "fulfilment_center_carrier" */
  delete_fulfilment_center_carriers?: Maybe<Fulfilment_Center_Carrier_Mutation_Response>;
  /** delete single row from the table: "fulfilment_center_carrier" */
  delete_fulfilment_center_carriers_by_pk?: Maybe<Fulfilment_Center_Carrier>;
  /** delete data from the table: "fulfilment_center" */
  delete_fulfilment_centers?: Maybe<Fulfilment_Center_Mutation_Response>;
  /** delete single row from the table: "fulfilment_center" */
  delete_fulfilment_centers_by_pk?: Maybe<Fulfilment_Center>;
  /** delete data from the table: "fulfilment_shipment_line_item" */
  delete_fulfilment_shipment_line_items?: Maybe<Fulfilment_Shipment_Line_Item_Mutation_Response>;
  /** delete single row from the table: "fulfilment_shipment_line_item" */
  delete_fulfilment_shipment_line_items_by_pk?: Maybe<Fulfilment_Shipment_Line_Item>;
  /** delete data from the table: "fulfilment_shipment_parcel" */
  delete_fulfilment_shipment_parcels?: Maybe<Fulfilment_Shipment_Parcel_Mutation_Response>;
  /** delete single row from the table: "fulfilment_shipment_parcel" */
  delete_fulfilment_shipment_parcels_by_pk?: Maybe<Fulfilment_Shipment_Parcel>;
  /** delete data from the table: "fulfilment_shipment" */
  delete_fulfilment_shipments?: Maybe<Fulfilment_Shipment_Mutation_Response>;
  /** delete single row from the table: "fulfilment_shipment" */
  delete_fulfilment_shipments_by_pk?: Maybe<Fulfilment_Shipment>;
  /** delete data from the table: "integration_source" */
  delete_integration_source?: Maybe<Integration_Source_Mutation_Response>;
  /** delete single row from the table: "integration_source" */
  delete_integration_source_by_pk?: Maybe<Integration_Source>;
  /** delete data from the table: "integration" */
  delete_integrations?: Maybe<Integration_Mutation_Response>;
  /** delete single row from the table: "integration" */
  delete_integrations_by_pk?: Maybe<Integration>;
  /** delete data from the table: "inventory_item_quantity" */
  delete_inventory_item_quantities?: Maybe<Inventory_Item_Quantity_Mutation_Response>;
  /** delete single row from the table: "inventory_item_quantity" */
  delete_inventory_item_quantities_by_pk?: Maybe<Inventory_Item_Quantity>;
  /** delete data from the table: "inventory_item" */
  delete_inventory_items?: Maybe<Inventory_Item_Mutation_Response>;
  /** delete single row from the table: "inventory_item" */
  delete_inventory_items_by_pk?: Maybe<Inventory_Item>;
  /** delete data from the table: "inventory_sync_job_status" */
  delete_inventory_sync_job_status?: Maybe<Inventory_Sync_Job_Status_Mutation_Response>;
  /** delete single row from the table: "inventory_sync_job_status" */
  delete_inventory_sync_job_status_by_pk?: Maybe<Inventory_Sync_Job_Status>;
  /** delete data from the table: "inventory_sync_job" */
  delete_inventory_sync_jobs?: Maybe<Inventory_Sync_Job_Mutation_Response>;
  /** delete single row from the table: "inventory_sync_job" */
  delete_inventory_sync_jobs_by_pk?: Maybe<Inventory_Sync_Job>;
  /** delete data from the table: "location" */
  delete_locations?: Maybe<Location_Mutation_Response>;
  /** delete single row from the table: "location" */
  delete_locations_by_pk?: Maybe<Location>;
  /** delete data from the table: "manifest" */
  delete_manifests?: Maybe<Manifest_Mutation_Response>;
  /** delete single row from the table: "manifest" */
  delete_manifests_by_pk?: Maybe<Manifest>;
  /** delete data from the table: "organization" */
  delete_organizations?: Maybe<Organization_Mutation_Response>;
  /** delete single row from the table: "organization" */
  delete_organizations_by_pk?: Maybe<Organization>;
  /** delete data from the table: "packing_status" */
  delete_packing_statuses?: Maybe<Packing_Status_Mutation_Response>;
  /** delete single row from the table: "packing_status" */
  delete_packing_statuses_by_pk?: Maybe<Packing_Status>;
  /** delete data from the table: "parcel_type" */
  delete_parcel_types?: Maybe<Parcel_Type_Mutation_Response>;
  delete_parcel_types_by_ids?: Maybe<DeleteParcelTypesByIdsOutput>;
  /** delete single row from the table: "parcel_type" */
  delete_parcel_types_by_pk?: Maybe<Parcel_Type>;
  /** delete data from the table: "payment_status" */
  delete_payment_statuses?: Maybe<Payment_Status_Mutation_Response>;
  /** delete single row from the table: "payment_status" */
  delete_payment_statuses_by_pk?: Maybe<Payment_Status>;
  /** delete data from the table: "product_variant" */
  delete_product_variants?: Maybe<Product_Variant_Mutation_Response>;
  /** delete single row from the table: "product_variant" */
  delete_product_variants_by_pk?: Maybe<Product_Variant>;
  /** delete data from the table: "product" */
  delete_products?: Maybe<Product_Mutation_Response>;
  /** delete single row from the table: "product" */
  delete_products_by_pk?: Maybe<Product>;
  /** delete data from the table: "rate_request" */
  delete_rate_requests?: Maybe<Rate_Request_Mutation_Response>;
  /** delete single row from the table: "rate_request" */
  delete_rate_requests_by_pk?: Maybe<Rate_Request>;
  /** delete data from the table: "rate_selected_by" */
  delete_rate_selected_by?: Maybe<Rate_Selected_By_Mutation_Response>;
  /** delete single row from the table: "rate_selected_by" */
  delete_rate_selected_by_by_pk?: Maybe<Rate_Selected_By>;
  /** delete data from the table: "release_channel" */
  delete_release_channel?: Maybe<Release_Channel_Mutation_Response>;
  /** delete single row from the table: "release_channel" */
  delete_release_channel_by_pk?: Maybe<Release_Channel>;
  /** delete data from the table: "retail_unit" */
  delete_retail_units?: Maybe<Retail_Unit_Mutation_Response>;
  /** delete single row from the table: "retail_unit" */
  delete_retail_units_by_pk?: Maybe<Retail_Unit>;
  /** delete data from the table: "sales_channel" */
  delete_sales_channel?: Maybe<Sales_Channel_Mutation_Response>;
  /** delete single row from the table: "sales_channel" */
  delete_sales_channel_by_pk?: Maybe<Sales_Channel>;
  /** delete data from the table: "sales_order_integration" */
  delete_sales_order_integration?: Maybe<Sales_Order_Integration_Mutation_Response>;
  /** delete single row from the table: "sales_order_integration" */
  delete_sales_order_integration_by_pk?: Maybe<Sales_Order_Integration>;
  /** delete data from the table: "sales_order_line_item" */
  delete_sales_order_line_items?: Maybe<Sales_Order_Line_Item_Mutation_Response>;
  /** delete single row from the table: "sales_order_line_item" */
  delete_sales_order_line_items_by_pk?: Maybe<Sales_Order_Line_Item>;
  /** delete data from the table: "sales_order_shipment_charge" */
  delete_sales_order_shipment_charges?: Maybe<Sales_Order_Shipment_Charge_Mutation_Response>;
  /** delete single row from the table: "sales_order_shipment_charge" */
  delete_sales_order_shipment_charges_by_pk?: Maybe<Sales_Order_Shipment_Charge>;
  /** delete data from the table: "sales_order_status" */
  delete_sales_order_statuses?: Maybe<Sales_Order_Status_Mutation_Response>;
  /** delete single row from the table: "sales_order_status" */
  delete_sales_order_statuses_by_pk?: Maybe<Sales_Order_Status>;
  /** delete data from the table: "sales_order_tag" */
  delete_sales_order_tags?: Maybe<Sales_Order_Tag_Mutation_Response>;
  /** delete single row from the table: "sales_order_tag" */
  delete_sales_order_tags_by_pk?: Maybe<Sales_Order_Tag>;
  /** delete data from the table: "sales_order" */
  delete_sales_orders?: Maybe<Sales_Order_Mutation_Response>;
  /** delete single row from the table: "sales_order" */
  delete_sales_orders_by_pk?: Maybe<Sales_Order>;
  /** delete data from the table: "shipment_source" */
  delete_shipment_source?: Maybe<Shipment_Source_Mutation_Response>;
  /** delete single row from the table: "shipment_source" */
  delete_shipment_source_by_pk?: Maybe<Shipment_Source>;
  /** delete data from the table: "shipment_status" */
  delete_shipment_statuses?: Maybe<Shipment_Status_Mutation_Response>;
  /** delete single row from the table: "shipment_status" */
  delete_shipment_statuses_by_pk?: Maybe<Shipment_Status>;
  /** delete data from the table: "shipping_area" */
  delete_shipping_areas?: Maybe<Shipping_Area_Mutation_Response>;
  /** delete single row from the table: "shipping_area" */
  delete_shipping_areas_by_pk?: Maybe<Shipping_Area>;
  /** delete data from the table: "shipping_margin_type" */
  delete_shipping_margin_type?: Maybe<Shipping_Margin_Type_Mutation_Response>;
  /** delete single row from the table: "shipping_margin_type" */
  delete_shipping_margin_type_by_pk?: Maybe<Shipping_Margin_Type>;
  /** delete data from the table: "shipping_margin" */
  delete_shipping_margins?: Maybe<Shipping_Margin_Mutation_Response>;
  /** delete single row from the table: "shipping_margin" */
  delete_shipping_margins_by_pk?: Maybe<Shipping_Margin>;
  /** delete data from the table: "shipping_provider" */
  delete_shipping_provider?: Maybe<Shipping_Provider_Mutation_Response>;
  /** delete single row from the table: "shipping_provider" */
  delete_shipping_provider_by_pk?: Maybe<Shipping_Provider>;
  /** delete data from the table: "shipping_rate" */
  delete_shipping_rates?: Maybe<Shipping_Rate_Mutation_Response>;
  /** delete single row from the table: "shipping_rate" */
  delete_shipping_rates_by_pk?: Maybe<Shipping_Rate>;
  /** delete data from the table: "shopify.integration" */
  delete_shopify_integrations?: Maybe<Shopify_Integration_Mutation_Response>;
  /** delete single row from the table: "shopify.integration" */
  delete_shopify_integrations_by_pk?: Maybe<Shopify_Integration>;
  /** delete data from the table: "shopify.order_archive" */
  delete_shopify_order_archives?: Maybe<Shopify_Order_Archive_Mutation_Response>;
  /** delete single row from the table: "shopify.order_archive" */
  delete_shopify_order_archives_by_pk?: Maybe<Shopify_Order_Archive>;
  /** delete data from the table: "stock_transfer_item" */
  delete_stock_transfer_items?: Maybe<Stock_Transfer_Item_Mutation_Response>;
  /** delete single row from the table: "stock_transfer_item" */
  delete_stock_transfer_items_by_pk?: Maybe<Stock_Transfer_Item>;
  /** delete data from the table: "stock_transfer_parcel" */
  delete_stock_transfer_parcels?: Maybe<Stock_Transfer_Parcel_Mutation_Response>;
  /** delete single row from the table: "stock_transfer_parcel" */
  delete_stock_transfer_parcels_by_pk?: Maybe<Stock_Transfer_Parcel>;
  /** delete data from the table: "stock_transfer_shipment" */
  delete_stock_transfer_shipments?: Maybe<Stock_Transfer_Shipment_Mutation_Response>;
  /** delete single row from the table: "stock_transfer_shipment" */
  delete_stock_transfer_shipments_by_pk?: Maybe<Stock_Transfer_Shipment>;
  /** delete data from the table: "stock_transfer_status" */
  delete_stock_transfer_status?: Maybe<Stock_Transfer_Status_Mutation_Response>;
  /** delete single row from the table: "stock_transfer_status" */
  delete_stock_transfer_status_by_pk?: Maybe<Stock_Transfer_Status>;
  /** delete data from the table: "stock_transfer" */
  delete_stock_transfers?: Maybe<Stock_Transfer_Mutation_Response>;
  /** delete single row from the table: "stock_transfer" */
  delete_stock_transfers_by_pk?: Maybe<Stock_Transfer>;
  /** delete data from the table: "store_feature_flag" */
  delete_store_feature_flag?: Maybe<Store_Feature_Flag_Mutation_Response>;
  /** delete single row from the table: "store_feature_flag" */
  delete_store_feature_flag_by_pk?: Maybe<Store_Feature_Flag>;
  /** delete data from the table: "store_setting" */
  delete_store_setting?: Maybe<Store_Setting_Mutation_Response>;
  /** delete single row from the table: "store_setting" */
  delete_store_setting_by_pk?: Maybe<Store_Setting>;
  /** delete data from the table: "store_setting_key" */
  delete_store_setting_key?: Maybe<Store_Setting_Key_Mutation_Response>;
  /** delete single row from the table: "store_setting_key" */
  delete_store_setting_key_by_pk?: Maybe<Store_Setting_Key>;
  /** delete data from the table: "store_slug" */
  delete_store_slug?: Maybe<Store_Slug_Mutation_Response>;
  /** delete single row from the table: "store_slug" */
  delete_store_slug_by_pk?: Maybe<Store_Slug>;
  /** delete data from the table: "store" */
  delete_stores?: Maybe<Store_Mutation_Response>;
  /** delete single row from the table: "store" */
  delete_stores_by_pk?: Maybe<Store>;
  /** delete data from the table: "tag" */
  delete_tags?: Maybe<Tag_Mutation_Response>;
  /** delete single row from the table: "tag" */
  delete_tags_by_pk?: Maybe<Tag>;
  /** delete data from the table: "user_organization" */
  delete_user_organizations?: Maybe<User_Organization_Mutation_Response>;
  /** delete single row from the table: "user_organization" */
  delete_user_organizations_by_pk?: Maybe<User_Organization>;
  /** delete data from the table: "users" */
  delete_users?: Maybe<Users_Mutation_Response>;
  /** delete single row from the table: "users" */
  delete_users_by_pk?: Maybe<Users>;
  edit_address?: Maybe<EditAddressOutput>;
  edit_parcel_types_by_pk?: Maybe<EditParcelTypeOutput>;
  edit_product_variant_packages: Array<EditProductVariantPackagesOutput>;
  edit_store?: Maybe<EditStoreOutput>;
  initiate_shopify_inventory_sync?: Maybe<InitiateShopifyInventorySyncOutput>;
  /** insert data into the table: "address_type" */
  insert_address_types?: Maybe<Address_Type_Mutation_Response>;
  /** insert a single row into the table: "address_type" */
  insert_address_types_one?: Maybe<Address_Type>;
  /** insert data into the table: "address" */
  insert_addresses?: Maybe<Address_Mutation_Response>;
  /** insert a single row into the table: "address" */
  insert_addresses_one?: Maybe<Address>;
  /** insert data into the table: "auth.account_providers" */
  insert_auth_account_providers?: Maybe<Auth_Account_Providers_Mutation_Response>;
  /** insert a single row into the table: "auth.account_providers" */
  insert_auth_account_providers_one?: Maybe<Auth_Account_Providers>;
  /** insert data into the table: "auth.account_roles" */
  insert_auth_account_roles?: Maybe<Auth_Account_Roles_Mutation_Response>;
  /** insert a single row into the table: "auth.account_roles" */
  insert_auth_account_roles_one?: Maybe<Auth_Account_Roles>;
  /** insert data into the table: "auth.accounts" */
  insert_auth_accounts?: Maybe<Auth_Accounts_Mutation_Response>;
  /** insert a single row into the table: "auth.accounts" */
  insert_auth_accounts_one?: Maybe<Auth_Accounts>;
  /** insert data into the table: "auth.providers" */
  insert_auth_providers?: Maybe<Auth_Providers_Mutation_Response>;
  /** insert a single row into the table: "auth.providers" */
  insert_auth_providers_one?: Maybe<Auth_Providers>;
  /** insert data into the table: "auth.refresh_tokens" */
  insert_auth_refresh_tokens?: Maybe<Auth_Refresh_Tokens_Mutation_Response>;
  /** insert a single row into the table: "auth.refresh_tokens" */
  insert_auth_refresh_tokens_one?: Maybe<Auth_Refresh_Tokens>;
  /** insert data into the table: "auth.roles" */
  insert_auth_roles?: Maybe<Auth_Roles_Mutation_Response>;
  /** insert a single row into the table: "auth.roles" */
  insert_auth_roles_one?: Maybe<Auth_Roles>;
  /** insert data into the table: "carrier_selection" */
  insert_carrier_selection?: Maybe<Carrier_Selection_Mutation_Response>;
  /** insert a single row into the table: "carrier_selection" */
  insert_carrier_selection_one?: Maybe<Carrier_Selection>;
  /** insert data into the table: "carrier" */
  insert_carriers?: Maybe<Carrier_Mutation_Response>;
  /** insert a single row into the table: "carrier" */
  insert_carriers_one?: Maybe<Carrier>;
  /** insert data into the table: "customer" */
  insert_customers?: Maybe<Customer_Mutation_Response>;
  /** insert a single row into the table: "customer" */
  insert_customers_one?: Maybe<Customer>;
  /** insert data into the table: "draft_fulfilment_shipment" */
  insert_draft_fulfilment_shipment?: Maybe<Draft_Fulfilment_Shipment_Mutation_Response>;
  /** insert a single row into the table: "draft_fulfilment_shipment" */
  insert_draft_fulfilment_shipment_one?: Maybe<Draft_Fulfilment_Shipment>;
  /** insert data into the table: "event_core.event_store" */
  insert_event_core_event_store?: Maybe<Event_Core_Event_Store_Mutation_Response>;
  /** insert a single row into the table: "event_core.event_store" */
  insert_event_core_event_store_one?: Maybe<Event_Core_Event_Store>;
  /** insert data into the table: "feature_flag" */
  insert_feature_flags?: Maybe<Feature_Flag_Mutation_Response>;
  /** insert a single row into the table: "feature_flag" */
  insert_feature_flags_one?: Maybe<Feature_Flag>;
  /** insert data into the table: "fulfilment_center_carrier" */
  insert_fulfilment_center_carriers?: Maybe<Fulfilment_Center_Carrier_Mutation_Response>;
  /** insert a single row into the table: "fulfilment_center_carrier" */
  insert_fulfilment_center_carriers_one?: Maybe<Fulfilment_Center_Carrier>;
  /** insert data into the table: "fulfilment_center" */
  insert_fulfilment_centers?: Maybe<Fulfilment_Center_Mutation_Response>;
  /** insert a single row into the table: "fulfilment_center" */
  insert_fulfilment_centers_one?: Maybe<Fulfilment_Center>;
  /** insert data into the table: "fulfilment_shipment_line_item" */
  insert_fulfilment_shipment_line_items?: Maybe<Fulfilment_Shipment_Line_Item_Mutation_Response>;
  /** insert a single row into the table: "fulfilment_shipment_line_item" */
  insert_fulfilment_shipment_line_items_one?: Maybe<Fulfilment_Shipment_Line_Item>;
  /** insert data into the table: "fulfilment_shipment_parcel" */
  insert_fulfilment_shipment_parcels?: Maybe<Fulfilment_Shipment_Parcel_Mutation_Response>;
  /** insert a single row into the table: "fulfilment_shipment_parcel" */
  insert_fulfilment_shipment_parcels_one?: Maybe<Fulfilment_Shipment_Parcel>;
  /** insert data into the table: "fulfilment_shipment" */
  insert_fulfilment_shipments?: Maybe<Fulfilment_Shipment_Mutation_Response>;
  /** insert a single row into the table: "fulfilment_shipment" */
  insert_fulfilment_shipments_one?: Maybe<Fulfilment_Shipment>;
  /** insert data into the table: "integration_source" */
  insert_integration_source?: Maybe<Integration_Source_Mutation_Response>;
  /** insert a single row into the table: "integration_source" */
  insert_integration_source_one?: Maybe<Integration_Source>;
  /** insert data into the table: "integration" */
  insert_integrations?: Maybe<Integration_Mutation_Response>;
  /** insert a single row into the table: "integration" */
  insert_integrations_one?: Maybe<Integration>;
  /** insert data into the table: "inventory_item_quantity" */
  insert_inventory_item_quantities?: Maybe<Inventory_Item_Quantity_Mutation_Response>;
  /** insert a single row into the table: "inventory_item_quantity" */
  insert_inventory_item_quantities_one?: Maybe<Inventory_Item_Quantity>;
  /** insert data into the table: "inventory_item" */
  insert_inventory_items?: Maybe<Inventory_Item_Mutation_Response>;
  /** insert a single row into the table: "inventory_item" */
  insert_inventory_items_one?: Maybe<Inventory_Item>;
  /** insert data into the table: "inventory_sync_job_status" */
  insert_inventory_sync_job_status?: Maybe<Inventory_Sync_Job_Status_Mutation_Response>;
  /** insert a single row into the table: "inventory_sync_job_status" */
  insert_inventory_sync_job_status_one?: Maybe<Inventory_Sync_Job_Status>;
  /** insert data into the table: "inventory_sync_job" */
  insert_inventory_sync_jobs?: Maybe<Inventory_Sync_Job_Mutation_Response>;
  /** insert a single row into the table: "inventory_sync_job" */
  insert_inventory_sync_jobs_one?: Maybe<Inventory_Sync_Job>;
  /** insert data into the table: "location" */
  insert_locations?: Maybe<Location_Mutation_Response>;
  /** insert a single row into the table: "location" */
  insert_locations_one?: Maybe<Location>;
  /** insert data into the table: "manifest" */
  insert_manifests?: Maybe<Manifest_Mutation_Response>;
  /** insert a single row into the table: "manifest" */
  insert_manifests_by_pk?: Maybe<Manifest>;
  /** insert data into the table: "organization" */
  insert_organizations?: Maybe<Organization_Mutation_Response>;
  /** insert a single row into the table: "organization" */
  insert_organizations_one?: Maybe<Organization>;
  /** insert data into the table: "packing_status" */
  insert_packing_statuses?: Maybe<Packing_Status_Mutation_Response>;
  /** insert a single row into the table: "packing_status" */
  insert_packing_statuses_one?: Maybe<Packing_Status>;
  /** insert data into the table: "parcel_type" */
  insert_parcel_types?: Maybe<Parcel_Type_Mutation_Response>;
  /** insert a single row into the table: "parcel_type" */
  insert_parcel_types_one?: Maybe<Parcel_Type>;
  /** insert data into the table: "payment_status" */
  insert_payment_statuses?: Maybe<Payment_Status_Mutation_Response>;
  /** insert a single row into the table: "payment_status" */
  insert_payment_statuses_one?: Maybe<Payment_Status>;
  /** insert data into the table: "product_variant" */
  insert_product_variants?: Maybe<Product_Variant_Mutation_Response>;
  /** insert a single row into the table: "product_variant" */
  insert_product_variants_one?: Maybe<Product_Variant>;
  /** insert data into the table: "product" */
  insert_products?: Maybe<Product_Mutation_Response>;
  /** insert a single row into the table: "product" */
  insert_products_one?: Maybe<Product>;
  /** insert data into the table: "rate_request" */
  insert_rate_requests?: Maybe<Rate_Request_Mutation_Response>;
  /** insert a single row into the table: "rate_request" */
  insert_rate_requests_one?: Maybe<Rate_Request>;
  /** insert data into the table: "rate_selected_by" */
  insert_rate_selected_by?: Maybe<Rate_Selected_By_Mutation_Response>;
  /** insert a single row into the table: "rate_selected_by" */
  insert_rate_selected_by_one?: Maybe<Rate_Selected_By>;
  /** insert data into the table: "release_channel" */
  insert_release_channel?: Maybe<Release_Channel_Mutation_Response>;
  /** insert a single row into the table: "release_channel" */
  insert_release_channel_one?: Maybe<Release_Channel>;
  /** insert data into the table: "retail_unit" */
  insert_retail_units?: Maybe<Retail_Unit_Mutation_Response>;
  /** insert a single row into the table: "retail_unit" */
  insert_retail_units_one?: Maybe<Retail_Unit>;
  /** insert data into the table: "sales_channel" */
  insert_sales_channel?: Maybe<Sales_Channel_Mutation_Response>;
  /** insert a single row into the table: "sales_channel" */
  insert_sales_channel_one?: Maybe<Sales_Channel>;
  /** insert data into the table: "sales_order_integration" */
  insert_sales_order_integration?: Maybe<Sales_Order_Integration_Mutation_Response>;
  /** insert a single row into the table: "sales_order_integration" */
  insert_sales_order_integration_one?: Maybe<Sales_Order_Integration>;
  /** insert data into the table: "sales_order_line_item" */
  insert_sales_order_line_items?: Maybe<Sales_Order_Line_Item_Mutation_Response>;
  /** insert a single row into the table: "sales_order_line_item" */
  insert_sales_order_line_items_one?: Maybe<Sales_Order_Line_Item>;
  /** insert data into the table: "sales_order_shipment_charge" */
  insert_sales_order_shipment_charges?: Maybe<Sales_Order_Shipment_Charge_Mutation_Response>;
  /** insert data into the table: "sales_order_status" */
  insert_sales_order_statuses?: Maybe<Sales_Order_Status_Mutation_Response>;
  /** insert a single row into the table: "sales_order_status" */
  insert_sales_order_statuses_one?: Maybe<Sales_Order_Status>;
  /** insert data into the table: "sales_order_tag" */
  insert_sales_order_tags?: Maybe<Sales_Order_Tag_Mutation_Response>;
  /** insert a single row into the table: "sales_order_tag" */
  insert_sales_order_tags_one?: Maybe<Sales_Order_Tag>;
  /** insert data into the table: "sales_order" */
  insert_sales_orders?: Maybe<Sales_Order_Mutation_Response>;
  /** insert a single row into the table: "sales_order" */
  insert_sales_orders_one?: Maybe<Sales_Order>;
  /** insert data into the table: "shipment_source" */
  insert_shipment_source?: Maybe<Shipment_Source_Mutation_Response>;
  /** insert a single row into the table: "shipment_source" */
  insert_shipment_source_one?: Maybe<Shipment_Source>;
  /** insert data into the table: "shipment_status" */
  insert_shipment_statuses?: Maybe<Shipment_Status_Mutation_Response>;
  /** insert a single row into the table: "shipment_status" */
  insert_shipment_statuses_one?: Maybe<Shipment_Status>;
  /** insert data into the table: "shipping_area" */
  insert_shipping_areas?: Maybe<Shipping_Area_Mutation_Response>;
  /** insert a single row into the table: "shipping_area" */
  insert_shipping_areas_one?: Maybe<Shipping_Area>;
  /** insert data into the table: "shipping_margin_type" */
  insert_shipping_margin_type?: Maybe<Shipping_Margin_Type_Mutation_Response>;
  /** insert a single row into the table: "shipping_margin_type" */
  insert_shipping_margin_type_one?: Maybe<Shipping_Margin_Type>;
  /** insert data into the table: "shipping_margin" */
  insert_shipping_margins?: Maybe<Shipping_Margin_Mutation_Response>;
  /** insert a single row into the table: "shipping_margin" */
  insert_shipping_margins_one?: Maybe<Shipping_Margin>;
  /** insert data into the table: "shipping_provider" */
  insert_shipping_provider?: Maybe<Shipping_Provider_Mutation_Response>;
  /** insert a single row into the table: "shipping_provider" */
  insert_shipping_provider_one?: Maybe<Shipping_Provider>;
  /** insert data into the table: "shipping_rate" */
  insert_shipping_rates?: Maybe<Shipping_Rate_Mutation_Response>;
  /** insert a single row into the table: "shipping_rate" */
  insert_shipping_rates_one?: Maybe<Shipping_Rate>;
  /** insert data into the table: "shopify.integration" */
  insert_shopify_integrations?: Maybe<Shopify_Integration_Mutation_Response>;
  /** insert a single row into the table: "shopify.integration" */
  insert_shopify_integrations_one?: Maybe<Shopify_Integration>;
  /** insert data into the table: "shopify.order_archive" */
  insert_shopify_order_archives?: Maybe<Shopify_Order_Archive_Mutation_Response>;
  /** insert a single row into the table: "shopify.order_archive" */
  insert_shopify_order_archives_one?: Maybe<Shopify_Order_Archive>;
  /** insert data into the table: "stock_transfer_item" */
  insert_stock_transfer_items?: Maybe<Stock_Transfer_Item_Mutation_Response>;
  /** insert a single row into the table: "stock_transfer_item" */
  insert_stock_transfer_items_one?: Maybe<Stock_Transfer_Item>;
  /** insert data into the table: "stock_transfer_parcel" */
  insert_stock_transfer_parcels?: Maybe<Stock_Transfer_Parcel_Mutation_Response>;
  /** insert a single row into the table: "stock_transfer_parcel" */
  insert_stock_transfer_parcels_one?: Maybe<Stock_Transfer_Parcel>;
  /** insert data into the table: "stock_transfer_shipment" */
  insert_stock_transfer_shipments?: Maybe<Stock_Transfer_Shipment_Mutation_Response>;
  /** insert a single row into the table: "stock_transfer_shipment" */
  insert_stock_transfer_shipments_one?: Maybe<Stock_Transfer_Shipment>;
  /** insert data into the table: "stock_transfer_status" */
  insert_stock_transfer_status?: Maybe<Stock_Transfer_Status_Mutation_Response>;
  /** insert a single row into the table: "stock_transfer_status" */
  insert_stock_transfer_status_one?: Maybe<Stock_Transfer_Status>;
  /** insert data into the table: "stock_transfer" */
  insert_stock_transfers?: Maybe<Stock_Transfer_Mutation_Response>;
  /** insert a single row into the table: "stock_transfer" */
  insert_stock_transfers_one?: Maybe<Stock_Transfer>;
  /** insert data into the table: "store_feature_flag" */
  insert_store_feature_flag?: Maybe<Store_Feature_Flag_Mutation_Response>;
  /** insert a single row into the table: "store_feature_flag" */
  insert_store_feature_flag_one?: Maybe<Store_Feature_Flag>;
  /** insert data into the table: "store_setting" */
  insert_store_setting?: Maybe<Store_Setting_Mutation_Response>;
  /** insert data into the table: "store_setting_key" */
  insert_store_setting_key?: Maybe<Store_Setting_Key_Mutation_Response>;
  /** insert a single row into the table: "store_setting_key" */
  insert_store_setting_key_one?: Maybe<Store_Setting_Key>;
  /** insert a single row into the table: "store_setting" */
  insert_store_setting_one?: Maybe<Store_Setting>;
  /** insert data into the table: "store_slug" */
  insert_store_slug?: Maybe<Store_Slug_Mutation_Response>;
  /** insert a single row into the table: "store_slug" */
  insert_store_slug_one?: Maybe<Store_Slug>;
  /** insert data into the table: "store" */
  insert_stores?: Maybe<Store_Mutation_Response>;
  /** insert a single row into the table: "store" */
  insert_stores_one?: Maybe<Store>;
  /** insert data into the table: "tag" */
  insert_tags?: Maybe<Tag_Mutation_Response>;
  /** insert a single row into the table: "tag" */
  insert_tags_one?: Maybe<Tag>;
  /** insert data into the table: "user_organization" */
  insert_user_organizations?: Maybe<User_Organization_Mutation_Response>;
  /** insert a single row into the table: "user_organization" */
  insert_user_organizations_one?: Maybe<User_Organization>;
  /** insert data into the table: "users" */
  insert_users?: Maybe<Users_Mutation_Response>;
  /** insert a single row into the table: "users" */
  insert_users_one?: Maybe<Users>;
  pack_line_items?: Maybe<PackLineItemsOutput>;
  replace_fulfilment_shipment_parcels?: Maybe<UpsertFulfilmentShipmentParcelOutput>;
  /** insert a single row into the table: "sales_order_shipment_charge" */
  sales_order_shipment_charges_one?: Maybe<Sales_Order_Shipment_Charge>;
  select_shipping_rate?: Maybe<SelectShippingRateOutput>;
  shipengine_tracking_handler?: Maybe<ShipEngineTrackingHandlerOutput>;
  shipping_webhook_shiptopia?: Maybe<ShippingWebhookHandlerOutput>;
  shopify_webhook_handler?: Maybe<ShopifyWebhookHandlerOutput>;
  sync_products?: Maybe<SyncProductsOutput>;
  sync_sales_order?: Maybe<SyncSalesOrderOutput>;
  /** update multiples rows of table: "address" */
  update_address_many?: Maybe<Array<Maybe<Address_Mutation_Response>>>;
  /** update multiples rows of table: "address_type" */
  update_address_type_many?: Maybe<Array<Maybe<Address_Type_Mutation_Response>>>;
  /** update data of the table: "address_type" */
  update_address_types?: Maybe<Address_Type_Mutation_Response>;
  /** update single row of the table: "address_type" */
  update_address_types_by_pk?: Maybe<Address_Type>;
  /** update data of the table: "address" */
  update_addresses?: Maybe<Address_Mutation_Response>;
  /** update single row of the table: "address" */
  update_addresses_by_pk?: Maybe<Address>;
  /** update data of the table: "auth.account_providers" */
  update_auth_account_providers?: Maybe<Auth_Account_Providers_Mutation_Response>;
  /** update single row of the table: "auth.account_providers" */
  update_auth_account_providers_by_pk?: Maybe<Auth_Account_Providers>;
  /** update multiples rows of table: "auth.account_providers" */
  update_auth_account_providers_many?: Maybe<Array<Maybe<Auth_Account_Providers_Mutation_Response>>>;
  /** update data of the table: "auth.account_roles" */
  update_auth_account_roles?: Maybe<Auth_Account_Roles_Mutation_Response>;
  /** update single row of the table: "auth.account_roles" */
  update_auth_account_roles_by_pk?: Maybe<Auth_Account_Roles>;
  /** update multiples rows of table: "auth.account_roles" */
  update_auth_account_roles_many?: Maybe<Array<Maybe<Auth_Account_Roles_Mutation_Response>>>;
  /** update data of the table: "auth.accounts" */
  update_auth_accounts?: Maybe<Auth_Accounts_Mutation_Response>;
  /** update single row of the table: "auth.accounts" */
  update_auth_accounts_by_pk?: Maybe<Auth_Accounts>;
  /** update multiples rows of table: "auth.accounts" */
  update_auth_accounts_many?: Maybe<Array<Maybe<Auth_Accounts_Mutation_Response>>>;
  /** update data of the table: "auth.providers" */
  update_auth_providers?: Maybe<Auth_Providers_Mutation_Response>;
  /** update single row of the table: "auth.providers" */
  update_auth_providers_by_pk?: Maybe<Auth_Providers>;
  /** update multiples rows of table: "auth.providers" */
  update_auth_providers_many?: Maybe<Array<Maybe<Auth_Providers_Mutation_Response>>>;
  /** update data of the table: "auth.refresh_tokens" */
  update_auth_refresh_tokens?: Maybe<Auth_Refresh_Tokens_Mutation_Response>;
  /** update single row of the table: "auth.refresh_tokens" */
  update_auth_refresh_tokens_by_pk?: Maybe<Auth_Refresh_Tokens>;
  /** update multiples rows of table: "auth.refresh_tokens" */
  update_auth_refresh_tokens_many?: Maybe<Array<Maybe<Auth_Refresh_Tokens_Mutation_Response>>>;
  /** update data of the table: "auth.roles" */
  update_auth_roles?: Maybe<Auth_Roles_Mutation_Response>;
  /** update single row of the table: "auth.roles" */
  update_auth_roles_by_pk?: Maybe<Auth_Roles>;
  /** update multiples rows of table: "auth.roles" */
  update_auth_roles_many?: Maybe<Array<Maybe<Auth_Roles_Mutation_Response>>>;
  /** update multiples rows of table: "carrier" */
  update_carrier_many?: Maybe<Array<Maybe<Carrier_Mutation_Response>>>;
  /** update data of the table: "carrier_selection" */
  update_carrier_selection?: Maybe<Carrier_Selection_Mutation_Response>;
  /** update single row of the table: "carrier_selection" */
  update_carrier_selection_by_pk?: Maybe<Carrier_Selection>;
  /** update multiples rows of table: "carrier_selection" */
  update_carrier_selection_many?: Maybe<Array<Maybe<Carrier_Selection_Mutation_Response>>>;
  /** update data of the table: "carrier" */
  update_carriers?: Maybe<Carrier_Mutation_Response>;
  /** update single row of the table: "carrier" */
  update_carriers_by_pk?: Maybe<Carrier>;
  /** update multiples rows of table: "customer" */
  update_customer_many?: Maybe<Array<Maybe<Customer_Mutation_Response>>>;
  /** update data of the table: "customer" */
  update_customers?: Maybe<Customer_Mutation_Response>;
  /** update single row of the table: "customer" */
  update_customers_by_pk?: Maybe<Customer>;
  /** update data of the table: "draft_fulfilment_shipment" */
  update_draft_fulfilment_shipment?: Maybe<Draft_Fulfilment_Shipment_Mutation_Response>;
  /** update multiples rows of table: "draft_fulfilment_shipment" */
  update_draft_fulfilment_shipment_many?: Maybe<Array<Maybe<Draft_Fulfilment_Shipment_Mutation_Response>>>;
  /** update data of the table: "event_core.event_store" */
  update_event_core_event_store?: Maybe<Event_Core_Event_Store_Mutation_Response>;
  /** update single row of the table: "event_core.event_store" */
  update_event_core_event_store_by_pk?: Maybe<Event_Core_Event_Store>;
  /** update multiples rows of table: "event_core.event_store" */
  update_event_core_event_store_many?: Maybe<Array<Maybe<Event_Core_Event_Store_Mutation_Response>>>;
  /** update multiples rows of table: "feature_flag" */
  update_feature_flag_many?: Maybe<Array<Maybe<Feature_Flag_Mutation_Response>>>;
  /** update data of the table: "feature_flag" */
  update_feature_flags?: Maybe<Feature_Flag_Mutation_Response>;
  /** update single row of the table: "feature_flag" */
  update_feature_flags_by_pk?: Maybe<Feature_Flag>;
  /** update multiples rows of table: "fulfilment_center_carrier" */
  update_fulfilment_center_carrier_many?: Maybe<Array<Maybe<Fulfilment_Center_Carrier_Mutation_Response>>>;
  /** update data of the table: "fulfilment_center_carrier" */
  update_fulfilment_center_carriers?: Maybe<Fulfilment_Center_Carrier_Mutation_Response>;
  /** update single row of the table: "fulfilment_center_carrier" */
  update_fulfilment_center_carriers_by_pk?: Maybe<Fulfilment_Center_Carrier>;
  /** update multiples rows of table: "fulfilment_center" */
  update_fulfilment_center_many?: Maybe<Array<Maybe<Fulfilment_Center_Mutation_Response>>>;
  /** update data of the table: "fulfilment_center" */
  update_fulfilment_centers?: Maybe<Fulfilment_Center_Mutation_Response>;
  /** update single row of the table: "fulfilment_center" */
  update_fulfilment_centers_by_pk?: Maybe<Fulfilment_Center>;
  /** update multiples rows of table: "fulfilment_shipment_line_item" */
  update_fulfilment_shipment_line_item_many?: Maybe<Array<Maybe<Fulfilment_Shipment_Line_Item_Mutation_Response>>>;
  /** update data of the table: "fulfilment_shipment_line_item" */
  update_fulfilment_shipment_line_items?: Maybe<Fulfilment_Shipment_Line_Item_Mutation_Response>;
  /** update single row of the table: "fulfilment_shipment_line_item" */
  update_fulfilment_shipment_line_items_by_pk?: Maybe<Fulfilment_Shipment_Line_Item>;
  /** update multiples rows of table: "fulfilment_shipment" */
  update_fulfilment_shipment_many?: Maybe<Array<Maybe<Fulfilment_Shipment_Mutation_Response>>>;
  /** update multiples rows of table: "fulfilment_shipment_parcel" */
  update_fulfilment_shipment_parcel_many?: Maybe<Array<Maybe<Fulfilment_Shipment_Parcel_Mutation_Response>>>;
  /** update data of the table: "fulfilment_shipment_parcel" */
  update_fulfilment_shipment_parcels?: Maybe<Fulfilment_Shipment_Parcel_Mutation_Response>;
  /** update single row of the table: "fulfilment_shipment_parcel" */
  update_fulfilment_shipment_parcels_by_pk?: Maybe<Fulfilment_Shipment_Parcel>;
  /** update data of the table: "fulfilment_shipment" */
  update_fulfilment_shipments?: Maybe<Fulfilment_Shipment_Mutation_Response>;
  /** update single row of the table: "fulfilment_shipment" */
  update_fulfilment_shipments_by_pk?: Maybe<Fulfilment_Shipment>;
  /** update multiples rows of table: "integration" */
  update_integration_many?: Maybe<Array<Maybe<Integration_Mutation_Response>>>;
  /** update data of the table: "integration_source" */
  update_integration_source?: Maybe<Integration_Source_Mutation_Response>;
  /** update single row of the table: "integration_source" */
  update_integration_source_by_pk?: Maybe<Integration_Source>;
  /** update multiples rows of table: "integration_source" */
  update_integration_source_many?: Maybe<Array<Maybe<Integration_Source_Mutation_Response>>>;
  /** update data of the table: "integration" */
  update_integrations?: Maybe<Integration_Mutation_Response>;
  /** update single row of the table: "integration" */
  update_integrations_by_pk?: Maybe<Integration>;
  /** update multiples rows of table: "inventory_item" */
  update_inventory_item_many?: Maybe<Array<Maybe<Inventory_Item_Mutation_Response>>>;
  /** update data of the table: "inventory_item_quantity" */
  update_inventory_item_quantities?: Maybe<Inventory_Item_Quantity_Mutation_Response>;
  /** update single row of the table: "inventory_item_quantity" */
  update_inventory_item_quantities_by_pk?: Maybe<Inventory_Item_Quantity>;
  /** update multiples rows of table: "inventory_item_quantity" */
  update_inventory_item_quantity_many?: Maybe<Array<Maybe<Inventory_Item_Quantity_Mutation_Response>>>;
  /** update data of the table: "inventory_item" */
  update_inventory_items?: Maybe<Inventory_Item_Mutation_Response>;
  /** update single row of the table: "inventory_item" */
  update_inventory_items_by_pk?: Maybe<Inventory_Item>;
  /** update multiples rows of table: "inventory_sync_job" */
  update_inventory_sync_job_many?: Maybe<Array<Maybe<Inventory_Sync_Job_Mutation_Response>>>;
  /** update data of the table: "inventory_sync_job_status" */
  update_inventory_sync_job_status?: Maybe<Inventory_Sync_Job_Status_Mutation_Response>;
  /** update single row of the table: "inventory_sync_job_status" */
  update_inventory_sync_job_status_by_pk?: Maybe<Inventory_Sync_Job_Status>;
  /** update multiples rows of table: "inventory_sync_job_status" */
  update_inventory_sync_job_status_many?: Maybe<Array<Maybe<Inventory_Sync_Job_Status_Mutation_Response>>>;
  /** update data of the table: "inventory_sync_job" */
  update_inventory_sync_jobs?: Maybe<Inventory_Sync_Job_Mutation_Response>;
  /** update single row of the table: "inventory_sync_job" */
  update_inventory_sync_jobs_by_pk?: Maybe<Inventory_Sync_Job>;
  /** update multiples rows of table: "location" */
  update_location_many?: Maybe<Array<Maybe<Location_Mutation_Response>>>;
  /** update data of the table: "location" */
  update_locations?: Maybe<Location_Mutation_Response>;
  /** update single row of the table: "location" */
  update_locations_by_pk?: Maybe<Location>;
  /** update multiples rows of table: "manifest" */
  update_manifest_many?: Maybe<Array<Maybe<Manifest_Mutation_Response>>>;
  /** update data of the table: "manifest" */
  update_manifests?: Maybe<Manifest_Mutation_Response>;
  /** update single row of the table: "manifest" */
  update_manifests_by_pk?: Maybe<Manifest>;
  /** update multiples rows of table: "organization" */
  update_organization_many?: Maybe<Array<Maybe<Organization_Mutation_Response>>>;
  /** update data of the table: "organization" */
  update_organizations?: Maybe<Organization_Mutation_Response>;
  /** update single row of the table: "organization" */
  update_organizations_by_pk?: Maybe<Organization>;
  /** update multiples rows of table: "packing_status" */
  update_packing_status_many?: Maybe<Array<Maybe<Packing_Status_Mutation_Response>>>;
  /** update data of the table: "packing_status" */
  update_packing_statuses?: Maybe<Packing_Status_Mutation_Response>;
  /** update single row of the table: "packing_status" */
  update_packing_statuses_by_pk?: Maybe<Packing_Status>;
  /** update multiples rows of table: "parcel_type" */
  update_parcel_type_many?: Maybe<Array<Maybe<Parcel_Type_Mutation_Response>>>;
  /** update data of the table: "parcel_type" */
  update_parcel_types?: Maybe<Parcel_Type_Mutation_Response>;
  /** update single row of the table: "parcel_type" */
  update_parcel_types_by_pk?: Maybe<Parcel_Type>;
  /** update multiples rows of table: "payment_status" */
  update_payment_status_many?: Maybe<Array<Maybe<Payment_Status_Mutation_Response>>>;
  /** update data of the table: "payment_status" */
  update_payment_statuses?: Maybe<Payment_Status_Mutation_Response>;
  /** update single row of the table: "payment_status" */
  update_payment_statuses_by_pk?: Maybe<Payment_Status>;
  /** update multiples rows of table: "product" */
  update_product_many?: Maybe<Array<Maybe<Product_Mutation_Response>>>;
  /** update multiples rows of table: "product_variant" */
  update_product_variant_many?: Maybe<Array<Maybe<Product_Variant_Mutation_Response>>>;
  /** update data of the table: "product_variant" */
  update_product_variants?: Maybe<Product_Variant_Mutation_Response>;
  /** update single row of the table: "product_variant" */
  update_product_variants_by_pk?: Maybe<Product_Variant>;
  /** update data of the table: "product" */
  update_products?: Maybe<Product_Mutation_Response>;
  /** update single row of the table: "product" */
  update_products_by_pk?: Maybe<Product>;
  /** update multiples rows of table: "rate_request" */
  update_rate_request_many?: Maybe<Array<Maybe<Rate_Request_Mutation_Response>>>;
  /** update data of the table: "rate_request" */
  update_rate_requests?: Maybe<Rate_Request_Mutation_Response>;
  /** update single row of the table: "rate_request" */
  update_rate_requests_by_pk?: Maybe<Rate_Request>;
  /** update data of the table: "rate_selected_by" */
  update_rate_selected_by?: Maybe<Rate_Selected_By_Mutation_Response>;
  /** update single row of the table: "rate_selected_by" */
  update_rate_selected_by_by_pk?: Maybe<Rate_Selected_By>;
  /** update multiples rows of table: "rate_selected_by" */
  update_rate_selected_by_many?: Maybe<Array<Maybe<Rate_Selected_By_Mutation_Response>>>;
  /** update data of the table: "release_channel" */
  update_release_channel?: Maybe<Release_Channel_Mutation_Response>;
  /** update single row of the table: "release_channel" */
  update_release_channel_by_pk?: Maybe<Release_Channel>;
  /** update multiples rows of table: "release_channel" */
  update_release_channel_many?: Maybe<Array<Maybe<Release_Channel_Mutation_Response>>>;
  /** update multiples rows of table: "retail_unit" */
  update_retail_unit_many?: Maybe<Array<Maybe<Retail_Unit_Mutation_Response>>>;
  /** update data of the table: "retail_unit" */
  update_retail_units?: Maybe<Retail_Unit_Mutation_Response>;
  /** update single row of the table: "retail_unit" */
  update_retail_units_by_pk?: Maybe<Retail_Unit>;
  /** update data of the table: "sales_channel" */
  update_sales_channel?: Maybe<Sales_Channel_Mutation_Response>;
  /** update single row of the table: "sales_channel" */
  update_sales_channel_by_pk?: Maybe<Sales_Channel>;
  /** update multiples rows of table: "sales_channel" */
  update_sales_channel_many?: Maybe<Array<Maybe<Sales_Channel_Mutation_Response>>>;
  /** update data of the table: "sales_order_integration" */
  update_sales_order_integration?: Maybe<Sales_Order_Integration_Mutation_Response>;
  /** update single row of the table: "sales_order_integration" */
  update_sales_order_integration_by_pk?: Maybe<Sales_Order_Integration>;
  /** update multiples rows of table: "sales_order_integration" */
  update_sales_order_integration_many?: Maybe<Array<Maybe<Sales_Order_Integration_Mutation_Response>>>;
  /** update multiples rows of table: "sales_order_line_item" */
  update_sales_order_line_item_many?: Maybe<Array<Maybe<Sales_Order_Line_Item_Mutation_Response>>>;
  /** update data of the table: "sales_order_line_item" */
  update_sales_order_line_items?: Maybe<Sales_Order_Line_Item_Mutation_Response>;
  /** update single row of the table: "sales_order_line_item" */
  update_sales_order_line_items_by_pk?: Maybe<Sales_Order_Line_Item>;
  /** update multiples rows of table: "sales_order" */
  update_sales_order_many?: Maybe<Array<Maybe<Sales_Order_Mutation_Response>>>;
  /** update multiples rows of table: "sales_order_shipment_charge" */
  update_sales_order_shipment_charge_many?: Maybe<Array<Maybe<Sales_Order_Shipment_Charge_Mutation_Response>>>;
  /** update data of the table: "sales_order_shipment_charge" */
  update_sales_order_shipment_charges?: Maybe<Sales_Order_Shipment_Charge_Mutation_Response>;
  /** update single row of the table: "sales_order_shipment_charge" */
  update_sales_order_shipment_charges_by_pk?: Maybe<Sales_Order_Shipment_Charge>;
  /** update multiples rows of table: "sales_order_status" */
  update_sales_order_status_many?: Maybe<Array<Maybe<Sales_Order_Status_Mutation_Response>>>;
  /** update data of the table: "sales_order_status" */
  update_sales_order_statuses?: Maybe<Sales_Order_Status_Mutation_Response>;
  /** update single row of the table: "sales_order_status" */
  update_sales_order_statuses_by_pk?: Maybe<Sales_Order_Status>;
  /** update multiples rows of table: "sales_order_tag" */
  update_sales_order_tag_many?: Maybe<Array<Maybe<Sales_Order_Tag_Mutation_Response>>>;
  /** update data of the table: "sales_order_tag" */
  update_sales_order_tags?: Maybe<Sales_Order_Tag_Mutation_Response>;
  /** update single row of the table: "sales_order_tag" */
  update_sales_order_tags_by_pk?: Maybe<Sales_Order_Tag>;
  /** update data of the table: "sales_order" */
  update_sales_orders?: Maybe<Sales_Order_Mutation_Response>;
  /** update single row of the table: "sales_order" */
  update_sales_orders_by_pk?: Maybe<Sales_Order>;
  /** update data of the table: "shipment_source" */
  update_shipment_source?: Maybe<Shipment_Source_Mutation_Response>;
  /** update single row of the table: "shipment_source" */
  update_shipment_source_by_pk?: Maybe<Shipment_Source>;
  /** update multiples rows of table: "shipment_source" */
  update_shipment_source_many?: Maybe<Array<Maybe<Shipment_Source_Mutation_Response>>>;
  /** update multiples rows of table: "shipment_status" */
  update_shipment_status_many?: Maybe<Array<Maybe<Shipment_Status_Mutation_Response>>>;
  /** update data of the table: "shipment_status" */
  update_shipment_statuses?: Maybe<Shipment_Status_Mutation_Response>;
  /** update single row of the table: "shipment_status" */
  update_shipment_statuses_by_pk?: Maybe<Shipment_Status>;
  /** update multiples rows of table: "shipping_area" */
  update_shipping_area_many?: Maybe<Array<Maybe<Shipping_Area_Mutation_Response>>>;
  /** update data of the table: "shipping_area" */
  update_shipping_areas?: Maybe<Shipping_Area_Mutation_Response>;
  /** update single row of the table: "shipping_area" */
  update_shipping_areas_by_pk?: Maybe<Shipping_Area>;
  /** update multiples rows of table: "shipping_margin" */
  update_shipping_margin_many?: Maybe<Array<Maybe<Shipping_Margin_Mutation_Response>>>;
  /** update data of the table: "shipping_margin_type" */
  update_shipping_margin_type?: Maybe<Shipping_Margin_Type_Mutation_Response>;
  /** update single row of the table: "shipping_margin_type" */
  update_shipping_margin_type_by_pk?: Maybe<Shipping_Margin_Type>;
  /** update multiples rows of table: "shipping_margin_type" */
  update_shipping_margin_type_many?: Maybe<Array<Maybe<Shipping_Margin_Type_Mutation_Response>>>;
  /** update data of the table: "shipping_margin" */
  update_shipping_margins?: Maybe<Shipping_Margin_Mutation_Response>;
  /** update single row of the table: "shipping_margin" */
  update_shipping_margins_by_pk?: Maybe<Shipping_Margin>;
  /** update data of the table: "shipping_provider" */
  update_shipping_provider?: Maybe<Shipping_Provider_Mutation_Response>;
  /** update single row of the table: "shipping_provider" */
  update_shipping_provider_by_pk?: Maybe<Shipping_Provider>;
  /** update multiples rows of table: "shipping_provider" */
  update_shipping_provider_many?: Maybe<Array<Maybe<Shipping_Provider_Mutation_Response>>>;
  /** update multiples rows of table: "shipping_rate" */
  update_shipping_rate_many?: Maybe<Array<Maybe<Shipping_Rate_Mutation_Response>>>;
  /** update data of the table: "shipping_rate" */
  update_shipping_rates?: Maybe<Shipping_Rate_Mutation_Response>;
  /** update single row of the table: "shipping_rate" */
  update_shipping_rates_by_pk?: Maybe<Shipping_Rate>;
  /** update multiples rows of table: "shopify.integration" */
  update_shopify_integration_many?: Maybe<Array<Maybe<Shopify_Integration_Mutation_Response>>>;
  /** update data of the table: "shopify.integration" */
  update_shopify_integrations?: Maybe<Shopify_Integration_Mutation_Response>;
  /** update single row of the table: "shopify.integration" */
  update_shopify_integrations_by_pk?: Maybe<Shopify_Integration>;
  /** update multiples rows of table: "shopify.order_archive" */
  update_shopify_order_archive_many?: Maybe<Array<Maybe<Shopify_Order_Archive_Mutation_Response>>>;
  /** update data of the table: "shopify.order_archive" */
  update_shopify_order_archives?: Maybe<Shopify_Order_Archive_Mutation_Response>;
  /** update single row of the table: "shopify.order_archive" */
  update_shopify_order_archives_by_pk?: Maybe<Shopify_Order_Archive>;
  /** update multiples rows of table: "stock_transfer_item" */
  update_stock_transfer_item_many?: Maybe<Array<Maybe<Stock_Transfer_Item_Mutation_Response>>>;
  /** update data of the table: "stock_transfer_item" */
  update_stock_transfer_items?: Maybe<Stock_Transfer_Item_Mutation_Response>;
  /** update single row of the table: "stock_transfer_item" */
  update_stock_transfer_items_by_pk?: Maybe<Stock_Transfer_Item>;
  /** update multiples rows of table: "stock_transfer" */
  update_stock_transfer_many?: Maybe<Array<Maybe<Stock_Transfer_Mutation_Response>>>;
  /** update multiples rows of table: "stock_transfer_parcel" */
  update_stock_transfer_parcel_many?: Maybe<Array<Maybe<Stock_Transfer_Parcel_Mutation_Response>>>;
  /** update data of the table: "stock_transfer_parcel" */
  update_stock_transfer_parcels?: Maybe<Stock_Transfer_Parcel_Mutation_Response>;
  /** update single row of the table: "stock_transfer_parcel" */
  update_stock_transfer_parcels_by_pk?: Maybe<Stock_Transfer_Parcel>;
  /** update multiples rows of table: "stock_transfer_shipment" */
  update_stock_transfer_shipment_many?: Maybe<Array<Maybe<Stock_Transfer_Shipment_Mutation_Response>>>;
  /** update data of the table: "stock_transfer_shipment" */
  update_stock_transfer_shipments?: Maybe<Stock_Transfer_Shipment_Mutation_Response>;
  /** update single row of the table: "stock_transfer_shipment" */
  update_stock_transfer_shipments_by_pk?: Maybe<Stock_Transfer_Shipment>;
  /** update data of the table: "stock_transfer_status" */
  update_stock_transfer_status?: Maybe<Stock_Transfer_Status_Mutation_Response>;
  /** update single row of the table: "stock_transfer_status" */
  update_stock_transfer_status_by_pk?: Maybe<Stock_Transfer_Status>;
  /** update multiples rows of table: "stock_transfer_status" */
  update_stock_transfer_status_many?: Maybe<Array<Maybe<Stock_Transfer_Status_Mutation_Response>>>;
  /** update data of the table: "stock_transfer" */
  update_stock_transfers?: Maybe<Stock_Transfer_Mutation_Response>;
  /** update single row of the table: "stock_transfer" */
  update_stock_transfers_by_pk?: Maybe<Stock_Transfer>;
  /** update data of the table: "store_feature_flag" */
  update_store_feature_flag?: Maybe<Store_Feature_Flag_Mutation_Response>;
  /** update single row of the table: "store_feature_flag" */
  update_store_feature_flag_by_pk?: Maybe<Store_Feature_Flag>;
  /** update multiples rows of table: "store_feature_flag" */
  update_store_feature_flag_many?: Maybe<Array<Maybe<Store_Feature_Flag_Mutation_Response>>>;
  /** update multiples rows of table: "store" */
  update_store_many?: Maybe<Array<Maybe<Store_Mutation_Response>>>;
  /** update data of the table: "store_setting" */
  update_store_setting?: Maybe<Store_Setting_Mutation_Response>;
  /** update single row of the table: "store_setting" */
  update_store_setting_by_pk?: Maybe<Store_Setting>;
  /** update data of the table: "store_setting_key" */
  update_store_setting_key?: Maybe<Store_Setting_Key_Mutation_Response>;
  /** update single row of the table: "store_setting_key" */
  update_store_setting_key_by_pk?: Maybe<Store_Setting_Key>;
  /** update multiples rows of table: "store_setting_key" */
  update_store_setting_key_many?: Maybe<Array<Maybe<Store_Setting_Key_Mutation_Response>>>;
  /** update multiples rows of table: "store_setting" */
  update_store_setting_many?: Maybe<Array<Maybe<Store_Setting_Mutation_Response>>>;
  /** update data of the table: "store_slug" */
  update_store_slug?: Maybe<Store_Slug_Mutation_Response>;
  /** update single row of the table: "store_slug" */
  update_store_slug_by_pk?: Maybe<Store_Slug>;
  /** update multiples rows of table: "store_slug" */
  update_store_slug_many?: Maybe<Array<Maybe<Store_Slug_Mutation_Response>>>;
  /** update data of the table: "store" */
  update_stores?: Maybe<Store_Mutation_Response>;
  /** update single row of the table: "store" */
  update_stores_by_pk?: Maybe<Store>;
  /** update multiples rows of table: "tag" */
  update_tag_many?: Maybe<Array<Maybe<Tag_Mutation_Response>>>;
  /** update data of the table: "tag" */
  update_tags?: Maybe<Tag_Mutation_Response>;
  /** update single row of the table: "tag" */
  update_tags_by_pk?: Maybe<Tag>;
  /** update multiples rows of table: "user_organization" */
  update_user_organization_many?: Maybe<Array<Maybe<User_Organization_Mutation_Response>>>;
  /** update data of the table: "user_organization" */
  update_user_organizations?: Maybe<User_Organization_Mutation_Response>;
  /** update single row of the table: "user_organization" */
  update_user_organizations_by_pk?: Maybe<User_Organization>;
  /** update data of the table: "users" */
  update_users?: Maybe<Users_Mutation_Response>;
  /** update single row of the table: "users" */
  update_users_by_pk?: Maybe<Users>;
  /** update multiples rows of table: "users" */
  update_users_many?: Maybe<Array<Maybe<Users_Mutation_Response>>>;
};


/** mutation root */
export type Mutation_RootAdd_Parcel_TypesArgs = {
  parcelTypes: Array<Maybe<AddParcelTypesInput>>;
};


/** mutation root */
export type Mutation_RootAdd_Shopify_StoreArgs = {
  shopDomain: Scalars['String'];
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCommand_Carrier_SettingArgs = {
  command: CarrierSettingCommand;
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCommand_Fulfilment_ShipmentArgs = {
  command: FulfilmentShipmentCommand;
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCommand_Fulfilment_ShipmentsArgs = {
  command: FulfilmentShipmentsCommand;
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCommand_Sales_OrderArgs = {
  command: SalesOrderCommand;
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCommand_Sales_OrdersArgs = {
  command: SalesOrdersCommand;
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCommand_Stock_TransferArgs = {
  command: StockTransferCommand;
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCommand_Test_OrderArgs = {
  command: TestOrderCommand;
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootConnect_Shopify_StoreArgs = {
  store: ConnectShopifyStoreInput;
};


/** mutation root */
export type Mutation_RootCreate_ManifestArgs = {
  fulfilment_shipment_ids: Array<Scalars['uuid']>;
  store_id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Address_TypesArgs = {
  where: Address_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Address_Types_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_AddressesArgs = {
  where: Address_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Addresses_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Auth_Account_ProvidersArgs = {
  where: Auth_Account_Providers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Auth_Account_Providers_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Auth_Account_RolesArgs = {
  where: Auth_Account_Roles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Auth_Account_Roles_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Auth_AccountsArgs = {
  where: Auth_Accounts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Auth_Accounts_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Auth_ProvidersArgs = {
  where: Auth_Providers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Auth_Providers_By_PkArgs = {
  provider: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Auth_Refresh_TokensArgs = {
  where: Auth_Refresh_Tokens_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Auth_Refresh_Tokens_By_PkArgs = {
  refresh_token: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Auth_RolesArgs = {
  where: Auth_Roles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Auth_Roles_By_PkArgs = {
  role: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Carrier_SelectionArgs = {
  where: Carrier_Selection_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Carrier_Selection_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_CarriersArgs = {
  where: Carrier_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Carriers_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_CustomersArgs = {
  where: Customer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Customers_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Draft_Fulfilment_ShipmentArgs = {
  where: Draft_Fulfilment_Shipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Event_Core_Event_StoreArgs = {
  where: Event_Core_Event_Store_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Event_Core_Event_Store_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Feature_FlagsArgs = {
  where: Feature_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Feature_Flags_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_Center_CarriersArgs = {
  where: Fulfilment_Center_Carrier_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_Center_Carriers_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_CentersArgs = {
  where: Fulfilment_Center_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_Centers_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_Shipment_Line_ItemsArgs = {
  where: Fulfilment_Shipment_Line_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_Shipment_Line_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_Shipment_ParcelsArgs = {
  where: Fulfilment_Shipment_Parcel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_Shipment_Parcels_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_ShipmentsArgs = {
  where: Fulfilment_Shipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fulfilment_Shipments_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Integration_SourceArgs = {
  where: Integration_Source_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Integration_Source_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_IntegrationsArgs = {
  where: Integration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Integrations_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Inventory_Item_QuantitiesArgs = {
  where: Inventory_Item_Quantity_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Inventory_Item_Quantities_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Inventory_ItemsArgs = {
  where: Inventory_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Inventory_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Inventory_Sync_Job_StatusArgs = {
  where: Inventory_Sync_Job_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Inventory_Sync_Job_Status_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Inventory_Sync_JobsArgs = {
  where: Inventory_Sync_Job_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Inventory_Sync_Jobs_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_LocationsArgs = {
  where: Location_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Locations_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ManifestsArgs = {
  where: Manifest_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Manifests_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_OrganizationsArgs = {
  where: Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Organizations_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Packing_StatusesArgs = {
  where: Packing_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Packing_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Parcel_TypesArgs = {
  where: Parcel_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Parcel_Types_By_IdsArgs = {
  parcelTypes: DeleteParcelTypesByIdsInput;
};


/** mutation root */
export type Mutation_RootDelete_Parcel_Types_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Payment_StatusesArgs = {
  where: Payment_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Payment_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Product_VariantsArgs = {
  where: Product_Variant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Product_Variants_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_ProductsArgs = {
  where: Product_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Products_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Rate_RequestsArgs = {
  where: Rate_Request_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rate_Requests_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Rate_Selected_ByArgs = {
  where: Rate_Selected_By_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rate_Selected_By_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Release_ChannelArgs = {
  where: Release_Channel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Release_Channel_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Retail_UnitsArgs = {
  where: Retail_Unit_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Retail_Units_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Sales_ChannelArgs = {
  where: Sales_Channel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Sales_Channel_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_IntegrationArgs = {
  where: Sales_Order_Integration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_Integration_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_Line_ItemsArgs = {
  where: Sales_Order_Line_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_Line_Items_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_Shipment_ChargesArgs = {
  where: Sales_Order_Shipment_Charge_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_Shipment_Charges_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_StatusesArgs = {
  where: Sales_Order_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_TagsArgs = {
  where: Sales_Order_Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Sales_Order_Tags_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Sales_OrdersArgs = {
  where: Sales_Order_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Sales_Orders_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Shipment_SourceArgs = {
  where: Shipment_Source_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shipment_Source_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Shipment_StatusesArgs = {
  where: Shipment_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shipment_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Shipping_AreasArgs = {
  where: Shipping_Area_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shipping_Areas_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Shipping_Margin_TypeArgs = {
  where: Shipping_Margin_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shipping_Margin_Type_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Shipping_MarginsArgs = {
  where: Shipping_Margin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shipping_Margins_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Shipping_ProviderArgs = {
  where: Shipping_Provider_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shipping_Provider_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Shipping_RatesArgs = {
  where: Shipping_Rate_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shipping_Rates_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Shopify_IntegrationsArgs = {
  where: Shopify_Integration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shopify_Integrations_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Shopify_Order_ArchivesArgs = {
  where: Shopify_Order_Archive_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shopify_Order_Archives_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Stock_Transfer_ItemsArgs = {
  where: Stock_Transfer_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Stock_Transfer_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Stock_Transfer_ParcelsArgs = {
  where: Stock_Transfer_Parcel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Stock_Transfer_Parcels_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Stock_Transfer_ShipmentsArgs = {
  where: Stock_Transfer_Shipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Stock_Transfer_Shipments_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Stock_Transfer_StatusArgs = {
  where: Stock_Transfer_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Stock_Transfer_Status_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Stock_TransfersArgs = {
  where: Stock_Transfer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Stock_Transfers_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Store_Feature_FlagArgs = {
  where: Store_Feature_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Store_Feature_Flag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Store_SettingArgs = {
  where: Store_Setting_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Store_Setting_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Store_Setting_KeyArgs = {
  where: Store_Setting_Key_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Store_Setting_Key_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Store_SlugArgs = {
  where: Store_Slug_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Store_Slug_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_StoresArgs = {
  where: Store_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Stores_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_TagsArgs = {
  where: Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tags_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_User_OrganizationsArgs = {
  where: User_Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Organizations_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_UsersArgs = {
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Users_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootEdit_AddressArgs = {
  fields: EditAddressInput;
  id: Scalars['uuid'];
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootEdit_Parcel_Types_By_PkArgs = {
  fields: EditParcelTypeInput;
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootEdit_Product_Variant_PackagesArgs = {
  product_variant_packages: Array<Maybe<EditProductVariantPackagesInput>>;
  store_id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootEdit_StoreArgs = {
  fields: EditStoreInput;
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootInitiate_Shopify_Inventory_SyncArgs = {
  shopifyIntegrationId: Scalars['uuid'];
  storeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootInsert_Address_TypesArgs = {
  objects: Array<Address_Type_Insert_Input>;
  on_conflict?: Maybe<Address_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Address_Types_OneArgs = {
  object: Address_Type_Insert_Input;
  on_conflict?: Maybe<Address_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AddressesArgs = {
  objects: Array<Address_Insert_Input>;
  on_conflict?: Maybe<Address_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Addresses_OneArgs = {
  object: Address_Insert_Input;
  on_conflict?: Maybe<Address_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Account_ProvidersArgs = {
  objects: Array<Auth_Account_Providers_Insert_Input>;
  on_conflict?: Maybe<Auth_Account_Providers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Account_Providers_OneArgs = {
  object: Auth_Account_Providers_Insert_Input;
  on_conflict?: Maybe<Auth_Account_Providers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Account_RolesArgs = {
  objects: Array<Auth_Account_Roles_Insert_Input>;
  on_conflict?: Maybe<Auth_Account_Roles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Account_Roles_OneArgs = {
  object: Auth_Account_Roles_Insert_Input;
  on_conflict?: Maybe<Auth_Account_Roles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_AccountsArgs = {
  objects: Array<Auth_Accounts_Insert_Input>;
  on_conflict?: Maybe<Auth_Accounts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Accounts_OneArgs = {
  object: Auth_Accounts_Insert_Input;
  on_conflict?: Maybe<Auth_Accounts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_ProvidersArgs = {
  objects: Array<Auth_Providers_Insert_Input>;
  on_conflict?: Maybe<Auth_Providers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Providers_OneArgs = {
  object: Auth_Providers_Insert_Input;
  on_conflict?: Maybe<Auth_Providers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Refresh_TokensArgs = {
  objects: Array<Auth_Refresh_Tokens_Insert_Input>;
  on_conflict?: Maybe<Auth_Refresh_Tokens_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Refresh_Tokens_OneArgs = {
  object: Auth_Refresh_Tokens_Insert_Input;
  on_conflict?: Maybe<Auth_Refresh_Tokens_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_RolesArgs = {
  objects: Array<Auth_Roles_Insert_Input>;
  on_conflict?: Maybe<Auth_Roles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Roles_OneArgs = {
  object: Auth_Roles_Insert_Input;
  on_conflict?: Maybe<Auth_Roles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Carrier_SelectionArgs = {
  objects: Array<Carrier_Selection_Insert_Input>;
  on_conflict?: Maybe<Carrier_Selection_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Carrier_Selection_OneArgs = {
  object: Carrier_Selection_Insert_Input;
  on_conflict?: Maybe<Carrier_Selection_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CarriersArgs = {
  objects: Array<Carrier_Insert_Input>;
  on_conflict?: Maybe<Carrier_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Carriers_OneArgs = {
  object: Carrier_Insert_Input;
  on_conflict?: Maybe<Carrier_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CustomersArgs = {
  objects: Array<Customer_Insert_Input>;
  on_conflict?: Maybe<Customer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Customers_OneArgs = {
  object: Customer_Insert_Input;
  on_conflict?: Maybe<Customer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Draft_Fulfilment_ShipmentArgs = {
  objects: Array<Draft_Fulfilment_Shipment_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Draft_Fulfilment_Shipment_OneArgs = {
  object: Draft_Fulfilment_Shipment_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Event_Core_Event_StoreArgs = {
  objects: Array<Event_Core_Event_Store_Insert_Input>;
  on_conflict?: Maybe<Event_Core_Event_Store_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Event_Core_Event_Store_OneArgs = {
  object: Event_Core_Event_Store_Insert_Input;
  on_conflict?: Maybe<Event_Core_Event_Store_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Feature_FlagsArgs = {
  objects: Array<Feature_Flag_Insert_Input>;
  on_conflict?: Maybe<Feature_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Feature_Flags_OneArgs = {
  object: Feature_Flag_Insert_Input;
  on_conflict?: Maybe<Feature_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_Center_CarriersArgs = {
  objects: Array<Fulfilment_Center_Carrier_Insert_Input>;
  on_conflict?: Maybe<Fulfilment_Center_Carrier_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_Center_Carriers_OneArgs = {
  object: Fulfilment_Center_Carrier_Insert_Input;
  on_conflict?: Maybe<Fulfilment_Center_Carrier_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_CentersArgs = {
  objects: Array<Fulfilment_Center_Insert_Input>;
  on_conflict?: Maybe<Fulfilment_Center_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_Centers_OneArgs = {
  object: Fulfilment_Center_Insert_Input;
  on_conflict?: Maybe<Fulfilment_Center_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_Shipment_Line_ItemsArgs = {
  objects: Array<Fulfilment_Shipment_Line_Item_Insert_Input>;
  on_conflict?: Maybe<Fulfilment_Shipment_Line_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_Shipment_Line_Items_OneArgs = {
  object: Fulfilment_Shipment_Line_Item_Insert_Input;
  on_conflict?: Maybe<Fulfilment_Shipment_Line_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_Shipment_ParcelsArgs = {
  objects: Array<Fulfilment_Shipment_Parcel_Insert_Input>;
  on_conflict?: Maybe<Fulfilment_Shipment_Parcel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_Shipment_Parcels_OneArgs = {
  object: Fulfilment_Shipment_Parcel_Insert_Input;
  on_conflict?: Maybe<Fulfilment_Shipment_Parcel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_ShipmentsArgs = {
  objects: Array<Fulfilment_Shipment_Insert_Input>;
  on_conflict?: Maybe<Fulfilment_Shipment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fulfilment_Shipments_OneArgs = {
  object: Fulfilment_Shipment_Insert_Input;
  on_conflict?: Maybe<Fulfilment_Shipment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Integration_SourceArgs = {
  objects: Array<Integration_Source_Insert_Input>;
  on_conflict?: Maybe<Integration_Source_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Integration_Source_OneArgs = {
  object: Integration_Source_Insert_Input;
  on_conflict?: Maybe<Integration_Source_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_IntegrationsArgs = {
  objects: Array<Integration_Insert_Input>;
  on_conflict?: Maybe<Integration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Integrations_OneArgs = {
  object: Integration_Insert_Input;
  on_conflict?: Maybe<Integration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inventory_Item_QuantitiesArgs = {
  objects: Array<Inventory_Item_Quantity_Insert_Input>;
  on_conflict?: Maybe<Inventory_Item_Quantity_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inventory_Item_Quantities_OneArgs = {
  object: Inventory_Item_Quantity_Insert_Input;
  on_conflict?: Maybe<Inventory_Item_Quantity_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inventory_ItemsArgs = {
  objects: Array<Inventory_Item_Insert_Input>;
  on_conflict?: Maybe<Inventory_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inventory_Items_OneArgs = {
  object: Inventory_Item_Insert_Input;
  on_conflict?: Maybe<Inventory_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inventory_Sync_Job_StatusArgs = {
  objects: Array<Inventory_Sync_Job_Status_Insert_Input>;
  on_conflict?: Maybe<Inventory_Sync_Job_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inventory_Sync_Job_Status_OneArgs = {
  object: Inventory_Sync_Job_Status_Insert_Input;
  on_conflict?: Maybe<Inventory_Sync_Job_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inventory_Sync_JobsArgs = {
  objects: Array<Inventory_Sync_Job_Insert_Input>;
  on_conflict?: Maybe<Inventory_Sync_Job_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Inventory_Sync_Jobs_OneArgs = {
  object: Inventory_Sync_Job_Insert_Input;
  on_conflict?: Maybe<Inventory_Sync_Job_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LocationsArgs = {
  objects: Array<Location_Insert_Input>;
  on_conflict?: Maybe<Location_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Locations_OneArgs = {
  object: Location_Insert_Input;
  on_conflict?: Maybe<Location_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ManifestsArgs = {
  objects: Array<Manifest_Insert_Input>;
  on_conflict?: Maybe<Manifest_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Manifests_By_PkArgs = {
  object: Manifest_Insert_Input;
  on_conflict?: Maybe<Manifest_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OrganizationsArgs = {
  objects: Array<Organization_Insert_Input>;
  on_conflict?: Maybe<Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organizations_OneArgs = {
  object: Organization_Insert_Input;
  on_conflict?: Maybe<Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Packing_StatusesArgs = {
  objects: Array<Packing_Status_Insert_Input>;
  on_conflict?: Maybe<Packing_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Packing_Statuses_OneArgs = {
  object: Packing_Status_Insert_Input;
  on_conflict?: Maybe<Packing_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Parcel_TypesArgs = {
  objects: Array<Parcel_Type_Insert_Input>;
  on_conflict?: Maybe<Parcel_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Parcel_Types_OneArgs = {
  object: Parcel_Type_Insert_Input;
  on_conflict?: Maybe<Parcel_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Payment_StatusesArgs = {
  objects: Array<Payment_Status_Insert_Input>;
  on_conflict?: Maybe<Payment_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Payment_Statuses_OneArgs = {
  object: Payment_Status_Insert_Input;
  on_conflict?: Maybe<Payment_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Product_VariantsArgs = {
  objects: Array<Product_Variant_Insert_Input>;
  on_conflict?: Maybe<Product_Variant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Product_Variants_OneArgs = {
  object: Product_Variant_Insert_Input;
  on_conflict?: Maybe<Product_Variant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ProductsArgs = {
  objects: Array<Product_Insert_Input>;
  on_conflict?: Maybe<Product_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Products_OneArgs = {
  object: Product_Insert_Input;
  on_conflict?: Maybe<Product_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rate_RequestsArgs = {
  objects: Array<Rate_Request_Insert_Input>;
  on_conflict?: Maybe<Rate_Request_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rate_Requests_OneArgs = {
  object: Rate_Request_Insert_Input;
  on_conflict?: Maybe<Rate_Request_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rate_Selected_ByArgs = {
  objects: Array<Rate_Selected_By_Insert_Input>;
  on_conflict?: Maybe<Rate_Selected_By_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rate_Selected_By_OneArgs = {
  object: Rate_Selected_By_Insert_Input;
  on_conflict?: Maybe<Rate_Selected_By_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Release_ChannelArgs = {
  objects: Array<Release_Channel_Insert_Input>;
  on_conflict?: Maybe<Release_Channel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Release_Channel_OneArgs = {
  object: Release_Channel_Insert_Input;
  on_conflict?: Maybe<Release_Channel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Retail_UnitsArgs = {
  objects: Array<Retail_Unit_Insert_Input>;
  on_conflict?: Maybe<Retail_Unit_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Retail_Units_OneArgs = {
  object: Retail_Unit_Insert_Input;
  on_conflict?: Maybe<Retail_Unit_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_ChannelArgs = {
  objects: Array<Sales_Channel_Insert_Input>;
  on_conflict?: Maybe<Sales_Channel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Channel_OneArgs = {
  object: Sales_Channel_Insert_Input;
  on_conflict?: Maybe<Sales_Channel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Order_IntegrationArgs = {
  objects: Array<Sales_Order_Integration_Insert_Input>;
  on_conflict?: Maybe<Sales_Order_Integration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Order_Integration_OneArgs = {
  object: Sales_Order_Integration_Insert_Input;
  on_conflict?: Maybe<Sales_Order_Integration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Order_Line_ItemsArgs = {
  objects: Array<Sales_Order_Line_Item_Insert_Input>;
  on_conflict?: Maybe<Sales_Order_Line_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Order_Line_Items_OneArgs = {
  object: Sales_Order_Line_Item_Insert_Input;
  on_conflict?: Maybe<Sales_Order_Line_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Order_Shipment_ChargesArgs = {
  objects: Array<Sales_Order_Shipment_Charge_Insert_Input>;
  on_conflict?: Maybe<Sales_Order_Shipment_Charge_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Order_StatusesArgs = {
  objects: Array<Sales_Order_Status_Insert_Input>;
  on_conflict?: Maybe<Sales_Order_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Order_Statuses_OneArgs = {
  object: Sales_Order_Status_Insert_Input;
  on_conflict?: Maybe<Sales_Order_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Order_TagsArgs = {
  objects: Array<Sales_Order_Tag_Insert_Input>;
  on_conflict?: Maybe<Sales_Order_Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Order_Tags_OneArgs = {
  object: Sales_Order_Tag_Insert_Input;
  on_conflict?: Maybe<Sales_Order_Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_OrdersArgs = {
  objects: Array<Sales_Order_Insert_Input>;
  on_conflict?: Maybe<Sales_Order_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sales_Orders_OneArgs = {
  object: Sales_Order_Insert_Input;
  on_conflict?: Maybe<Sales_Order_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipment_SourceArgs = {
  objects: Array<Shipment_Source_Insert_Input>;
  on_conflict?: Maybe<Shipment_Source_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipment_Source_OneArgs = {
  object: Shipment_Source_Insert_Input;
  on_conflict?: Maybe<Shipment_Source_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipment_StatusesArgs = {
  objects: Array<Shipment_Status_Insert_Input>;
  on_conflict?: Maybe<Shipment_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipment_Statuses_OneArgs = {
  object: Shipment_Status_Insert_Input;
  on_conflict?: Maybe<Shipment_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_AreasArgs = {
  objects: Array<Shipping_Area_Insert_Input>;
  on_conflict?: Maybe<Shipping_Area_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_Areas_OneArgs = {
  object: Shipping_Area_Insert_Input;
  on_conflict?: Maybe<Shipping_Area_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_Margin_TypeArgs = {
  objects: Array<Shipping_Margin_Type_Insert_Input>;
  on_conflict?: Maybe<Shipping_Margin_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_Margin_Type_OneArgs = {
  object: Shipping_Margin_Type_Insert_Input;
  on_conflict?: Maybe<Shipping_Margin_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_MarginsArgs = {
  objects: Array<Shipping_Margin_Insert_Input>;
  on_conflict?: Maybe<Shipping_Margin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_Margins_OneArgs = {
  object: Shipping_Margin_Insert_Input;
  on_conflict?: Maybe<Shipping_Margin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_ProviderArgs = {
  objects: Array<Shipping_Provider_Insert_Input>;
  on_conflict?: Maybe<Shipping_Provider_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_Provider_OneArgs = {
  object: Shipping_Provider_Insert_Input;
  on_conflict?: Maybe<Shipping_Provider_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_RatesArgs = {
  objects: Array<Shipping_Rate_Insert_Input>;
  on_conflict?: Maybe<Shipping_Rate_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_Rates_OneArgs = {
  object: Shipping_Rate_Insert_Input;
  on_conflict?: Maybe<Shipping_Rate_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shopify_IntegrationsArgs = {
  objects: Array<Shopify_Integration_Insert_Input>;
  on_conflict?: Maybe<Shopify_Integration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shopify_Integrations_OneArgs = {
  object: Shopify_Integration_Insert_Input;
  on_conflict?: Maybe<Shopify_Integration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shopify_Order_ArchivesArgs = {
  objects: Array<Shopify_Order_Archive_Insert_Input>;
  on_conflict?: Maybe<Shopify_Order_Archive_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shopify_Order_Archives_OneArgs = {
  object: Shopify_Order_Archive_Insert_Input;
  on_conflict?: Maybe<Shopify_Order_Archive_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_Transfer_ItemsArgs = {
  objects: Array<Stock_Transfer_Item_Insert_Input>;
  on_conflict?: Maybe<Stock_Transfer_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_Transfer_Items_OneArgs = {
  object: Stock_Transfer_Item_Insert_Input;
  on_conflict?: Maybe<Stock_Transfer_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_Transfer_ParcelsArgs = {
  objects: Array<Stock_Transfer_Parcel_Insert_Input>;
  on_conflict?: Maybe<Stock_Transfer_Parcel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_Transfer_Parcels_OneArgs = {
  object: Stock_Transfer_Parcel_Insert_Input;
  on_conflict?: Maybe<Stock_Transfer_Parcel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_Transfer_ShipmentsArgs = {
  objects: Array<Stock_Transfer_Shipment_Insert_Input>;
  on_conflict?: Maybe<Stock_Transfer_Shipment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_Transfer_Shipments_OneArgs = {
  object: Stock_Transfer_Shipment_Insert_Input;
  on_conflict?: Maybe<Stock_Transfer_Shipment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_Transfer_StatusArgs = {
  objects: Array<Stock_Transfer_Status_Insert_Input>;
  on_conflict?: Maybe<Stock_Transfer_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_Transfer_Status_OneArgs = {
  object: Stock_Transfer_Status_Insert_Input;
  on_conflict?: Maybe<Stock_Transfer_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_TransfersArgs = {
  objects: Array<Stock_Transfer_Insert_Input>;
  on_conflict?: Maybe<Stock_Transfer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stock_Transfers_OneArgs = {
  object: Stock_Transfer_Insert_Input;
  on_conflict?: Maybe<Stock_Transfer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Store_Feature_FlagArgs = {
  objects: Array<Store_Feature_Flag_Insert_Input>;
  on_conflict?: Maybe<Store_Feature_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Store_Feature_Flag_OneArgs = {
  object: Store_Feature_Flag_Insert_Input;
  on_conflict?: Maybe<Store_Feature_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Store_SettingArgs = {
  objects: Array<Store_Setting_Insert_Input>;
  on_conflict?: Maybe<Store_Setting_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Store_Setting_KeyArgs = {
  objects: Array<Store_Setting_Key_Insert_Input>;
  on_conflict?: Maybe<Store_Setting_Key_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Store_Setting_Key_OneArgs = {
  object: Store_Setting_Key_Insert_Input;
  on_conflict?: Maybe<Store_Setting_Key_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Store_Setting_OneArgs = {
  object: Store_Setting_Insert_Input;
  on_conflict?: Maybe<Store_Setting_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Store_SlugArgs = {
  objects: Array<Store_Slug_Insert_Input>;
  on_conflict?: Maybe<Store_Slug_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Store_Slug_OneArgs = {
  object: Store_Slug_Insert_Input;
  on_conflict?: Maybe<Store_Slug_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_StoresArgs = {
  objects: Array<Store_Insert_Input>;
  on_conflict?: Maybe<Store_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Stores_OneArgs = {
  object: Store_Insert_Input;
  on_conflict?: Maybe<Store_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TagsArgs = {
  objects: Array<Tag_Insert_Input>;
  on_conflict?: Maybe<Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tags_OneArgs = {
  object: Tag_Insert_Input;
  on_conflict?: Maybe<Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_OrganizationsArgs = {
  objects: Array<User_Organization_Insert_Input>;
  on_conflict?: Maybe<User_Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Organizations_OneArgs = {
  object: User_Organization_Insert_Input;
  on_conflict?: Maybe<User_Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict?: Maybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Users_OneArgs = {
  object: Users_Insert_Input;
  on_conflict?: Maybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootPack_Line_ItemsArgs = {
  lineItems: Array<Maybe<PackLineItemsInput>>;
  unpack?: Maybe<Scalars['Boolean']>;
};


/** mutation root */
export type Mutation_RootReplace_Fulfilment_Shipment_ParcelsArgs = {
  parcels: Array<FulfilmentShipmentParcelInput>;
};


/** mutation root */
export type Mutation_RootSales_Order_Shipment_Charges_OneArgs = {
  object: Sales_Order_Shipment_Charge_Insert_Input;
  on_conflict?: Maybe<Sales_Order_Shipment_Charge_On_Conflict>;
};


/** mutation root */
export type Mutation_RootSelect_Shipping_RateArgs = {
  fulfilmentShipmentId: Scalars['uuid'];
  shippingRateId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootShipengine_Tracking_HandlerArgs = {
  payload: Scalars['String'];
};


/** mutation root */
export type Mutation_RootShipping_Webhook_ShiptopiaArgs = {
  payload: ShippingWebhookShiptopiaInput;
};


/** mutation root */
export type Mutation_RootShopify_Webhook_HandlerArgs = {
  webhook: ShopifyWebhookHandlerInput;
};


/** mutation root */
export type Mutation_RootSync_ProductsArgs = {
  store_id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootSync_Sales_OrderArgs = {
  sales_order_id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootUpdate_Address_ManyArgs = {
  updates: Array<Address_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Address_Type_ManyArgs = {
  updates: Array<Address_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Address_TypesArgs = {
  _set?: Maybe<Address_Type_Set_Input>;
  where: Address_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Address_Types_By_PkArgs = {
  _set?: Maybe<Address_Type_Set_Input>;
  pk_columns: Address_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_AddressesArgs = {
  _inc?: Maybe<Address_Inc_Input>;
  _set?: Maybe<Address_Set_Input>;
  where: Address_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Addresses_By_PkArgs = {
  _inc?: Maybe<Address_Inc_Input>;
  _set?: Maybe<Address_Set_Input>;
  pk_columns: Address_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Account_ProvidersArgs = {
  _set?: Maybe<Auth_Account_Providers_Set_Input>;
  where: Auth_Account_Providers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Account_Providers_By_PkArgs = {
  _set?: Maybe<Auth_Account_Providers_Set_Input>;
  pk_columns: Auth_Account_Providers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Account_Providers_ManyArgs = {
  updates: Array<Auth_Account_Providers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Account_RolesArgs = {
  _set?: Maybe<Auth_Account_Roles_Set_Input>;
  where: Auth_Account_Roles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Account_Roles_By_PkArgs = {
  _set?: Maybe<Auth_Account_Roles_Set_Input>;
  pk_columns: Auth_Account_Roles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Account_Roles_ManyArgs = {
  updates: Array<Auth_Account_Roles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_AccountsArgs = {
  _append?: Maybe<Auth_Accounts_Append_Input>;
  _delete_at_path?: Maybe<Auth_Accounts_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Auth_Accounts_Delete_Elem_Input>;
  _delete_key?: Maybe<Auth_Accounts_Delete_Key_Input>;
  _prepend?: Maybe<Auth_Accounts_Prepend_Input>;
  _set?: Maybe<Auth_Accounts_Set_Input>;
  where: Auth_Accounts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Accounts_By_PkArgs = {
  _append?: Maybe<Auth_Accounts_Append_Input>;
  _delete_at_path?: Maybe<Auth_Accounts_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Auth_Accounts_Delete_Elem_Input>;
  _delete_key?: Maybe<Auth_Accounts_Delete_Key_Input>;
  _prepend?: Maybe<Auth_Accounts_Prepend_Input>;
  _set?: Maybe<Auth_Accounts_Set_Input>;
  pk_columns: Auth_Accounts_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Accounts_ManyArgs = {
  updates: Array<Auth_Accounts_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_ProvidersArgs = {
  _set?: Maybe<Auth_Providers_Set_Input>;
  where: Auth_Providers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Providers_By_PkArgs = {
  _set?: Maybe<Auth_Providers_Set_Input>;
  pk_columns: Auth_Providers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Providers_ManyArgs = {
  updates: Array<Auth_Providers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Refresh_TokensArgs = {
  _set?: Maybe<Auth_Refresh_Tokens_Set_Input>;
  where: Auth_Refresh_Tokens_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Refresh_Tokens_By_PkArgs = {
  _set?: Maybe<Auth_Refresh_Tokens_Set_Input>;
  pk_columns: Auth_Refresh_Tokens_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Refresh_Tokens_ManyArgs = {
  updates: Array<Auth_Refresh_Tokens_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_RolesArgs = {
  _set?: Maybe<Auth_Roles_Set_Input>;
  where: Auth_Roles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Roles_By_PkArgs = {
  _set?: Maybe<Auth_Roles_Set_Input>;
  pk_columns: Auth_Roles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Roles_ManyArgs = {
  updates: Array<Auth_Roles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Carrier_ManyArgs = {
  updates: Array<Carrier_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Carrier_SelectionArgs = {
  _set?: Maybe<Carrier_Selection_Set_Input>;
  where: Carrier_Selection_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Carrier_Selection_By_PkArgs = {
  _set?: Maybe<Carrier_Selection_Set_Input>;
  pk_columns: Carrier_Selection_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Carrier_Selection_ManyArgs = {
  updates: Array<Carrier_Selection_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CarriersArgs = {
  _append?: Maybe<Carrier_Append_Input>;
  _delete_at_path?: Maybe<Carrier_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Carrier_Delete_Elem_Input>;
  _delete_key?: Maybe<Carrier_Delete_Key_Input>;
  _prepend?: Maybe<Carrier_Prepend_Input>;
  _set?: Maybe<Carrier_Set_Input>;
  where: Carrier_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Carriers_By_PkArgs = {
  _append?: Maybe<Carrier_Append_Input>;
  _delete_at_path?: Maybe<Carrier_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Carrier_Delete_Elem_Input>;
  _delete_key?: Maybe<Carrier_Delete_Key_Input>;
  _prepend?: Maybe<Carrier_Prepend_Input>;
  _set?: Maybe<Carrier_Set_Input>;
  pk_columns: Carrier_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Customer_ManyArgs = {
  updates: Array<Customer_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CustomersArgs = {
  _append?: Maybe<Customer_Append_Input>;
  _delete_at_path?: Maybe<Customer_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Customer_Delete_Elem_Input>;
  _delete_key?: Maybe<Customer_Delete_Key_Input>;
  _prepend?: Maybe<Customer_Prepend_Input>;
  _set?: Maybe<Customer_Set_Input>;
  where: Customer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Customers_By_PkArgs = {
  _append?: Maybe<Customer_Append_Input>;
  _delete_at_path?: Maybe<Customer_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Customer_Delete_Elem_Input>;
  _delete_key?: Maybe<Customer_Delete_Key_Input>;
  _prepend?: Maybe<Customer_Prepend_Input>;
  _set?: Maybe<Customer_Set_Input>;
  pk_columns: Customer_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Draft_Fulfilment_ShipmentArgs = {
  _append?: Maybe<Draft_Fulfilment_Shipment_Append_Input>;
  _delete_at_path?: Maybe<Draft_Fulfilment_Shipment_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Draft_Fulfilment_Shipment_Delete_Elem_Input>;
  _delete_key?: Maybe<Draft_Fulfilment_Shipment_Delete_Key_Input>;
  _inc?: Maybe<Draft_Fulfilment_Shipment_Inc_Input>;
  _prepend?: Maybe<Draft_Fulfilment_Shipment_Prepend_Input>;
  _set?: Maybe<Draft_Fulfilment_Shipment_Set_Input>;
  where: Draft_Fulfilment_Shipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Draft_Fulfilment_Shipment_ManyArgs = {
  updates: Array<Draft_Fulfilment_Shipment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Event_Core_Event_StoreArgs = {
  _append?: Maybe<Event_Core_Event_Store_Append_Input>;
  _delete_at_path?: Maybe<Event_Core_Event_Store_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Event_Core_Event_Store_Delete_Elem_Input>;
  _delete_key?: Maybe<Event_Core_Event_Store_Delete_Key_Input>;
  _inc?: Maybe<Event_Core_Event_Store_Inc_Input>;
  _prepend?: Maybe<Event_Core_Event_Store_Prepend_Input>;
  _set?: Maybe<Event_Core_Event_Store_Set_Input>;
  where: Event_Core_Event_Store_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Event_Core_Event_Store_By_PkArgs = {
  _append?: Maybe<Event_Core_Event_Store_Append_Input>;
  _delete_at_path?: Maybe<Event_Core_Event_Store_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Event_Core_Event_Store_Delete_Elem_Input>;
  _delete_key?: Maybe<Event_Core_Event_Store_Delete_Key_Input>;
  _inc?: Maybe<Event_Core_Event_Store_Inc_Input>;
  _prepend?: Maybe<Event_Core_Event_Store_Prepend_Input>;
  _set?: Maybe<Event_Core_Event_Store_Set_Input>;
  pk_columns: Event_Core_Event_Store_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Event_Core_Event_Store_ManyArgs = {
  updates: Array<Event_Core_Event_Store_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Feature_Flag_ManyArgs = {
  updates: Array<Feature_Flag_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Feature_FlagsArgs = {
  _set?: Maybe<Feature_Flag_Set_Input>;
  where: Feature_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Feature_Flags_By_PkArgs = {
  _set?: Maybe<Feature_Flag_Set_Input>;
  pk_columns: Feature_Flag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Center_Carrier_ManyArgs = {
  updates: Array<Fulfilment_Center_Carrier_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Center_CarriersArgs = {
  _append?: Maybe<Fulfilment_Center_Carrier_Append_Input>;
  _delete_at_path?: Maybe<Fulfilment_Center_Carrier_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Fulfilment_Center_Carrier_Delete_Elem_Input>;
  _delete_key?: Maybe<Fulfilment_Center_Carrier_Delete_Key_Input>;
  _inc?: Maybe<Fulfilment_Center_Carrier_Inc_Input>;
  _prepend?: Maybe<Fulfilment_Center_Carrier_Prepend_Input>;
  _set?: Maybe<Fulfilment_Center_Carrier_Set_Input>;
  where: Fulfilment_Center_Carrier_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Center_Carriers_By_PkArgs = {
  _append?: Maybe<Fulfilment_Center_Carrier_Append_Input>;
  _delete_at_path?: Maybe<Fulfilment_Center_Carrier_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Fulfilment_Center_Carrier_Delete_Elem_Input>;
  _delete_key?: Maybe<Fulfilment_Center_Carrier_Delete_Key_Input>;
  _inc?: Maybe<Fulfilment_Center_Carrier_Inc_Input>;
  _prepend?: Maybe<Fulfilment_Center_Carrier_Prepend_Input>;
  _set?: Maybe<Fulfilment_Center_Carrier_Set_Input>;
  pk_columns: Fulfilment_Center_Carrier_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Center_ManyArgs = {
  updates: Array<Fulfilment_Center_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_CentersArgs = {
  _inc?: Maybe<Fulfilment_Center_Inc_Input>;
  _set?: Maybe<Fulfilment_Center_Set_Input>;
  where: Fulfilment_Center_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Centers_By_PkArgs = {
  _inc?: Maybe<Fulfilment_Center_Inc_Input>;
  _set?: Maybe<Fulfilment_Center_Set_Input>;
  pk_columns: Fulfilment_Center_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Shipment_Line_Item_ManyArgs = {
  updates: Array<Fulfilment_Shipment_Line_Item_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Shipment_Line_ItemsArgs = {
  _inc?: Maybe<Fulfilment_Shipment_Line_Item_Inc_Input>;
  _set?: Maybe<Fulfilment_Shipment_Line_Item_Set_Input>;
  where: Fulfilment_Shipment_Line_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Shipment_Line_Items_By_PkArgs = {
  _inc?: Maybe<Fulfilment_Shipment_Line_Item_Inc_Input>;
  _set?: Maybe<Fulfilment_Shipment_Line_Item_Set_Input>;
  pk_columns: Fulfilment_Shipment_Line_Item_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Shipment_ManyArgs = {
  updates: Array<Fulfilment_Shipment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Shipment_Parcel_ManyArgs = {
  updates: Array<Fulfilment_Shipment_Parcel_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Shipment_ParcelsArgs = {
  _inc?: Maybe<Fulfilment_Shipment_Parcel_Inc_Input>;
  _set?: Maybe<Fulfilment_Shipment_Parcel_Set_Input>;
  where: Fulfilment_Shipment_Parcel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Shipment_Parcels_By_PkArgs = {
  _inc?: Maybe<Fulfilment_Shipment_Parcel_Inc_Input>;
  _set?: Maybe<Fulfilment_Shipment_Parcel_Set_Input>;
  pk_columns: Fulfilment_Shipment_Parcel_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_ShipmentsArgs = {
  _append?: Maybe<Fulfilment_Shipment_Append_Input>;
  _delete_at_path?: Maybe<Fulfilment_Shipment_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Fulfilment_Shipment_Delete_Elem_Input>;
  _delete_key?: Maybe<Fulfilment_Shipment_Delete_Key_Input>;
  _inc?: Maybe<Fulfilment_Shipment_Inc_Input>;
  _prepend?: Maybe<Fulfilment_Shipment_Prepend_Input>;
  _set?: Maybe<Fulfilment_Shipment_Set_Input>;
  where: Fulfilment_Shipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fulfilment_Shipments_By_PkArgs = {
  _append?: Maybe<Fulfilment_Shipment_Append_Input>;
  _delete_at_path?: Maybe<Fulfilment_Shipment_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Fulfilment_Shipment_Delete_Elem_Input>;
  _delete_key?: Maybe<Fulfilment_Shipment_Delete_Key_Input>;
  _inc?: Maybe<Fulfilment_Shipment_Inc_Input>;
  _prepend?: Maybe<Fulfilment_Shipment_Prepend_Input>;
  _set?: Maybe<Fulfilment_Shipment_Set_Input>;
  pk_columns: Fulfilment_Shipment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Integration_ManyArgs = {
  updates: Array<Integration_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Integration_SourceArgs = {
  _set?: Maybe<Integration_Source_Set_Input>;
  where: Integration_Source_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Integration_Source_By_PkArgs = {
  _set?: Maybe<Integration_Source_Set_Input>;
  pk_columns: Integration_Source_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Integration_Source_ManyArgs = {
  updates: Array<Integration_Source_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_IntegrationsArgs = {
  _inc?: Maybe<Integration_Inc_Input>;
  _set?: Maybe<Integration_Set_Input>;
  where: Integration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Integrations_By_PkArgs = {
  _inc?: Maybe<Integration_Inc_Input>;
  _set?: Maybe<Integration_Set_Input>;
  pk_columns: Integration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Item_ManyArgs = {
  updates: Array<Inventory_Item_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Item_QuantitiesArgs = {
  _inc?: Maybe<Inventory_Item_Quantity_Inc_Input>;
  _set?: Maybe<Inventory_Item_Quantity_Set_Input>;
  where: Inventory_Item_Quantity_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Item_Quantities_By_PkArgs = {
  _inc?: Maybe<Inventory_Item_Quantity_Inc_Input>;
  _set?: Maybe<Inventory_Item_Quantity_Set_Input>;
  pk_columns: Inventory_Item_Quantity_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Item_Quantity_ManyArgs = {
  updates: Array<Inventory_Item_Quantity_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_ItemsArgs = {
  _inc?: Maybe<Inventory_Item_Inc_Input>;
  _set?: Maybe<Inventory_Item_Set_Input>;
  where: Inventory_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Items_By_PkArgs = {
  _inc?: Maybe<Inventory_Item_Inc_Input>;
  _set?: Maybe<Inventory_Item_Set_Input>;
  pk_columns: Inventory_Item_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Sync_Job_ManyArgs = {
  updates: Array<Inventory_Sync_Job_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Sync_Job_StatusArgs = {
  _set?: Maybe<Inventory_Sync_Job_Status_Set_Input>;
  where: Inventory_Sync_Job_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Sync_Job_Status_By_PkArgs = {
  _set?: Maybe<Inventory_Sync_Job_Status_Set_Input>;
  pk_columns: Inventory_Sync_Job_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Sync_Job_Status_ManyArgs = {
  updates: Array<Inventory_Sync_Job_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Sync_JobsArgs = {
  _append?: Maybe<Inventory_Sync_Job_Append_Input>;
  _delete_at_path?: Maybe<Inventory_Sync_Job_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Inventory_Sync_Job_Delete_Elem_Input>;
  _delete_key?: Maybe<Inventory_Sync_Job_Delete_Key_Input>;
  _inc?: Maybe<Inventory_Sync_Job_Inc_Input>;
  _prepend?: Maybe<Inventory_Sync_Job_Prepend_Input>;
  _set?: Maybe<Inventory_Sync_Job_Set_Input>;
  where: Inventory_Sync_Job_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Inventory_Sync_Jobs_By_PkArgs = {
  _append?: Maybe<Inventory_Sync_Job_Append_Input>;
  _delete_at_path?: Maybe<Inventory_Sync_Job_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Inventory_Sync_Job_Delete_Elem_Input>;
  _delete_key?: Maybe<Inventory_Sync_Job_Delete_Key_Input>;
  _inc?: Maybe<Inventory_Sync_Job_Inc_Input>;
  _prepend?: Maybe<Inventory_Sync_Job_Prepend_Input>;
  _set?: Maybe<Inventory_Sync_Job_Set_Input>;
  pk_columns: Inventory_Sync_Job_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Location_ManyArgs = {
  updates: Array<Location_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LocationsArgs = {
  _append?: Maybe<Location_Append_Input>;
  _delete_at_path?: Maybe<Location_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Location_Delete_Elem_Input>;
  _delete_key?: Maybe<Location_Delete_Key_Input>;
  _inc?: Maybe<Location_Inc_Input>;
  _prepend?: Maybe<Location_Prepend_Input>;
  _set?: Maybe<Location_Set_Input>;
  where: Location_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Locations_By_PkArgs = {
  _append?: Maybe<Location_Append_Input>;
  _delete_at_path?: Maybe<Location_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Location_Delete_Elem_Input>;
  _delete_key?: Maybe<Location_Delete_Key_Input>;
  _inc?: Maybe<Location_Inc_Input>;
  _prepend?: Maybe<Location_Prepend_Input>;
  _set?: Maybe<Location_Set_Input>;
  pk_columns: Location_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Manifest_ManyArgs = {
  updates: Array<Manifest_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ManifestsArgs = {
  _append?: Maybe<Manifest_Append_Input>;
  _delete_at_path?: Maybe<Manifest_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Manifest_Delete_Elem_Input>;
  _delete_key?: Maybe<Manifest_Delete_Key_Input>;
  _inc?: Maybe<Manifest_Inc_Input>;
  _prepend?: Maybe<Manifest_Prepend_Input>;
  _set?: Maybe<Manifest_Set_Input>;
  where: Manifest_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Manifests_By_PkArgs = {
  _append?: Maybe<Manifest_Append_Input>;
  _delete_at_path?: Maybe<Manifest_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Manifest_Delete_Elem_Input>;
  _delete_key?: Maybe<Manifest_Delete_Key_Input>;
  _inc?: Maybe<Manifest_Inc_Input>;
  _prepend?: Maybe<Manifest_Prepend_Input>;
  _set?: Maybe<Manifest_Set_Input>;
  pk_columns: Manifest_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_ManyArgs = {
  updates: Array<Organization_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_OrganizationsArgs = {
  _append?: Maybe<Organization_Append_Input>;
  _delete_at_path?: Maybe<Organization_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Organization_Delete_Elem_Input>;
  _delete_key?: Maybe<Organization_Delete_Key_Input>;
  _prepend?: Maybe<Organization_Prepend_Input>;
  _set?: Maybe<Organization_Set_Input>;
  where: Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Organizations_By_PkArgs = {
  _append?: Maybe<Organization_Append_Input>;
  _delete_at_path?: Maybe<Organization_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Organization_Delete_Elem_Input>;
  _delete_key?: Maybe<Organization_Delete_Key_Input>;
  _prepend?: Maybe<Organization_Prepend_Input>;
  _set?: Maybe<Organization_Set_Input>;
  pk_columns: Organization_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Packing_Status_ManyArgs = {
  updates: Array<Packing_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Packing_StatusesArgs = {
  _set?: Maybe<Packing_Status_Set_Input>;
  where: Packing_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Packing_Statuses_By_PkArgs = {
  _set?: Maybe<Packing_Status_Set_Input>;
  pk_columns: Packing_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Parcel_Type_ManyArgs = {
  updates: Array<Parcel_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Parcel_TypesArgs = {
  _inc?: Maybe<Parcel_Type_Inc_Input>;
  _set?: Maybe<Parcel_Type_Set_Input>;
  where: Parcel_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Parcel_Types_By_PkArgs = {
  _inc?: Maybe<Parcel_Type_Inc_Input>;
  _set?: Maybe<Parcel_Type_Set_Input>;
  pk_columns: Parcel_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Payment_Status_ManyArgs = {
  updates: Array<Payment_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Payment_StatusesArgs = {
  _set?: Maybe<Payment_Status_Set_Input>;
  where: Payment_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Payment_Statuses_By_PkArgs = {
  _set?: Maybe<Payment_Status_Set_Input>;
  pk_columns: Payment_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Product_ManyArgs = {
  updates: Array<Product_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Product_Variant_ManyArgs = {
  updates: Array<Product_Variant_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Product_VariantsArgs = {
  _append?: Maybe<Product_Variant_Append_Input>;
  _delete_at_path?: Maybe<Product_Variant_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Product_Variant_Delete_Elem_Input>;
  _delete_key?: Maybe<Product_Variant_Delete_Key_Input>;
  _inc?: Maybe<Product_Variant_Inc_Input>;
  _prepend?: Maybe<Product_Variant_Prepend_Input>;
  _set?: Maybe<Product_Variant_Set_Input>;
  where: Product_Variant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Product_Variants_By_PkArgs = {
  _append?: Maybe<Product_Variant_Append_Input>;
  _delete_at_path?: Maybe<Product_Variant_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Product_Variant_Delete_Elem_Input>;
  _delete_key?: Maybe<Product_Variant_Delete_Key_Input>;
  _inc?: Maybe<Product_Variant_Inc_Input>;
  _prepend?: Maybe<Product_Variant_Prepend_Input>;
  _set?: Maybe<Product_Variant_Set_Input>;
  pk_columns: Product_Variant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ProductsArgs = {
  _append?: Maybe<Product_Append_Input>;
  _delete_at_path?: Maybe<Product_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Product_Delete_Elem_Input>;
  _delete_key?: Maybe<Product_Delete_Key_Input>;
  _inc?: Maybe<Product_Inc_Input>;
  _prepend?: Maybe<Product_Prepend_Input>;
  _set?: Maybe<Product_Set_Input>;
  where: Product_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Products_By_PkArgs = {
  _append?: Maybe<Product_Append_Input>;
  _delete_at_path?: Maybe<Product_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Product_Delete_Elem_Input>;
  _delete_key?: Maybe<Product_Delete_Key_Input>;
  _inc?: Maybe<Product_Inc_Input>;
  _prepend?: Maybe<Product_Prepend_Input>;
  _set?: Maybe<Product_Set_Input>;
  pk_columns: Product_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rate_Request_ManyArgs = {
  updates: Array<Rate_Request_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rate_RequestsArgs = {
  _append?: Maybe<Rate_Request_Append_Input>;
  _delete_at_path?: Maybe<Rate_Request_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Rate_Request_Delete_Elem_Input>;
  _delete_key?: Maybe<Rate_Request_Delete_Key_Input>;
  _prepend?: Maybe<Rate_Request_Prepend_Input>;
  _set?: Maybe<Rate_Request_Set_Input>;
  where: Rate_Request_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rate_Requests_By_PkArgs = {
  _append?: Maybe<Rate_Request_Append_Input>;
  _delete_at_path?: Maybe<Rate_Request_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Rate_Request_Delete_Elem_Input>;
  _delete_key?: Maybe<Rate_Request_Delete_Key_Input>;
  _prepend?: Maybe<Rate_Request_Prepend_Input>;
  _set?: Maybe<Rate_Request_Set_Input>;
  pk_columns: Rate_Request_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rate_Selected_ByArgs = {
  _set?: Maybe<Rate_Selected_By_Set_Input>;
  where: Rate_Selected_By_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rate_Selected_By_By_PkArgs = {
  _set?: Maybe<Rate_Selected_By_Set_Input>;
  pk_columns: Rate_Selected_By_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rate_Selected_By_ManyArgs = {
  updates: Array<Rate_Selected_By_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Release_ChannelArgs = {
  _set?: Maybe<Release_Channel_Set_Input>;
  where: Release_Channel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Release_Channel_By_PkArgs = {
  _set?: Maybe<Release_Channel_Set_Input>;
  pk_columns: Release_Channel_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Release_Channel_ManyArgs = {
  updates: Array<Release_Channel_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Retail_Unit_ManyArgs = {
  updates: Array<Retail_Unit_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Retail_UnitsArgs = {
  _inc?: Maybe<Retail_Unit_Inc_Input>;
  _set?: Maybe<Retail_Unit_Set_Input>;
  where: Retail_Unit_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Retail_Units_By_PkArgs = {
  _inc?: Maybe<Retail_Unit_Inc_Input>;
  _set?: Maybe<Retail_Unit_Set_Input>;
  pk_columns: Retail_Unit_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_ChannelArgs = {
  _set?: Maybe<Sales_Channel_Set_Input>;
  where: Sales_Channel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Channel_By_PkArgs = {
  _set?: Maybe<Sales_Channel_Set_Input>;
  pk_columns: Sales_Channel_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Channel_ManyArgs = {
  updates: Array<Sales_Channel_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_IntegrationArgs = {
  _inc?: Maybe<Sales_Order_Integration_Inc_Input>;
  _set?: Maybe<Sales_Order_Integration_Set_Input>;
  where: Sales_Order_Integration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Integration_By_PkArgs = {
  _inc?: Maybe<Sales_Order_Integration_Inc_Input>;
  _set?: Maybe<Sales_Order_Integration_Set_Input>;
  pk_columns: Sales_Order_Integration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Integration_ManyArgs = {
  updates: Array<Sales_Order_Integration_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Line_Item_ManyArgs = {
  updates: Array<Sales_Order_Line_Item_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Line_ItemsArgs = {
  _append?: Maybe<Sales_Order_Line_Item_Append_Input>;
  _delete_at_path?: Maybe<Sales_Order_Line_Item_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Sales_Order_Line_Item_Delete_Elem_Input>;
  _delete_key?: Maybe<Sales_Order_Line_Item_Delete_Key_Input>;
  _inc?: Maybe<Sales_Order_Line_Item_Inc_Input>;
  _prepend?: Maybe<Sales_Order_Line_Item_Prepend_Input>;
  _set?: Maybe<Sales_Order_Line_Item_Set_Input>;
  where: Sales_Order_Line_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Line_Items_By_PkArgs = {
  _append?: Maybe<Sales_Order_Line_Item_Append_Input>;
  _delete_at_path?: Maybe<Sales_Order_Line_Item_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Sales_Order_Line_Item_Delete_Elem_Input>;
  _delete_key?: Maybe<Sales_Order_Line_Item_Delete_Key_Input>;
  _inc?: Maybe<Sales_Order_Line_Item_Inc_Input>;
  _prepend?: Maybe<Sales_Order_Line_Item_Prepend_Input>;
  _set?: Maybe<Sales_Order_Line_Item_Set_Input>;
  pk_columns: Sales_Order_Line_Item_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_ManyArgs = {
  updates: Array<Sales_Order_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Shipment_Charge_ManyArgs = {
  updates: Array<Sales_Order_Shipment_Charge_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Shipment_ChargesArgs = {
  _append?: Maybe<Sales_Order_Shipment_Charge_Append_Input>;
  _delete_at_path?: Maybe<Sales_Order_Shipment_Charge_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Sales_Order_Shipment_Charge_Delete_Elem_Input>;
  _delete_key?: Maybe<Sales_Order_Shipment_Charge_Delete_Key_Input>;
  _inc?: Maybe<Sales_Order_Shipment_Charge_Inc_Input>;
  _prepend?: Maybe<Sales_Order_Shipment_Charge_Prepend_Input>;
  _set?: Maybe<Sales_Order_Shipment_Charge_Set_Input>;
  where: Sales_Order_Shipment_Charge_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Shipment_Charges_By_PkArgs = {
  _append?: Maybe<Sales_Order_Shipment_Charge_Append_Input>;
  _delete_at_path?: Maybe<Sales_Order_Shipment_Charge_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Sales_Order_Shipment_Charge_Delete_Elem_Input>;
  _delete_key?: Maybe<Sales_Order_Shipment_Charge_Delete_Key_Input>;
  _inc?: Maybe<Sales_Order_Shipment_Charge_Inc_Input>;
  _prepend?: Maybe<Sales_Order_Shipment_Charge_Prepend_Input>;
  _set?: Maybe<Sales_Order_Shipment_Charge_Set_Input>;
  pk_columns: Sales_Order_Shipment_Charge_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Status_ManyArgs = {
  updates: Array<Sales_Order_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_StatusesArgs = {
  _set?: Maybe<Sales_Order_Status_Set_Input>;
  where: Sales_Order_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Statuses_By_PkArgs = {
  _set?: Maybe<Sales_Order_Status_Set_Input>;
  pk_columns: Sales_Order_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Tag_ManyArgs = {
  updates: Array<Sales_Order_Tag_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_TagsArgs = {
  _inc?: Maybe<Sales_Order_Tag_Inc_Input>;
  _set?: Maybe<Sales_Order_Tag_Set_Input>;
  where: Sales_Order_Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Order_Tags_By_PkArgs = {
  _inc?: Maybe<Sales_Order_Tag_Inc_Input>;
  _set?: Maybe<Sales_Order_Tag_Set_Input>;
  pk_columns: Sales_Order_Tag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_OrdersArgs = {
  _append?: Maybe<Sales_Order_Append_Input>;
  _delete_at_path?: Maybe<Sales_Order_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Sales_Order_Delete_Elem_Input>;
  _delete_key?: Maybe<Sales_Order_Delete_Key_Input>;
  _inc?: Maybe<Sales_Order_Inc_Input>;
  _prepend?: Maybe<Sales_Order_Prepend_Input>;
  _set?: Maybe<Sales_Order_Set_Input>;
  where: Sales_Order_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Sales_Orders_By_PkArgs = {
  _append?: Maybe<Sales_Order_Append_Input>;
  _delete_at_path?: Maybe<Sales_Order_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Sales_Order_Delete_Elem_Input>;
  _delete_key?: Maybe<Sales_Order_Delete_Key_Input>;
  _inc?: Maybe<Sales_Order_Inc_Input>;
  _prepend?: Maybe<Sales_Order_Prepend_Input>;
  _set?: Maybe<Sales_Order_Set_Input>;
  pk_columns: Sales_Order_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shipment_SourceArgs = {
  _set?: Maybe<Shipment_Source_Set_Input>;
  where: Shipment_Source_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shipment_Source_By_PkArgs = {
  _set?: Maybe<Shipment_Source_Set_Input>;
  pk_columns: Shipment_Source_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shipment_Source_ManyArgs = {
  updates: Array<Shipment_Source_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Shipment_Status_ManyArgs = {
  updates: Array<Shipment_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Shipment_StatusesArgs = {
  _set?: Maybe<Shipment_Status_Set_Input>;
  where: Shipment_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shipment_Statuses_By_PkArgs = {
  _set?: Maybe<Shipment_Status_Set_Input>;
  pk_columns: Shipment_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Area_ManyArgs = {
  updates: Array<Shipping_Area_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_AreasArgs = {
  _inc?: Maybe<Shipping_Area_Inc_Input>;
  _set?: Maybe<Shipping_Area_Set_Input>;
  where: Shipping_Area_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Areas_By_PkArgs = {
  _inc?: Maybe<Shipping_Area_Inc_Input>;
  _set?: Maybe<Shipping_Area_Set_Input>;
  pk_columns: Shipping_Area_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Margin_ManyArgs = {
  updates: Array<Shipping_Margin_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Margin_TypeArgs = {
  _set?: Maybe<Shipping_Margin_Type_Set_Input>;
  where: Shipping_Margin_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Margin_Type_By_PkArgs = {
  _set?: Maybe<Shipping_Margin_Type_Set_Input>;
  pk_columns: Shipping_Margin_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Margin_Type_ManyArgs = {
  updates: Array<Shipping_Margin_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_MarginsArgs = {
  _inc?: Maybe<Shipping_Margin_Inc_Input>;
  _set?: Maybe<Shipping_Margin_Set_Input>;
  where: Shipping_Margin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Margins_By_PkArgs = {
  _inc?: Maybe<Shipping_Margin_Inc_Input>;
  _set?: Maybe<Shipping_Margin_Set_Input>;
  pk_columns: Shipping_Margin_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_ProviderArgs = {
  _set?: Maybe<Shipping_Provider_Set_Input>;
  where: Shipping_Provider_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Provider_By_PkArgs = {
  _set?: Maybe<Shipping_Provider_Set_Input>;
  pk_columns: Shipping_Provider_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Provider_ManyArgs = {
  updates: Array<Shipping_Provider_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Rate_ManyArgs = {
  updates: Array<Shipping_Rate_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_RatesArgs = {
  _append?: Maybe<Shipping_Rate_Append_Input>;
  _delete_at_path?: Maybe<Shipping_Rate_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Shipping_Rate_Delete_Elem_Input>;
  _delete_key?: Maybe<Shipping_Rate_Delete_Key_Input>;
  _inc?: Maybe<Shipping_Rate_Inc_Input>;
  _prepend?: Maybe<Shipping_Rate_Prepend_Input>;
  _set?: Maybe<Shipping_Rate_Set_Input>;
  where: Shipping_Rate_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Rates_By_PkArgs = {
  _append?: Maybe<Shipping_Rate_Append_Input>;
  _delete_at_path?: Maybe<Shipping_Rate_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Shipping_Rate_Delete_Elem_Input>;
  _delete_key?: Maybe<Shipping_Rate_Delete_Key_Input>;
  _inc?: Maybe<Shipping_Rate_Inc_Input>;
  _prepend?: Maybe<Shipping_Rate_Prepend_Input>;
  _set?: Maybe<Shipping_Rate_Set_Input>;
  pk_columns: Shipping_Rate_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shopify_Integration_ManyArgs = {
  updates: Array<Shopify_Integration_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Shopify_IntegrationsArgs = {
  _append?: Maybe<Shopify_Integration_Append_Input>;
  _delete_at_path?: Maybe<Shopify_Integration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Shopify_Integration_Delete_Elem_Input>;
  _delete_key?: Maybe<Shopify_Integration_Delete_Key_Input>;
  _prepend?: Maybe<Shopify_Integration_Prepend_Input>;
  _set?: Maybe<Shopify_Integration_Set_Input>;
  where: Shopify_Integration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shopify_Integrations_By_PkArgs = {
  _append?: Maybe<Shopify_Integration_Append_Input>;
  _delete_at_path?: Maybe<Shopify_Integration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Shopify_Integration_Delete_Elem_Input>;
  _delete_key?: Maybe<Shopify_Integration_Delete_Key_Input>;
  _prepend?: Maybe<Shopify_Integration_Prepend_Input>;
  _set?: Maybe<Shopify_Integration_Set_Input>;
  pk_columns: Shopify_Integration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shopify_Order_Archive_ManyArgs = {
  updates: Array<Shopify_Order_Archive_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Shopify_Order_ArchivesArgs = {
  _append?: Maybe<Shopify_Order_Archive_Append_Input>;
  _delete_at_path?: Maybe<Shopify_Order_Archive_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Shopify_Order_Archive_Delete_Elem_Input>;
  _delete_key?: Maybe<Shopify_Order_Archive_Delete_Key_Input>;
  _prepend?: Maybe<Shopify_Order_Archive_Prepend_Input>;
  _set?: Maybe<Shopify_Order_Archive_Set_Input>;
  where: Shopify_Order_Archive_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shopify_Order_Archives_By_PkArgs = {
  _append?: Maybe<Shopify_Order_Archive_Append_Input>;
  _delete_at_path?: Maybe<Shopify_Order_Archive_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Shopify_Order_Archive_Delete_Elem_Input>;
  _delete_key?: Maybe<Shopify_Order_Archive_Delete_Key_Input>;
  _prepend?: Maybe<Shopify_Order_Archive_Prepend_Input>;
  _set?: Maybe<Shopify_Order_Archive_Set_Input>;
  pk_columns: Shopify_Order_Archive_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_Item_ManyArgs = {
  updates: Array<Stock_Transfer_Item_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_ItemsArgs = {
  _inc?: Maybe<Stock_Transfer_Item_Inc_Input>;
  _set?: Maybe<Stock_Transfer_Item_Set_Input>;
  where: Stock_Transfer_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_Items_By_PkArgs = {
  _inc?: Maybe<Stock_Transfer_Item_Inc_Input>;
  _set?: Maybe<Stock_Transfer_Item_Set_Input>;
  pk_columns: Stock_Transfer_Item_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_ManyArgs = {
  updates: Array<Stock_Transfer_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_Parcel_ManyArgs = {
  updates: Array<Stock_Transfer_Parcel_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_ParcelsArgs = {
  _inc?: Maybe<Stock_Transfer_Parcel_Inc_Input>;
  _set?: Maybe<Stock_Transfer_Parcel_Set_Input>;
  where: Stock_Transfer_Parcel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_Parcels_By_PkArgs = {
  _inc?: Maybe<Stock_Transfer_Parcel_Inc_Input>;
  _set?: Maybe<Stock_Transfer_Parcel_Set_Input>;
  pk_columns: Stock_Transfer_Parcel_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_Shipment_ManyArgs = {
  updates: Array<Stock_Transfer_Shipment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_ShipmentsArgs = {
  _inc?: Maybe<Stock_Transfer_Shipment_Inc_Input>;
  _set?: Maybe<Stock_Transfer_Shipment_Set_Input>;
  where: Stock_Transfer_Shipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_Shipments_By_PkArgs = {
  _inc?: Maybe<Stock_Transfer_Shipment_Inc_Input>;
  _set?: Maybe<Stock_Transfer_Shipment_Set_Input>;
  pk_columns: Stock_Transfer_Shipment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_StatusArgs = {
  _set?: Maybe<Stock_Transfer_Status_Set_Input>;
  where: Stock_Transfer_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_Status_By_PkArgs = {
  _set?: Maybe<Stock_Transfer_Status_Set_Input>;
  pk_columns: Stock_Transfer_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfer_Status_ManyArgs = {
  updates: Array<Stock_Transfer_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_TransfersArgs = {
  _inc?: Maybe<Stock_Transfer_Inc_Input>;
  _set?: Maybe<Stock_Transfer_Set_Input>;
  where: Stock_Transfer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Stock_Transfers_By_PkArgs = {
  _inc?: Maybe<Stock_Transfer_Inc_Input>;
  _set?: Maybe<Stock_Transfer_Set_Input>;
  pk_columns: Stock_Transfer_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Feature_FlagArgs = {
  _set?: Maybe<Store_Feature_Flag_Set_Input>;
  where: Store_Feature_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Feature_Flag_By_PkArgs = {
  _set?: Maybe<Store_Feature_Flag_Set_Input>;
  pk_columns: Store_Feature_Flag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Feature_Flag_ManyArgs = {
  updates: Array<Store_Feature_Flag_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Store_ManyArgs = {
  updates: Array<Store_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Store_SettingArgs = {
  _inc?: Maybe<Store_Setting_Inc_Input>;
  _set?: Maybe<Store_Setting_Set_Input>;
  where: Store_Setting_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Setting_By_PkArgs = {
  _inc?: Maybe<Store_Setting_Inc_Input>;
  _set?: Maybe<Store_Setting_Set_Input>;
  pk_columns: Store_Setting_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Setting_KeyArgs = {
  _set?: Maybe<Store_Setting_Key_Set_Input>;
  where: Store_Setting_Key_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Setting_Key_By_PkArgs = {
  _set?: Maybe<Store_Setting_Key_Set_Input>;
  pk_columns: Store_Setting_Key_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Setting_Key_ManyArgs = {
  updates: Array<Store_Setting_Key_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Setting_ManyArgs = {
  updates: Array<Store_Setting_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Store_SlugArgs = {
  _inc?: Maybe<Store_Slug_Inc_Input>;
  _set?: Maybe<Store_Slug_Set_Input>;
  where: Store_Slug_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Slug_By_PkArgs = {
  _inc?: Maybe<Store_Slug_Inc_Input>;
  _set?: Maybe<Store_Slug_Set_Input>;
  pk_columns: Store_Slug_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Store_Slug_ManyArgs = {
  updates: Array<Store_Slug_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_StoresArgs = {
  _append?: Maybe<Store_Append_Input>;
  _delete_at_path?: Maybe<Store_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Store_Delete_Elem_Input>;
  _delete_key?: Maybe<Store_Delete_Key_Input>;
  _prepend?: Maybe<Store_Prepend_Input>;
  _set?: Maybe<Store_Set_Input>;
  where: Store_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Stores_By_PkArgs = {
  _append?: Maybe<Store_Append_Input>;
  _delete_at_path?: Maybe<Store_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Store_Delete_Elem_Input>;
  _delete_key?: Maybe<Store_Delete_Key_Input>;
  _prepend?: Maybe<Store_Prepend_Input>;
  _set?: Maybe<Store_Set_Input>;
  pk_columns: Store_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tag_ManyArgs = {
  updates: Array<Tag_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TagsArgs = {
  _inc?: Maybe<Tag_Inc_Input>;
  _set?: Maybe<Tag_Set_Input>;
  where: Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tags_By_PkArgs = {
  _inc?: Maybe<Tag_Inc_Input>;
  _set?: Maybe<Tag_Set_Input>;
  pk_columns: Tag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Organization_ManyArgs = {
  updates: Array<User_Organization_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_OrganizationsArgs = {
  _set?: Maybe<User_Organization_Set_Input>;
  where: User_Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Organizations_By_PkArgs = {
  _set?: Maybe<User_Organization_Set_Input>;
  pk_columns: User_Organization_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_UsersArgs = {
  _set?: Maybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Users_By_PkArgs = {
  _set?: Maybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Users_ManyArgs = {
  updates: Array<Users_Updates>;
};


/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq?: Maybe<Scalars['numeric']>;
  _gt?: Maybe<Scalars['numeric']>;
  _gte?: Maybe<Scalars['numeric']>;
  _in?: Maybe<Array<Scalars['numeric']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['numeric']>;
  _lte?: Maybe<Scalars['numeric']>;
  _neq?: Maybe<Scalars['numeric']>;
  _nin?: Maybe<Array<Scalars['numeric']>>;
};

/** column ordering options */
export const Order_By = {
  /** in ascending order, nulls last */
  Asc: 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst: 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast: 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc: 'desc',
  /** in descending order, nulls first */
  DescNullsFirst: 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast: 'desc_nulls_last'
} as const;

export type Order_By = typeof Order_By[keyof typeof Order_By];
/** columns and relationships of "organization" */
export type Organization = {
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  is_fbs: Scalars['Boolean'];
  name: Scalars['String'];
  owner_user_id: Scalars['uuid'];
  /** An object relationship */
  owner_users: Users;
  pricing_model?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  stores: Array<Store>;
  /** An aggregate relationship */
  stores_aggregate: Store_Aggregate;
  updated_at: Scalars['timestamptz'];
  /** An array relationship */
  user_organizations: Array<User_Organization>;
  /** An aggregate relationship */
  user_organizations_aggregate: User_Organization_Aggregate;
};


/** columns and relationships of "organization" */
export type OrganizationPricing_ModelArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "organization" */
export type OrganizationStoresArgs = {
  distinct_on?: Maybe<Array<Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Order_By>>;
  where?: Maybe<Store_Bool_Exp>;
};


/** columns and relationships of "organization" */
export type OrganizationStores_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Order_By>>;
  where?: Maybe<Store_Bool_Exp>;
};


/** columns and relationships of "organization" */
export type OrganizationUser_OrganizationsArgs = {
  distinct_on?: Maybe<Array<User_Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Organization_Order_By>>;
  where?: Maybe<User_Organization_Bool_Exp>;
};


/** columns and relationships of "organization" */
export type OrganizationUser_Organizations_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Organization_Order_By>>;
  where?: Maybe<User_Organization_Bool_Exp>;
};

/** aggregated selection of "organization" */
export type Organization_Aggregate = {
  aggregate?: Maybe<Organization_Aggregate_Fields>;
  nodes: Array<Organization>;
};

export type Organization_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Organization_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Organization_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Organization_Aggregate_Bool_Exp_Count>;
};

export type Organization_Aggregate_Bool_Exp_Bool_And = {
  arguments: Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Organization_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Organization_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Organization_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Organization_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Organization_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Organization_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "organization" */
export type Organization_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Organization_Max_Fields>;
  min?: Maybe<Organization_Min_Fields>;
};


/** aggregate fields of "organization" */
export type Organization_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Organization_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "organization" */
export type Organization_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Organization_Max_Order_By>;
  min?: Maybe<Organization_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Organization_Append_Input = {
  pricing_model?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "organization" */
export type Organization_Arr_Rel_Insert_Input = {
  data: Array<Organization_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Organization_On_Conflict>;
};

/** Boolean expression to filter rows from the table "organization". All fields are combined with a logical 'AND'. */
export type Organization_Bool_Exp = {
  _and?: Maybe<Array<Organization_Bool_Exp>>;
  _not?: Maybe<Organization_Bool_Exp>;
  _or?: Maybe<Array<Organization_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_fbs?: Maybe<Boolean_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  owner_user_id?: Maybe<Uuid_Comparison_Exp>;
  owner_users?: Maybe<Users_Bool_Exp>;
  pricing_model?: Maybe<Jsonb_Comparison_Exp>;
  stores?: Maybe<Store_Bool_Exp>;
  stores_aggregate?: Maybe<Store_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_organizations?: Maybe<User_Organization_Bool_Exp>;
  user_organizations_aggregate?: Maybe<User_Organization_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "organization" */
export const Organization_Constraint = {
  /** unique or primary key constraint on columns "id" */
  OrganizationPkey: 'organization_pkey'
} as const;

export type Organization_Constraint = typeof Organization_Constraint[keyof typeof Organization_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Organization_Delete_At_Path_Input = {
  pricing_model?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Organization_Delete_Elem_Input = {
  pricing_model?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Organization_Delete_Key_Input = {
  pricing_model?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "organization" */
export type Organization_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_fbs?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  owner_user_id?: Maybe<Scalars['uuid']>;
  owner_users?: Maybe<Users_Obj_Rel_Insert_Input>;
  pricing_model?: Maybe<Scalars['jsonb']>;
  stores?: Maybe<Store_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_organizations?: Maybe<User_Organization_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Organization_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_user_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "organization" */
export type Organization_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  owner_user_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Organization_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_user_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "organization" */
export type Organization_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  owner_user_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "organization" */
export type Organization_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organization>;
};

/** input type for inserting object relation for remote table "organization" */
export type Organization_Obj_Rel_Insert_Input = {
  data: Organization_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Organization_On_Conflict>;
};

/** on_conflict condition type for table "organization" */
export type Organization_On_Conflict = {
  constraint: Organization_Constraint;
  update_columns?: Array<Organization_Update_Column>;
  where?: Maybe<Organization_Bool_Exp>;
};

/** Ordering options when selecting data from "organization". */
export type Organization_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_fbs?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  owner_user_id?: Maybe<Order_By>;
  owner_users?: Maybe<Users_Order_By>;
  pricing_model?: Maybe<Order_By>;
  stores_aggregate?: Maybe<Store_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  user_organizations_aggregate?: Maybe<User_Organization_Aggregate_Order_By>;
};

/** primary key columns input for table: organization */
export type Organization_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Organization_Prepend_Input = {
  pricing_model?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "organization" */
export const Organization_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  IsFbs: 'is_fbs',
  /** column name */
  Name: 'name',
  /** column name */
  OwnerUserId: 'owner_user_id',
  /** column name */
  PricingModel: 'pricing_model',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Organization_Select_Column = typeof Organization_Select_Column[keyof typeof Organization_Select_Column];
/** select "organization_aggregate_bool_exp_bool_and_arguments_columns" columns of table "organization" */
export const Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  IsFbs: 'is_fbs'
} as const;

export type Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "organization_aggregate_bool_exp_bool_or_arguments_columns" columns of table "organization" */
export const Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  IsFbs: 'is_fbs'
} as const;

export type Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Organization_Select_Column_Organization_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "organization" */
export type Organization_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_fbs?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  owner_user_id?: Maybe<Scalars['uuid']>;
  pricing_model?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "organization" */
export type Organization_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organization_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organization_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_fbs?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  owner_user_id?: Maybe<Scalars['uuid']>;
  pricing_model?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "organization" */
export const Organization_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  IsFbs: 'is_fbs',
  /** column name */
  Name: 'name',
  /** column name */
  OwnerUserId: 'owner_user_id',
  /** column name */
  PricingModel: 'pricing_model',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Organization_Update_Column = typeof Organization_Update_Column[keyof typeof Organization_Update_Column];
export type Organization_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Organization_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Organization_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Organization_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Organization_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Organization_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Organization_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organization_Bool_Exp;
};

/** columns and relationships of "packing_status" */
export type Packing_Status = {
  /** An array relationship */
  sales_order_line_items: Array<Sales_Order_Line_Item>;
  /** An aggregate relationship */
  sales_order_line_items_aggregate: Sales_Order_Line_Item_Aggregate;
  /** An array relationship */
  sales_orders: Array<Sales_Order>;
  /** An aggregate relationship */
  sales_orders_aggregate: Sales_Order_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "packing_status" */
export type Packing_StatusSales_Order_Line_ItemsArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Line_Item_Order_By>>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};


/** columns and relationships of "packing_status" */
export type Packing_StatusSales_Order_Line_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Line_Item_Order_By>>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};


/** columns and relationships of "packing_status" */
export type Packing_StatusSales_OrdersArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "packing_status" */
export type Packing_StatusSales_Orders_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};

/** aggregated selection of "packing_status" */
export type Packing_Status_Aggregate = {
  aggregate?: Maybe<Packing_Status_Aggregate_Fields>;
  nodes: Array<Packing_Status>;
};

/** aggregate fields of "packing_status" */
export type Packing_Status_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Packing_Status_Max_Fields>;
  min?: Maybe<Packing_Status_Min_Fields>;
};


/** aggregate fields of "packing_status" */
export type Packing_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Packing_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "packing_status". All fields are combined with a logical 'AND'. */
export type Packing_Status_Bool_Exp = {
  _and?: Maybe<Array<Packing_Status_Bool_Exp>>;
  _not?: Maybe<Packing_Status_Bool_Exp>;
  _or?: Maybe<Array<Packing_Status_Bool_Exp>>;
  sales_order_line_items?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
  sales_order_line_items_aggregate?: Maybe<Sales_Order_Line_Item_Aggregate_Bool_Exp>;
  sales_orders?: Maybe<Sales_Order_Bool_Exp>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "packing_status" */
export const Packing_Status_Constraint = {
  /** unique or primary key constraint on columns "value" */
  PackingStatusPkey: 'packing_status_pkey'
} as const;

export type Packing_Status_Constraint = typeof Packing_Status_Constraint[keyof typeof Packing_Status_Constraint];
export const Packing_Status_Enum = {
  Packed: 'PACKED',
  PartialPacked: 'PARTIAL_PACKED',
  Unpacked: 'UNPACKED'
} as const;

export type Packing_Status_Enum = typeof Packing_Status_Enum[keyof typeof Packing_Status_Enum];
/** Boolean expression to compare columns of type "packing_status_enum". All fields are combined with logical 'AND'. */
export type Packing_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Packing_Status_Enum>;
  _in?: Maybe<Array<Packing_Status_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Packing_Status_Enum>;
  _nin?: Maybe<Array<Packing_Status_Enum>>;
};

/** input type for inserting data into table "packing_status" */
export type Packing_Status_Insert_Input = {
  sales_order_line_items?: Maybe<Sales_Order_Line_Item_Arr_Rel_Insert_Input>;
  sales_orders?: Maybe<Sales_Order_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Packing_Status_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Packing_Status_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "packing_status" */
export type Packing_Status_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Packing_Status>;
};

/** input type for inserting object relation for remote table "packing_status" */
export type Packing_Status_Obj_Rel_Insert_Input = {
  data: Packing_Status_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Packing_Status_On_Conflict>;
};

/** on_conflict condition type for table "packing_status" */
export type Packing_Status_On_Conflict = {
  constraint: Packing_Status_Constraint;
  update_columns?: Array<Packing_Status_Update_Column>;
  where?: Maybe<Packing_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "packing_status". */
export type Packing_Status_Order_By = {
  sales_order_line_items_aggregate?: Maybe<Sales_Order_Line_Item_Aggregate_Order_By>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: packing_status */
export type Packing_Status_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "packing_status" */
export const Packing_Status_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Packing_Status_Select_Column = typeof Packing_Status_Select_Column[keyof typeof Packing_Status_Select_Column];
/** input type for updating data in table "packing_status" */
export type Packing_Status_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "packing_status" */
export type Packing_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Packing_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Packing_Status_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "packing_status" */
export const Packing_Status_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Packing_Status_Update_Column = typeof Packing_Status_Update_Column[keyof typeof Packing_Status_Update_Column];
export type Packing_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Packing_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Packing_Status_Bool_Exp;
};

/** columns and relationships of "parcel_type" */
export type Parcel_Type = {
  created_at: Scalars['timestamptz'];
  deleted_at?: Maybe<Scalars['timestamptz']>;
  empty_weight?: Maybe<Scalars['numeric']>;
  /** An array relationship */
  fulfilment_shipment_parcels: Array<Fulfilment_Shipment_Parcel>;
  /** An aggregate relationship */
  fulfilment_shipment_parcels_aggregate: Fulfilment_Shipment_Parcel_Aggregate;
  height: Scalars['numeric'];
  id: Scalars['uuid'];
  is_active: Scalars['Boolean'];
  is_default: Scalars['Boolean'];
  is_preset: Scalars['Boolean'];
  length: Scalars['numeric'];
  max_weight?: Maybe<Scalars['numeric']>;
  min_weight?: Maybe<Scalars['numeric']>;
  name: Scalars['String'];
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  /** An array relationship */
  transfer_parcels: Array<Stock_Transfer_Parcel>;
  /** An aggregate relationship */
  transfer_parcels_aggregate: Stock_Transfer_Parcel_Aggregate;
  type: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  width: Scalars['numeric'];
};


/** columns and relationships of "parcel_type" */
export type Parcel_TypeFulfilment_Shipment_ParcelsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


/** columns and relationships of "parcel_type" */
export type Parcel_TypeFulfilment_Shipment_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


/** columns and relationships of "parcel_type" */
export type Parcel_TypeTransfer_ParcelsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


/** columns and relationships of "parcel_type" */
export type Parcel_TypeTransfer_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};

/** aggregated selection of "parcel_type" */
export type Parcel_Type_Aggregate = {
  aggregate?: Maybe<Parcel_Type_Aggregate_Fields>;
  nodes: Array<Parcel_Type>;
};

export type Parcel_Type_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Parcel_Type_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Parcel_Type_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Parcel_Type_Aggregate_Bool_Exp_Count>;
};

export type Parcel_Type_Aggregate_Bool_Exp_Bool_And = {
  arguments: Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Parcel_Type_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Parcel_Type_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Parcel_Type_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Parcel_Type_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Parcel_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Parcel_Type_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "parcel_type" */
export type Parcel_Type_Aggregate_Fields = {
  avg?: Maybe<Parcel_Type_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Parcel_Type_Max_Fields>;
  min?: Maybe<Parcel_Type_Min_Fields>;
  stddev?: Maybe<Parcel_Type_Stddev_Fields>;
  stddev_pop?: Maybe<Parcel_Type_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Parcel_Type_Stddev_Samp_Fields>;
  sum?: Maybe<Parcel_Type_Sum_Fields>;
  var_pop?: Maybe<Parcel_Type_Var_Pop_Fields>;
  var_samp?: Maybe<Parcel_Type_Var_Samp_Fields>;
  variance?: Maybe<Parcel_Type_Variance_Fields>;
};


/** aggregate fields of "parcel_type" */
export type Parcel_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Parcel_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parcel_type" */
export type Parcel_Type_Aggregate_Order_By = {
  avg?: Maybe<Parcel_Type_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Parcel_Type_Max_Order_By>;
  min?: Maybe<Parcel_Type_Min_Order_By>;
  stddev?: Maybe<Parcel_Type_Stddev_Order_By>;
  stddev_pop?: Maybe<Parcel_Type_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Parcel_Type_Stddev_Samp_Order_By>;
  sum?: Maybe<Parcel_Type_Sum_Order_By>;
  var_pop?: Maybe<Parcel_Type_Var_Pop_Order_By>;
  var_samp?: Maybe<Parcel_Type_Var_Samp_Order_By>;
  variance?: Maybe<Parcel_Type_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "parcel_type" */
export type Parcel_Type_Arr_Rel_Insert_Input = {
  data: Array<Parcel_Type_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Parcel_Type_On_Conflict>;
};

/** aggregate avg on columns */
export type Parcel_Type_Avg_Fields = {
  empty_weight?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  max_weight?: Maybe<Scalars['Float']>;
  min_weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parcel_type" */
export type Parcel_Type_Avg_Order_By = {
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "parcel_type". All fields are combined with a logical 'AND'. */
export type Parcel_Type_Bool_Exp = {
  _and?: Maybe<Array<Parcel_Type_Bool_Exp>>;
  _not?: Maybe<Parcel_Type_Bool_Exp>;
  _or?: Maybe<Array<Parcel_Type_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  deleted_at?: Maybe<Timestamptz_Comparison_Exp>;
  empty_weight?: Maybe<Numeric_Comparison_Exp>;
  fulfilment_shipment_parcels?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
  fulfilment_shipment_parcels_aggregate?: Maybe<Fulfilment_Shipment_Parcel_Aggregate_Bool_Exp>;
  height?: Maybe<Numeric_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  is_default?: Maybe<Boolean_Comparison_Exp>;
  is_preset?: Maybe<Boolean_Comparison_Exp>;
  length?: Maybe<Numeric_Comparison_Exp>;
  max_weight?: Maybe<Numeric_Comparison_Exp>;
  min_weight?: Maybe<Numeric_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  transfer_parcels?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
  transfer_parcels_aggregate?: Maybe<Stock_Transfer_Parcel_Aggregate_Bool_Exp>;
  type?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  width?: Maybe<Numeric_Comparison_Exp>;
};

/** unique or primary key constraints on table "parcel_type" */
export const Parcel_Type_Constraint = {
  /** unique or primary key constraint on columns "id" */
  ParcelTypePkey: 'parcel_type_pkey',
  /** unique or primary key constraint on columns "store_id" */
  ParcelTypeStoreIdIsDefaultTrueKey: 'parcel_type_store_id_is_default_true_key'
} as const;

export type Parcel_Type_Constraint = typeof Parcel_Type_Constraint[keyof typeof Parcel_Type_Constraint];
/** input type for incrementing numeric columns in table "parcel_type" */
export type Parcel_Type_Inc_Input = {
  empty_weight?: Maybe<Scalars['numeric']>;
  height?: Maybe<Scalars['numeric']>;
  length?: Maybe<Scalars['numeric']>;
  max_weight?: Maybe<Scalars['numeric']>;
  min_weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "parcel_type" */
export type Parcel_Type_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  deleted_at?: Maybe<Scalars['timestamptz']>;
  empty_weight?: Maybe<Scalars['numeric']>;
  fulfilment_shipment_parcels?: Maybe<Fulfilment_Shipment_Parcel_Arr_Rel_Insert_Input>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_default?: Maybe<Scalars['Boolean']>;
  is_preset?: Maybe<Scalars['Boolean']>;
  length?: Maybe<Scalars['numeric']>;
  max_weight?: Maybe<Scalars['numeric']>;
  min_weight?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  transfer_parcels?: Maybe<Stock_Transfer_Parcel_Arr_Rel_Insert_Input>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type Parcel_Type_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  deleted_at?: Maybe<Scalars['timestamptz']>;
  empty_weight?: Maybe<Scalars['numeric']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['uuid']>;
  length?: Maybe<Scalars['numeric']>;
  max_weight?: Maybe<Scalars['numeric']>;
  min_weight?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  width?: Maybe<Scalars['numeric']>;
};

/** order by max() on columns of table "parcel_type" */
export type Parcel_Type_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  deleted_at?: Maybe<Order_By>;
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Parcel_Type_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  deleted_at?: Maybe<Scalars['timestamptz']>;
  empty_weight?: Maybe<Scalars['numeric']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['uuid']>;
  length?: Maybe<Scalars['numeric']>;
  max_weight?: Maybe<Scalars['numeric']>;
  min_weight?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  width?: Maybe<Scalars['numeric']>;
};

/** order by min() on columns of table "parcel_type" */
export type Parcel_Type_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  deleted_at?: Maybe<Order_By>;
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** response of any mutation on the table "parcel_type" */
export type Parcel_Type_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Parcel_Type>;
};

/** input type for inserting object relation for remote table "parcel_type" */
export type Parcel_Type_Obj_Rel_Insert_Input = {
  data: Parcel_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Parcel_Type_On_Conflict>;
};

/** on_conflict condition type for table "parcel_type" */
export type Parcel_Type_On_Conflict = {
  constraint: Parcel_Type_Constraint;
  update_columns?: Array<Parcel_Type_Update_Column>;
  where?: Maybe<Parcel_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "parcel_type". */
export type Parcel_Type_Order_By = {
  created_at?: Maybe<Order_By>;
  deleted_at?: Maybe<Order_By>;
  empty_weight?: Maybe<Order_By>;
  fulfilment_shipment_parcels_aggregate?: Maybe<Fulfilment_Shipment_Parcel_Aggregate_Order_By>;
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  is_default?: Maybe<Order_By>;
  is_preset?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  transfer_parcels_aggregate?: Maybe<Stock_Transfer_Parcel_Aggregate_Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** primary key columns input for table: parcel_type */
export type Parcel_Type_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "parcel_type" */
export const Parcel_Type_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DeletedAt: 'deleted_at',
  /** column name */
  EmptyWeight: 'empty_weight',
  /** column name */
  Height: 'height',
  /** column name */
  Id: 'id',
  /** column name */
  IsActive: 'is_active',
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  IsPreset: 'is_preset',
  /** column name */
  Length: 'length',
  /** column name */
  MaxWeight: 'max_weight',
  /** column name */
  MinWeight: 'min_weight',
  /** column name */
  Name: 'name',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Type: 'type',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  Width: 'width'
} as const;

export type Parcel_Type_Select_Column = typeof Parcel_Type_Select_Column[keyof typeof Parcel_Type_Select_Column];
/** select "parcel_type_aggregate_bool_exp_bool_and_arguments_columns" columns of table "parcel_type" */
export const Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  IsActive: 'is_active',
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  IsPreset: 'is_preset'
} as const;

export type Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "parcel_type_aggregate_bool_exp_bool_or_arguments_columns" columns of table "parcel_type" */
export const Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  IsActive: 'is_active',
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  IsPreset: 'is_preset'
} as const;

export type Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Parcel_Type_Select_Column_Parcel_Type_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "parcel_type" */
export type Parcel_Type_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  deleted_at?: Maybe<Scalars['timestamptz']>;
  empty_weight?: Maybe<Scalars['numeric']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_default?: Maybe<Scalars['Boolean']>;
  is_preset?: Maybe<Scalars['Boolean']>;
  length?: Maybe<Scalars['numeric']>;
  max_weight?: Maybe<Scalars['numeric']>;
  min_weight?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type Parcel_Type_Stddev_Fields = {
  empty_weight?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  max_weight?: Maybe<Scalars['Float']>;
  min_weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parcel_type" */
export type Parcel_Type_Stddev_Order_By = {
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Parcel_Type_Stddev_Pop_Fields = {
  empty_weight?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  max_weight?: Maybe<Scalars['Float']>;
  min_weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parcel_type" */
export type Parcel_Type_Stddev_Pop_Order_By = {
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Parcel_Type_Stddev_Samp_Fields = {
  empty_weight?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  max_weight?: Maybe<Scalars['Float']>;
  min_weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parcel_type" */
export type Parcel_Type_Stddev_Samp_Order_By = {
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** Streaming cursor of the table "parcel_type" */
export type Parcel_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Parcel_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Parcel_Type_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  deleted_at?: Maybe<Scalars['timestamptz']>;
  empty_weight?: Maybe<Scalars['numeric']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_default?: Maybe<Scalars['Boolean']>;
  is_preset?: Maybe<Scalars['Boolean']>;
  length?: Maybe<Scalars['numeric']>;
  max_weight?: Maybe<Scalars['numeric']>;
  min_weight?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type Parcel_Type_Sum_Fields = {
  empty_weight?: Maybe<Scalars['numeric']>;
  height?: Maybe<Scalars['numeric']>;
  length?: Maybe<Scalars['numeric']>;
  max_weight?: Maybe<Scalars['numeric']>;
  min_weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "parcel_type" */
export type Parcel_Type_Sum_Order_By = {
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** update columns of table "parcel_type" */
export const Parcel_Type_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DeletedAt: 'deleted_at',
  /** column name */
  EmptyWeight: 'empty_weight',
  /** column name */
  Height: 'height',
  /** column name */
  Id: 'id',
  /** column name */
  IsActive: 'is_active',
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  IsPreset: 'is_preset',
  /** column name */
  Length: 'length',
  /** column name */
  MaxWeight: 'max_weight',
  /** column name */
  MinWeight: 'min_weight',
  /** column name */
  Name: 'name',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Type: 'type',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  Width: 'width'
} as const;

export type Parcel_Type_Update_Column = typeof Parcel_Type_Update_Column[keyof typeof Parcel_Type_Update_Column];
export type Parcel_Type_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Parcel_Type_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Parcel_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Parcel_Type_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Parcel_Type_Var_Pop_Fields = {
  empty_weight?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  max_weight?: Maybe<Scalars['Float']>;
  min_weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parcel_type" */
export type Parcel_Type_Var_Pop_Order_By = {
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Parcel_Type_Var_Samp_Fields = {
  empty_weight?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  max_weight?: Maybe<Scalars['Float']>;
  min_weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parcel_type" */
export type Parcel_Type_Var_Samp_Order_By = {
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Parcel_Type_Variance_Fields = {
  empty_weight?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  max_weight?: Maybe<Scalars['Float']>;
  min_weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parcel_type" */
export type Parcel_Type_Variance_Order_By = {
  empty_weight?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  max_weight?: Maybe<Order_By>;
  min_weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** columns and relationships of "payment_status" */
export type Payment_Status = {
  /** An array relationship */
  sales_orders: Array<Sales_Order>;
  /** An aggregate relationship */
  sales_orders_aggregate: Sales_Order_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "payment_status" */
export type Payment_StatusSales_OrdersArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "payment_status" */
export type Payment_StatusSales_Orders_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};

/** aggregated selection of "payment_status" */
export type Payment_Status_Aggregate = {
  aggregate?: Maybe<Payment_Status_Aggregate_Fields>;
  nodes: Array<Payment_Status>;
};

/** aggregate fields of "payment_status" */
export type Payment_Status_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Payment_Status_Max_Fields>;
  min?: Maybe<Payment_Status_Min_Fields>;
};


/** aggregate fields of "payment_status" */
export type Payment_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Payment_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "payment_status". All fields are combined with a logical 'AND'. */
export type Payment_Status_Bool_Exp = {
  _and?: Maybe<Array<Payment_Status_Bool_Exp>>;
  _not?: Maybe<Payment_Status_Bool_Exp>;
  _or?: Maybe<Array<Payment_Status_Bool_Exp>>;
  sales_orders?: Maybe<Sales_Order_Bool_Exp>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "payment_status" */
export const Payment_Status_Constraint = {
  /** unique or primary key constraint on columns "value" */
  PaymentStatusPkey: 'payment_status_pkey'
} as const;

export type Payment_Status_Constraint = typeof Payment_Status_Constraint[keyof typeof Payment_Status_Constraint];
export const Payment_Status_Enum = {
  Paid: 'PAID',
  PartialPaid: 'PARTIAL_PAID',
  Refunded: 'REFUNDED',
  Unpaid: 'UNPAID'
} as const;

export type Payment_Status_Enum = typeof Payment_Status_Enum[keyof typeof Payment_Status_Enum];
/** Boolean expression to compare columns of type "payment_status_enum". All fields are combined with logical 'AND'. */
export type Payment_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Payment_Status_Enum>;
  _in?: Maybe<Array<Payment_Status_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Payment_Status_Enum>;
  _nin?: Maybe<Array<Payment_Status_Enum>>;
};

/** input type for inserting data into table "payment_status" */
export type Payment_Status_Insert_Input = {
  sales_orders?: Maybe<Sales_Order_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Payment_Status_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Payment_Status_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "payment_status" */
export type Payment_Status_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Payment_Status>;
};

/** input type for inserting object relation for remote table "payment_status" */
export type Payment_Status_Obj_Rel_Insert_Input = {
  data: Payment_Status_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Payment_Status_On_Conflict>;
};

/** on_conflict condition type for table "payment_status" */
export type Payment_Status_On_Conflict = {
  constraint: Payment_Status_Constraint;
  update_columns?: Array<Payment_Status_Update_Column>;
  where?: Maybe<Payment_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "payment_status". */
export type Payment_Status_Order_By = {
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: payment_status */
export type Payment_Status_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "payment_status" */
export const Payment_Status_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Payment_Status_Select_Column = typeof Payment_Status_Select_Column[keyof typeof Payment_Status_Select_Column];
/** input type for updating data in table "payment_status" */
export type Payment_Status_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "payment_status" */
export type Payment_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Payment_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Payment_Status_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "payment_status" */
export const Payment_Status_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Payment_Status_Update_Column = typeof Payment_Status_Update_Column[keyof typeof Payment_Status_Update_Column];
export type Payment_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Payment_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Payment_Status_Bool_Exp;
};

/** columns and relationships of "product" */
export type Product = {
  created_at: Scalars['timestamptz'];
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id: Scalars['bigint'];
  image_url?: Maybe<Scalars['String']>;
  /** An object relationship */
  integration?: Maybe<Integration>;
  integration_id?: Maybe<Scalars['bigint']>;
  /** An object relationship */
  integration_source?: Maybe<Integration_Source>;
  options?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  product_variants: Array<Product_Variant>;
  /** An aggregate relationship */
  product_variants_aggregate: Product_Variant_Aggregate;
  source?: Maybe<Integration_Source_Enum>;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  title: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "product" */
export type ProductOptionsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "product" */
export type ProductProduct_VariantsArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


/** columns and relationships of "product" */
export type ProductProduct_Variants_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};

/** aggregated selection of "product" */
export type Product_Aggregate = {
  aggregate?: Maybe<Product_Aggregate_Fields>;
  nodes: Array<Product>;
};

export type Product_Aggregate_Bool_Exp = {
  count?: Maybe<Product_Aggregate_Bool_Exp_Count>;
};

export type Product_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Product_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Product_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "product" */
export type Product_Aggregate_Fields = {
  avg?: Maybe<Product_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Product_Max_Fields>;
  min?: Maybe<Product_Min_Fields>;
  stddev?: Maybe<Product_Stddev_Fields>;
  stddev_pop?: Maybe<Product_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Product_Stddev_Samp_Fields>;
  sum?: Maybe<Product_Sum_Fields>;
  var_pop?: Maybe<Product_Var_Pop_Fields>;
  var_samp?: Maybe<Product_Var_Samp_Fields>;
  variance?: Maybe<Product_Variance_Fields>;
};


/** aggregate fields of "product" */
export type Product_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Product_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "product" */
export type Product_Aggregate_Order_By = {
  avg?: Maybe<Product_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Product_Max_Order_By>;
  min?: Maybe<Product_Min_Order_By>;
  stddev?: Maybe<Product_Stddev_Order_By>;
  stddev_pop?: Maybe<Product_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Product_Stddev_Samp_Order_By>;
  sum?: Maybe<Product_Sum_Order_By>;
  var_pop?: Maybe<Product_Var_Pop_Order_By>;
  var_samp?: Maybe<Product_Var_Samp_Order_By>;
  variance?: Maybe<Product_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Product_Append_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "product" */
export type Product_Arr_Rel_Insert_Input = {
  data: Array<Product_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Product_On_Conflict>;
};

/** aggregate avg on columns */
export type Product_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "product" */
export type Product_Avg_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "product". All fields are combined with a logical 'AND'. */
export type Product_Bool_Exp = {
  _and?: Maybe<Array<Product_Bool_Exp>>;
  _not?: Maybe<Product_Bool_Exp>;
  _or?: Maybe<Array<Product_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  external_entity_id?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  image_url?: Maybe<String_Comparison_Exp>;
  integration?: Maybe<Integration_Bool_Exp>;
  integration_id?: Maybe<Bigint_Comparison_Exp>;
  integration_source?: Maybe<Integration_Source_Bool_Exp>;
  options?: Maybe<Jsonb_Comparison_Exp>;
  product_variants?: Maybe<Product_Variant_Bool_Exp>;
  product_variants_aggregate?: Maybe<Product_Variant_Aggregate_Bool_Exp>;
  source?: Maybe<Integration_Source_Enum_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  title?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "product" */
export const Product_Constraint = {
  /** unique or primary key constraint on columns "external_entity_id", "integration_id" */
  ProductIntegrationIdExternalEntityId: 'product_integration_id_external_entity_id',
  /** unique or primary key constraint on columns "id" */
  ProductPk: 'product_pk'
} as const;

export type Product_Constraint = typeof Product_Constraint[keyof typeof Product_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Product_Delete_At_Path_Input = {
  options?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Product_Delete_Elem_Input = {
  options?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Product_Delete_Key_Input = {
  options?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "product" */
export type Product_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "product" */
export type Product_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration?: Maybe<Integration_Obj_Rel_Insert_Input>;
  integration_id?: Maybe<Scalars['bigint']>;
  integration_source?: Maybe<Integration_Source_Obj_Rel_Insert_Input>;
  options?: Maybe<Scalars['jsonb']>;
  product_variants?: Maybe<Product_Variant_Arr_Rel_Insert_Input>;
  source?: Maybe<Integration_Source_Enum>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Product_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "product" */
export type Product_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Product_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "product" */
export type Product_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "product" */
export type Product_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Product>;
};

/** input type for inserting object relation for remote table "product" */
export type Product_Obj_Rel_Insert_Input = {
  data: Product_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Product_On_Conflict>;
};

/** on_conflict condition type for table "product" */
export type Product_On_Conflict = {
  constraint: Product_Constraint;
  update_columns?: Array<Product_Update_Column>;
  where?: Maybe<Product_Bool_Exp>;
};

/** Ordering options when selecting data from "product". */
export type Product_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  integration?: Maybe<Integration_Order_By>;
  integration_id?: Maybe<Order_By>;
  integration_source?: Maybe<Integration_Source_Order_By>;
  options?: Maybe<Order_By>;
  product_variants_aggregate?: Maybe<Product_Variant_Aggregate_Order_By>;
  source?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: product */
export type Product_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Product_Prepend_Input = {
  options?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "product" */
export const Product_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Description: 'description',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  ImageUrl: 'image_url',
  /** column name */
  IntegrationId: 'integration_id',
  /** column name */
  Options: 'options',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Title: 'title',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Product_Select_Column = typeof Product_Select_Column[keyof typeof Product_Select_Column];
/** input type for updating data in table "product" */
export type Product_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration_id?: Maybe<Scalars['bigint']>;
  options?: Maybe<Scalars['jsonb']>;
  source?: Maybe<Integration_Source_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Product_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "product" */
export type Product_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Product_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "product" */
export type Product_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Product_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "product" */
export type Product_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "product" */
export type Product_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Product_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Product_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration_id?: Maybe<Scalars['bigint']>;
  options?: Maybe<Scalars['jsonb']>;
  source?: Maybe<Integration_Source_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Product_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "product" */
export type Product_Sum_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
};

/** update columns of table "product" */
export const Product_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Description: 'description',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  ImageUrl: 'image_url',
  /** column name */
  IntegrationId: 'integration_id',
  /** column name */
  Options: 'options',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Title: 'title',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Product_Update_Column = typeof Product_Update_Column[keyof typeof Product_Update_Column];
export type Product_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Product_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Product_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Product_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Product_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Product_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Product_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Product_Set_Input>;
  /** filter the rows which have to be updated */
  where: Product_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Product_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "product" */
export type Product_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Product_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "product" */
export type Product_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Product_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "product" */
export type Product_Variance_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
};

/** columns and relationships of "product_variant" */
export type Product_Variant = {
  created_at: Scalars['timestamptz'];
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id: Scalars['bigint'];
  image_url?: Maybe<Scalars['String']>;
  /** An object relationship */
  integration?: Maybe<Integration>;
  integration_id?: Maybe<Scalars['bigint']>;
  /** An object relationship */
  integration_source?: Maybe<Integration_Source>;
  option_values?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  product: Product;
  product_id: Scalars['bigint'];
  /** An array relationship */
  retail_units: Array<Retail_Unit>;
  /** An aggregate relationship */
  retail_units_aggregate: Retail_Unit_Aggregate;
  sku?: Maybe<Scalars['String']>;
  source?: Maybe<Integration_Source_Enum>;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  title?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  weight_gram: Scalars['Int'];
};


/** columns and relationships of "product_variant" */
export type Product_VariantOption_ValuesArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "product_variant" */
export type Product_VariantRetail_UnitsArgs = {
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


/** columns and relationships of "product_variant" */
export type Product_VariantRetail_Units_AggregateArgs = {
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};

/** aggregated selection of "product_variant" */
export type Product_Variant_Aggregate = {
  aggregate?: Maybe<Product_Variant_Aggregate_Fields>;
  nodes: Array<Product_Variant>;
};

export type Product_Variant_Aggregate_Bool_Exp = {
  count?: Maybe<Product_Variant_Aggregate_Bool_Exp_Count>;
};

export type Product_Variant_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Product_Variant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Product_Variant_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "product_variant" */
export type Product_Variant_Aggregate_Fields = {
  avg?: Maybe<Product_Variant_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Product_Variant_Max_Fields>;
  min?: Maybe<Product_Variant_Min_Fields>;
  stddev?: Maybe<Product_Variant_Stddev_Fields>;
  stddev_pop?: Maybe<Product_Variant_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Product_Variant_Stddev_Samp_Fields>;
  sum?: Maybe<Product_Variant_Sum_Fields>;
  var_pop?: Maybe<Product_Variant_Var_Pop_Fields>;
  var_samp?: Maybe<Product_Variant_Var_Samp_Fields>;
  variance?: Maybe<Product_Variant_Variance_Fields>;
};


/** aggregate fields of "product_variant" */
export type Product_Variant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Product_Variant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "product_variant" */
export type Product_Variant_Aggregate_Order_By = {
  avg?: Maybe<Product_Variant_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Product_Variant_Max_Order_By>;
  min?: Maybe<Product_Variant_Min_Order_By>;
  stddev?: Maybe<Product_Variant_Stddev_Order_By>;
  stddev_pop?: Maybe<Product_Variant_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Product_Variant_Stddev_Samp_Order_By>;
  sum?: Maybe<Product_Variant_Sum_Order_By>;
  var_pop?: Maybe<Product_Variant_Var_Pop_Order_By>;
  var_samp?: Maybe<Product_Variant_Var_Samp_Order_By>;
  variance?: Maybe<Product_Variant_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Product_Variant_Append_Input = {
  option_values?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "product_variant" */
export type Product_Variant_Arr_Rel_Insert_Input = {
  data: Array<Product_Variant_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Product_Variant_On_Conflict>;
};

/** aggregate avg on columns */
export type Product_Variant_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "product_variant" */
export type Product_Variant_Avg_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "product_variant". All fields are combined with a logical 'AND'. */
export type Product_Variant_Bool_Exp = {
  _and?: Maybe<Array<Product_Variant_Bool_Exp>>;
  _not?: Maybe<Product_Variant_Bool_Exp>;
  _or?: Maybe<Array<Product_Variant_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  external_entity_id?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  image_url?: Maybe<String_Comparison_Exp>;
  integration?: Maybe<Integration_Bool_Exp>;
  integration_id?: Maybe<Bigint_Comparison_Exp>;
  integration_source?: Maybe<Integration_Source_Bool_Exp>;
  option_values?: Maybe<Jsonb_Comparison_Exp>;
  product?: Maybe<Product_Bool_Exp>;
  product_id?: Maybe<Bigint_Comparison_Exp>;
  retail_units?: Maybe<Retail_Unit_Bool_Exp>;
  retail_units_aggregate?: Maybe<Retail_Unit_Aggregate_Bool_Exp>;
  sku?: Maybe<String_Comparison_Exp>;
  source?: Maybe<Integration_Source_Enum_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  title?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  weight_gram?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "product_variant" */
export const Product_Variant_Constraint = {
  /** unique or primary key constraint on columns "external_entity_id", "integration_id" */
  ProductVariantIntegrationIdExternalEntityId: 'product_variant_integration_id_external_entity_id',
  /** unique or primary key constraint on columns "id" */
  ProductVariantPk: 'product_variant_pk'
} as const;

export type Product_Variant_Constraint = typeof Product_Variant_Constraint[keyof typeof Product_Variant_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Product_Variant_Delete_At_Path_Input = {
  option_values?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Product_Variant_Delete_Elem_Input = {
  option_values?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Product_Variant_Delete_Key_Input = {
  option_values?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "product_variant" */
export type Product_Variant_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  product_id?: Maybe<Scalars['bigint']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "product_variant" */
export type Product_Variant_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration?: Maybe<Integration_Obj_Rel_Insert_Input>;
  integration_id?: Maybe<Scalars['bigint']>;
  integration_source?: Maybe<Integration_Source_Obj_Rel_Insert_Input>;
  option_values?: Maybe<Scalars['jsonb']>;
  product?: Maybe<Product_Obj_Rel_Insert_Input>;
  product_id?: Maybe<Scalars['bigint']>;
  retail_units?: Maybe<Retail_Unit_Arr_Rel_Insert_Input>;
  sku?: Maybe<Scalars['String']>;
  source?: Maybe<Integration_Source_Enum>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Product_Variant_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration_id?: Maybe<Scalars['bigint']>;
  product_id?: Maybe<Scalars['bigint']>;
  sku?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "product_variant" */
export type Product_Variant_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  sku?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Product_Variant_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration_id?: Maybe<Scalars['bigint']>;
  product_id?: Maybe<Scalars['bigint']>;
  sku?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "product_variant" */
export type Product_Variant_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  sku?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** response of any mutation on the table "product_variant" */
export type Product_Variant_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Product_Variant>;
};

/** input type for inserting object relation for remote table "product_variant" */
export type Product_Variant_Obj_Rel_Insert_Input = {
  data: Product_Variant_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Product_Variant_On_Conflict>;
};

/** on_conflict condition type for table "product_variant" */
export type Product_Variant_On_Conflict = {
  constraint: Product_Variant_Constraint;
  update_columns?: Array<Product_Variant_Update_Column>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};

/** Ordering options when selecting data from "product_variant". */
export type Product_Variant_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  integration?: Maybe<Integration_Order_By>;
  integration_id?: Maybe<Order_By>;
  integration_source?: Maybe<Integration_Source_Order_By>;
  option_values?: Maybe<Order_By>;
  product?: Maybe<Product_Order_By>;
  product_id?: Maybe<Order_By>;
  retail_units_aggregate?: Maybe<Retail_Unit_Aggregate_Order_By>;
  sku?: Maybe<Order_By>;
  source?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** primary key columns input for table: product_variant */
export type Product_Variant_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Product_Variant_Prepend_Input = {
  option_values?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "product_variant" */
export const Product_Variant_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Description: 'description',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  ImageUrl: 'image_url',
  /** column name */
  IntegrationId: 'integration_id',
  /** column name */
  OptionValues: 'option_values',
  /** column name */
  ProductId: 'product_id',
  /** column name */
  Sku: 'sku',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Title: 'title',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  WeightGram: 'weight_gram'
} as const;

export type Product_Variant_Select_Column = typeof Product_Variant_Select_Column[keyof typeof Product_Variant_Select_Column];
/** input type for updating data in table "product_variant" */
export type Product_Variant_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration_id?: Maybe<Scalars['bigint']>;
  option_values?: Maybe<Scalars['jsonb']>;
  product_id?: Maybe<Scalars['bigint']>;
  sku?: Maybe<Scalars['String']>;
  source?: Maybe<Integration_Source_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Product_Variant_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "product_variant" */
export type Product_Variant_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Product_Variant_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "product_variant" */
export type Product_Variant_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Product_Variant_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "product_variant" */
export type Product_Variant_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** Streaming cursor of the table "product_variant" */
export type Product_Variant_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Product_Variant_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Product_Variant_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  integration_id?: Maybe<Scalars['bigint']>;
  option_values?: Maybe<Scalars['jsonb']>;
  product_id?: Maybe<Scalars['bigint']>;
  sku?: Maybe<Scalars['String']>;
  source?: Maybe<Integration_Source_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Product_Variant_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  product_id?: Maybe<Scalars['bigint']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "product_variant" */
export type Product_Variant_Sum_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** update columns of table "product_variant" */
export const Product_Variant_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Description: 'description',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  ImageUrl: 'image_url',
  /** column name */
  IntegrationId: 'integration_id',
  /** column name */
  OptionValues: 'option_values',
  /** column name */
  ProductId: 'product_id',
  /** column name */
  Sku: 'sku',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Title: 'title',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  WeightGram: 'weight_gram'
} as const;

export type Product_Variant_Update_Column = typeof Product_Variant_Update_Column[keyof typeof Product_Variant_Update_Column];
export type Product_Variant_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Product_Variant_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Product_Variant_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Product_Variant_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Product_Variant_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Product_Variant_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Product_Variant_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Product_Variant_Set_Input>;
  /** filter the rows which have to be updated */
  where: Product_Variant_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Product_Variant_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "product_variant" */
export type Product_Variant_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Product_Variant_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "product_variant" */
export type Product_Variant_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Product_Variant_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "product_variant" */
export type Product_Variant_Variance_Order_By = {
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  product_id?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

export type Query_Root = {
  /** fetch aggregated fields from the table: "payment_status" */
  address_payment_statuses_aggregate: Payment_Status_Aggregate;
  /** fetch data from the table: "address_type" */
  address_types: Array<Address_Type>;
  /** fetch aggregated fields from the table: "address_type" */
  address_types_aggregate: Address_Type_Aggregate;
  /** fetch data from the table: "address_type" using primary key columns */
  address_types_by_pk?: Maybe<Address_Type>;
  /** An array relationship */
  addresses: Array<Address>;
  /** An aggregate relationship */
  addresses_aggregate: Address_Aggregate;
  /** fetch data from the table: "address" using primary key columns */
  addresses_by_pk?: Maybe<Address>;
  /** fetch data from the table: "auth.account_providers" */
  auth_account_providers: Array<Auth_Account_Providers>;
  /** fetch aggregated fields from the table: "auth.account_providers" */
  auth_account_providers_aggregate: Auth_Account_Providers_Aggregate;
  /** fetch data from the table: "auth.account_providers" using primary key columns */
  auth_account_providers_by_pk?: Maybe<Auth_Account_Providers>;
  /** fetch data from the table: "auth.account_roles" */
  auth_account_roles: Array<Auth_Account_Roles>;
  /** fetch aggregated fields from the table: "auth.account_roles" */
  auth_account_roles_aggregate: Auth_Account_Roles_Aggregate;
  /** fetch data from the table: "auth.account_roles" using primary key columns */
  auth_account_roles_by_pk?: Maybe<Auth_Account_Roles>;
  /** fetch data from the table: "auth.accounts" */
  auth_accounts: Array<Auth_Accounts>;
  /** fetch aggregated fields from the table: "auth.accounts" */
  auth_accounts_aggregate: Auth_Accounts_Aggregate;
  /** fetch data from the table: "auth.accounts" using primary key columns */
  auth_accounts_by_pk?: Maybe<Auth_Accounts>;
  /** fetch data from the table: "auth.providers" */
  auth_providers: Array<Auth_Providers>;
  /** fetch aggregated fields from the table: "auth.providers" */
  auth_providers_aggregate: Auth_Providers_Aggregate;
  /** fetch data from the table: "auth.providers" using primary key columns */
  auth_providers_by_pk?: Maybe<Auth_Providers>;
  /** fetch data from the table: "auth.refresh_tokens" */
  auth_refresh_tokens: Array<Auth_Refresh_Tokens>;
  /** fetch aggregated fields from the table: "auth.refresh_tokens" */
  auth_refresh_tokens_aggregate: Auth_Refresh_Tokens_Aggregate;
  /** fetch data from the table: "auth.refresh_tokens" using primary key columns */
  auth_refresh_tokens_by_pk?: Maybe<Auth_Refresh_Tokens>;
  /** fetch data from the table: "auth.roles" */
  auth_roles: Array<Auth_Roles>;
  /** fetch aggregated fields from the table: "auth.roles" */
  auth_roles_aggregate: Auth_Roles_Aggregate;
  /** fetch data from the table: "auth.roles" using primary key columns */
  auth_roles_by_pk?: Maybe<Auth_Roles>;
  /** fetch data from the table: "carrier_selection" */
  carrier_selection: Array<Carrier_Selection>;
  /** fetch aggregated fields from the table: "carrier_selection" */
  carrier_selection_aggregate: Carrier_Selection_Aggregate;
  /** fetch data from the table: "carrier_selection" using primary key columns */
  carrier_selection_by_pk?: Maybe<Carrier_Selection>;
  /** An array relationship */
  carriers: Array<Carrier>;
  /** An aggregate relationship */
  carriers_aggregate: Carrier_Aggregate;
  /** fetch data from the table: "carrier" using primary key columns */
  carriers_by_pk?: Maybe<Carrier>;
  /** An array relationship */
  customers: Array<Customer>;
  /** An aggregate relationship */
  customers_aggregate: Customer_Aggregate;
  /** fetch data from the table: "customer" using primary key columns */
  customers_by_pk?: Maybe<Customer>;
  /** fetch data from the table: "draft_fulfilment_shipment" */
  draft_fulfilment_shipment: Array<Draft_Fulfilment_Shipment>;
  /** fetch aggregated fields from the table: "draft_fulfilment_shipment" */
  draft_fulfilment_shipment_aggregate: Draft_Fulfilment_Shipment_Aggregate;
  /** fetch data from the table: "event_core.event_store" */
  event_core_event_store: Array<Event_Core_Event_Store>;
  /** fetch aggregated fields from the table: "event_core.event_store" */
  event_core_event_store_aggregate: Event_Core_Event_Store_Aggregate;
  /** fetch data from the table: "event_core.event_store" using primary key columns */
  event_core_event_store_by_pk?: Maybe<Event_Core_Event_Store>;
  /** fetch data from the table: "feature_flag" */
  feature_flags: Array<Feature_Flag>;
  /** fetch aggregated fields from the table: "feature_flag" */
  feature_flags_aggregate: Feature_Flag_Aggregate;
  /** fetch data from the table: "feature_flag" using primary key columns */
  feature_flags_by_pk?: Maybe<Feature_Flag>;
  /** An array relationship */
  fulfilment_center_carriers: Array<Fulfilment_Center_Carrier>;
  /** An aggregate relationship */
  fulfilment_center_carriers_aggregate: Fulfilment_Center_Carrier_Aggregate;
  /** fetch data from the table: "fulfilment_center_carrier" using primary key columns */
  fulfilment_center_carriers_by_pk?: Maybe<Fulfilment_Center_Carrier>;
  /** fetch data from the table: "fulfilment_center" */
  fulfilment_centers: Array<Fulfilment_Center>;
  /** fetch aggregated fields from the table: "fulfilment_center" */
  fulfilment_centers_aggregate: Fulfilment_Center_Aggregate;
  /** fetch data from the table: "fulfilment_center" using primary key columns */
  fulfilment_centers_by_pk?: Maybe<Fulfilment_Center>;
  /** An array relationship */
  fulfilment_shipment_line_items: Array<Fulfilment_Shipment_Line_Item>;
  /** An aggregate relationship */
  fulfilment_shipment_line_items_aggregate: Fulfilment_Shipment_Line_Item_Aggregate;
  /** fetch data from the table: "fulfilment_shipment_line_item" using primary key columns */
  fulfilment_shipment_line_items_by_pk?: Maybe<Fulfilment_Shipment_Line_Item>;
  /** An array relationship */
  fulfilment_shipment_parcels: Array<Fulfilment_Shipment_Parcel>;
  /** An aggregate relationship */
  fulfilment_shipment_parcels_aggregate: Fulfilment_Shipment_Parcel_Aggregate;
  /** fetch data from the table: "fulfilment_shipment_parcel" using primary key columns */
  fulfilment_shipment_parcels_by_pk?: Maybe<Fulfilment_Shipment_Parcel>;
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  /** fetch data from the table: "fulfilment_shipment" using primary key columns */
  fulfilment_shipments_by_pk?: Maybe<Fulfilment_Shipment>;
  get_carrier_settings: Array<CarrierSettingOutput>;
  get_shipping_rates?: Maybe<GetShippingRatesOutput>;
  get_shopify_access_tokens?: Maybe<GetShopifyAccessTokensOutput>;
  get_shopify_store?: Maybe<GetShopifyStoreOutput>;
  /** fetch data from the table: "integration_source" */
  integration_source: Array<Integration_Source>;
  /** fetch aggregated fields from the table: "integration_source" */
  integration_source_aggregate: Integration_Source_Aggregate;
  /** fetch data from the table: "integration_source" using primary key columns */
  integration_source_by_pk?: Maybe<Integration_Source>;
  /** fetch data from the table: "integration" */
  integrations: Array<Integration>;
  /** fetch aggregated fields from the table: "integration" */
  integrations_aggregate: Integration_Aggregate;
  /** fetch data from the table: "integration" using primary key columns */
  integrations_by_pk?: Maybe<Integration>;
  /** An array relationship */
  inventory_item_quantities: Array<Inventory_Item_Quantity>;
  /** An aggregate relationship */
  inventory_item_quantities_aggregate: Inventory_Item_Quantity_Aggregate;
  /** fetch data from the table: "inventory_item_quantity" using primary key columns */
  inventory_item_quantities_by_pk?: Maybe<Inventory_Item_Quantity>;
  /** An array relationship */
  inventory_items: Array<Inventory_Item>;
  /** An aggregate relationship */
  inventory_items_aggregate: Inventory_Item_Aggregate;
  /** fetch data from the table: "inventory_item" using primary key columns */
  inventory_items_by_pk?: Maybe<Inventory_Item>;
  /** fetch data from the table: "inventory_sync_job_status" */
  inventory_sync_job_status: Array<Inventory_Sync_Job_Status>;
  /** fetch aggregated fields from the table: "inventory_sync_job_status" */
  inventory_sync_job_status_aggregate: Inventory_Sync_Job_Status_Aggregate;
  /** fetch data from the table: "inventory_sync_job_status" using primary key columns */
  inventory_sync_job_status_by_pk?: Maybe<Inventory_Sync_Job_Status>;
  /** An array relationship */
  inventory_sync_jobs: Array<Inventory_Sync_Job>;
  /** An aggregate relationship */
  inventory_sync_jobs_aggregate: Inventory_Sync_Job_Aggregate;
  /** fetch data from the table: "inventory_sync_job" using primary key columns */
  inventory_sync_jobs_by_pk?: Maybe<Inventory_Sync_Job>;
  /** An array relationship */
  locations: Array<Location>;
  /** An aggregate relationship */
  locations_aggregate: Location_Aggregate;
  /** fetch data from the table: "location" using primary key columns */
  locations_by_pk?: Maybe<Location>;
  /** An array relationship */
  manifests: Array<Manifest>;
  /** An aggregate relationship */
  manifests_aggregate: Manifest_Aggregate;
  /** fetch data from the table: "manifest" using primary key columns */
  manifests_by_pk?: Maybe<Manifest>;
  /** An array relationship */
  organizations: Array<Organization>;
  /** An aggregate relationship */
  organizations_aggregate: Organization_Aggregate;
  /** fetch data from the table: "organization" using primary key columns */
  organizations_by_pk?: Maybe<Organization>;
  /** fetch data from the table: "packing_status" */
  packing_statuses: Array<Packing_Status>;
  /** fetch aggregated fields from the table: "packing_status" */
  packing_statuses_aggregate: Packing_Status_Aggregate;
  /** fetch data from the table: "packing_status" using primary key columns */
  packing_statuses_by_pk?: Maybe<Packing_Status>;
  /** An array relationship */
  parcel_types: Array<Parcel_Type>;
  /** An aggregate relationship */
  parcel_types_aggregate: Parcel_Type_Aggregate;
  /** fetch data from the table: "parcel_type" using primary key columns */
  parcel_types_by_pk?: Maybe<Parcel_Type>;
  /** fetch data from the table: "payment_status" */
  payment_statuses: Array<Payment_Status>;
  /** fetch data from the table: "payment_status" using primary key columns */
  payment_statuses_by_pk?: Maybe<Payment_Status>;
  /** An array relationship */
  product_variants: Array<Product_Variant>;
  /** An aggregate relationship */
  product_variants_aggregate: Product_Variant_Aggregate;
  /** fetch data from the table: "product_variant" using primary key columns */
  product_variants_by_pk?: Maybe<Product_Variant>;
  /** An array relationship */
  products: Array<Product>;
  /** An aggregate relationship */
  products_aggregate: Product_Aggregate;
  /** fetch data from the table: "product" using primary key columns */
  products_by_pk?: Maybe<Product>;
  /** fetch data from the table: "rate_request" */
  rate_requests: Array<Rate_Request>;
  /** fetch aggregated fields from the table: "rate_request" */
  rate_requests_aggregate: Rate_Request_Aggregate;
  /** fetch data from the table: "rate_request" using primary key columns */
  rate_requests_by_pk?: Maybe<Rate_Request>;
  /** fetch data from the table: "rate_selected_by" */
  rate_selected_by: Array<Rate_Selected_By>;
  /** fetch aggregated fields from the table: "rate_selected_by" */
  rate_selected_by_aggregate: Rate_Selected_By_Aggregate;
  /** fetch data from the table: "rate_selected_by" using primary key columns */
  rate_selected_by_by_pk?: Maybe<Rate_Selected_By>;
  /** fetch data from the table: "release_channel" */
  release_channel: Array<Release_Channel>;
  /** fetch aggregated fields from the table: "release_channel" */
  release_channel_aggregate: Release_Channel_Aggregate;
  /** fetch data from the table: "release_channel" using primary key columns */
  release_channel_by_pk?: Maybe<Release_Channel>;
  /** An array relationship */
  retail_units: Array<Retail_Unit>;
  /** An aggregate relationship */
  retail_units_aggregate: Retail_Unit_Aggregate;
  /** fetch data from the table: "retail_unit" using primary key columns */
  retail_units_by_pk?: Maybe<Retail_Unit>;
  /** fetch data from the table: "sales_channel" */
  sales_channel: Array<Sales_Channel>;
  /** fetch aggregated fields from the table: "sales_channel" */
  sales_channel_aggregate: Sales_Channel_Aggregate;
  /** fetch data from the table: "sales_channel" using primary key columns */
  sales_channel_by_pk?: Maybe<Sales_Channel>;
  /** fetch data from the table: "sales_order_integration" */
  sales_order_integration: Array<Sales_Order_Integration>;
  /** fetch aggregated fields from the table: "sales_order_integration" */
  sales_order_integration_aggregate: Sales_Order_Integration_Aggregate;
  /** fetch data from the table: "sales_order_integration" using primary key columns */
  sales_order_integration_by_pk?: Maybe<Sales_Order_Integration>;
  /** An array relationship */
  sales_order_line_items: Array<Sales_Order_Line_Item>;
  /** An aggregate relationship */
  sales_order_line_items_aggregate: Sales_Order_Line_Item_Aggregate;
  /** fetch data from the table: "sales_order_line_item" using primary key columns */
  sales_order_line_items_by_pk?: Maybe<Sales_Order_Line_Item>;
  /** An array relationship */
  sales_order_shipment_charges: Array<Sales_Order_Shipment_Charge>;
  /** An aggregate relationship */
  sales_order_shipment_charges_aggregate: Sales_Order_Shipment_Charge_Aggregate;
  /** fetch data from the table: "sales_order_shipment_charge" using primary key columns */
  sales_order_shipment_charges_by_pk?: Maybe<Sales_Order_Shipment_Charge>;
  /** fetch data from the table: "sales_order_status" */
  sales_order_statuses: Array<Sales_Order_Status>;
  /** fetch aggregated fields from the table: "sales_order_status" */
  sales_order_statuses_aggregate: Sales_Order_Status_Aggregate;
  /** fetch data from the table: "sales_order_status" using primary key columns */
  sales_order_statuses_by_pk?: Maybe<Sales_Order_Status>;
  /** An array relationship */
  sales_order_tags: Array<Sales_Order_Tag>;
  /** An aggregate relationship */
  sales_order_tags_aggregate: Sales_Order_Tag_Aggregate;
  /** fetch data from the table: "sales_order_tag" using primary key columns */
  sales_order_tags_by_pk?: Maybe<Sales_Order_Tag>;
  /** An array relationship */
  sales_orders: Array<Sales_Order>;
  /** An aggregate relationship */
  sales_orders_aggregate: Sales_Order_Aggregate;
  /** fetch data from the table: "sales_order" using primary key columns */
  sales_orders_by_pk?: Maybe<Sales_Order>;
  /** execute function "search_retail_unit" which returns "retail_unit" */
  search_retail_unit: Array<Retail_Unit>;
  /** execute function "search_retail_unit" and query aggregates on result of table type "retail_unit" */
  search_retail_unit_aggregate: Retail_Unit_Aggregate;
  /** execute function "search_tag" which returns "tag" */
  search_tag: Array<Tag>;
  /** execute function "search_tag" and query aggregates on result of table type "tag" */
  search_tag_aggregate: Tag_Aggregate;
  /** fetch data from the table: "shipment_source" */
  shipment_source: Array<Shipment_Source>;
  /** fetch aggregated fields from the table: "shipment_source" */
  shipment_source_aggregate: Shipment_Source_Aggregate;
  /** fetch data from the table: "shipment_source" using primary key columns */
  shipment_source_by_pk?: Maybe<Shipment_Source>;
  /** fetch data from the table: "shipment_status" */
  shipment_statuses: Array<Shipment_Status>;
  /** fetch aggregated fields from the table: "shipment_status" */
  shipment_statuses_aggregate: Shipment_Status_Aggregate;
  /** fetch data from the table: "shipment_status" using primary key columns */
  shipment_statuses_by_pk?: Maybe<Shipment_Status>;
  /** fetch data from the table: "shipping_area" */
  shipping_areas: Array<Shipping_Area>;
  /** fetch aggregated fields from the table: "shipping_area" */
  shipping_areas_aggregate: Shipping_Area_Aggregate;
  /** fetch data from the table: "shipping_area" using primary key columns */
  shipping_areas_by_pk?: Maybe<Shipping_Area>;
  /** fetch data from the table: "shipping_margin_type" */
  shipping_margin_type: Array<Shipping_Margin_Type>;
  /** fetch aggregated fields from the table: "shipping_margin_type" */
  shipping_margin_type_aggregate: Shipping_Margin_Type_Aggregate;
  /** fetch data from the table: "shipping_margin_type" using primary key columns */
  shipping_margin_type_by_pk?: Maybe<Shipping_Margin_Type>;
  /** An array relationship */
  shipping_margins: Array<Shipping_Margin>;
  /** An aggregate relationship */
  shipping_margins_aggregate: Shipping_Margin_Aggregate;
  /** fetch data from the table: "shipping_margin" using primary key columns */
  shipping_margins_by_pk?: Maybe<Shipping_Margin>;
  /** fetch data from the table: "shipping_provider" */
  shipping_provider: Array<Shipping_Provider>;
  /** fetch aggregated fields from the table: "shipping_provider" */
  shipping_provider_aggregate: Shipping_Provider_Aggregate;
  /** fetch data from the table: "shipping_provider" using primary key columns */
  shipping_provider_by_pk?: Maybe<Shipping_Provider>;
  /** An array relationship */
  shipping_rates: Array<Shipping_Rate>;
  /** An aggregate relationship */
  shipping_rates_aggregate: Shipping_Rate_Aggregate;
  /** fetch data from the table: "shipping_rate" using primary key columns */
  shipping_rates_by_pk?: Maybe<Shipping_Rate>;
  /** An array relationship */
  shopify_integrations: Array<Shopify_Integration>;
  /** An aggregate relationship */
  shopify_integrations_aggregate: Shopify_Integration_Aggregate;
  /** fetch data from the table: "shopify.integration" using primary key columns */
  shopify_integrations_by_pk?: Maybe<Shopify_Integration>;
  /** fetch data from the table: "shopify.order_archive" */
  shopify_order_archives: Array<Shopify_Order_Archive>;
  /** fetch aggregated fields from the table: "shopify.order_archive" */
  shopify_order_archives_aggregate: Shopify_Order_Archive_Aggregate;
  /** fetch data from the table: "shopify.order_archive" using primary key columns */
  shopify_order_archives_by_pk?: Maybe<Shopify_Order_Archive>;
  /** An array relationship */
  stock_transfer_items: Array<Stock_Transfer_Item>;
  /** An aggregate relationship */
  stock_transfer_items_aggregate: Stock_Transfer_Item_Aggregate;
  /** fetch data from the table: "stock_transfer_item" using primary key columns */
  stock_transfer_items_by_pk?: Maybe<Stock_Transfer_Item>;
  /** fetch data from the table: "stock_transfer_parcel" */
  stock_transfer_parcels: Array<Stock_Transfer_Parcel>;
  /** fetch aggregated fields from the table: "stock_transfer_parcel" */
  stock_transfer_parcels_aggregate: Stock_Transfer_Parcel_Aggregate;
  /** fetch data from the table: "stock_transfer_parcel" using primary key columns */
  stock_transfer_parcels_by_pk?: Maybe<Stock_Transfer_Parcel>;
  /** fetch data from the table: "stock_transfer_shipment" */
  stock_transfer_shipments: Array<Stock_Transfer_Shipment>;
  /** fetch aggregated fields from the table: "stock_transfer_shipment" */
  stock_transfer_shipments_aggregate: Stock_Transfer_Shipment_Aggregate;
  /** fetch data from the table: "stock_transfer_shipment" using primary key columns */
  stock_transfer_shipments_by_pk?: Maybe<Stock_Transfer_Shipment>;
  /** fetch data from the table: "stock_transfer_status" */
  stock_transfer_status: Array<Stock_Transfer_Status>;
  /** fetch aggregated fields from the table: "stock_transfer_status" */
  stock_transfer_status_aggregate: Stock_Transfer_Status_Aggregate;
  /** fetch data from the table: "stock_transfer_status" using primary key columns */
  stock_transfer_status_by_pk?: Maybe<Stock_Transfer_Status>;
  /** An array relationship */
  stock_transfers: Array<Stock_Transfer>;
  /** An aggregate relationship */
  stock_transfers_aggregate: Stock_Transfer_Aggregate;
  /** fetch data from the table: "stock_transfer" using primary key columns */
  stock_transfers_by_pk?: Maybe<Stock_Transfer>;
  /** fetch data from the table: "store_feature_flag" */
  store_feature_flag: Array<Store_Feature_Flag>;
  /** fetch aggregated fields from the table: "store_feature_flag" */
  store_feature_flag_aggregate: Store_Feature_Flag_Aggregate;
  /** fetch data from the table: "store_feature_flag" using primary key columns */
  store_feature_flag_by_pk?: Maybe<Store_Feature_Flag>;
  /** fetch data from the table: "store_setting" */
  store_setting: Array<Store_Setting>;
  /** fetch aggregated fields from the table: "store_setting" */
  store_setting_aggregate: Store_Setting_Aggregate;
  /** fetch data from the table: "store_setting" using primary key columns */
  store_setting_by_pk?: Maybe<Store_Setting>;
  /** fetch data from the table: "store_setting_key" */
  store_setting_key: Array<Store_Setting_Key>;
  /** fetch aggregated fields from the table: "store_setting_key" */
  store_setting_key_aggregate: Store_Setting_Key_Aggregate;
  /** fetch data from the table: "store_setting_key" using primary key columns */
  store_setting_key_by_pk?: Maybe<Store_Setting_Key>;
  /** fetch data from the table: "store_slug" */
  store_slug: Array<Store_Slug>;
  /** fetch aggregated fields from the table: "store_slug" */
  store_slug_aggregate: Store_Slug_Aggregate;
  /** fetch data from the table: "store_slug" using primary key columns */
  store_slug_by_pk?: Maybe<Store_Slug>;
  /** An array relationship */
  stores: Array<Store>;
  /** An aggregate relationship */
  stores_aggregate: Store_Aggregate;
  /** fetch data from the table: "store" using primary key columns */
  stores_by_pk?: Maybe<Store>;
  /** An array relationship */
  tags: Array<Tag>;
  /** An aggregate relationship */
  tags_aggregate: Tag_Aggregate;
  /** fetch data from the table: "tag" using primary key columns */
  tags_by_pk?: Maybe<Tag>;
  /** An array relationship */
  user_organizations: Array<User_Organization>;
  /** An aggregate relationship */
  user_organizations_aggregate: User_Organization_Aggregate;
  /** fetch data from the table: "user_organization" using primary key columns */
  user_organizations_by_pk?: Maybe<User_Organization>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
};


export type Query_RootAddress_Payment_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Payment_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Status_Order_By>>;
  where?: Maybe<Payment_Status_Bool_Exp>;
};


export type Query_RootAddress_TypesArgs = {
  distinct_on?: Maybe<Array<Address_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Type_Order_By>>;
  where?: Maybe<Address_Type_Bool_Exp>;
};


export type Query_RootAddress_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Address_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Type_Order_By>>;
  where?: Maybe<Address_Type_Bool_Exp>;
};


export type Query_RootAddress_Types_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootAddressesArgs = {
  distinct_on?: Maybe<Array<Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Order_By>>;
  where?: Maybe<Address_Bool_Exp>;
};


export type Query_RootAddresses_AggregateArgs = {
  distinct_on?: Maybe<Array<Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Order_By>>;
  where?: Maybe<Address_Bool_Exp>;
};


export type Query_RootAddresses_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAuth_Account_ProvidersArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Providers_Order_By>>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};


export type Query_RootAuth_Account_Providers_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Providers_Order_By>>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};


export type Query_RootAuth_Account_Providers_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAuth_Account_RolesArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Roles_Order_By>>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};


export type Query_RootAuth_Account_Roles_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Roles_Order_By>>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};


export type Query_RootAuth_Account_Roles_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAuth_AccountsArgs = {
  distinct_on?: Maybe<Array<Auth_Accounts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Accounts_Order_By>>;
  where?: Maybe<Auth_Accounts_Bool_Exp>;
};


export type Query_RootAuth_Accounts_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Accounts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Accounts_Order_By>>;
  where?: Maybe<Auth_Accounts_Bool_Exp>;
};


export type Query_RootAuth_Accounts_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAuth_ProvidersArgs = {
  distinct_on?: Maybe<Array<Auth_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Providers_Order_By>>;
  where?: Maybe<Auth_Providers_Bool_Exp>;
};


export type Query_RootAuth_Providers_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Providers_Order_By>>;
  where?: Maybe<Auth_Providers_Bool_Exp>;
};


export type Query_RootAuth_Providers_By_PkArgs = {
  provider: Scalars['String'];
};


export type Query_RootAuth_Refresh_TokensArgs = {
  distinct_on?: Maybe<Array<Auth_Refresh_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Refresh_Tokens_Order_By>>;
  where?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
};


export type Query_RootAuth_Refresh_Tokens_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Refresh_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Refresh_Tokens_Order_By>>;
  where?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
};


export type Query_RootAuth_Refresh_Tokens_By_PkArgs = {
  refresh_token: Scalars['uuid'];
};


export type Query_RootAuth_RolesArgs = {
  distinct_on?: Maybe<Array<Auth_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Roles_Order_By>>;
  where?: Maybe<Auth_Roles_Bool_Exp>;
};


export type Query_RootAuth_Roles_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Roles_Order_By>>;
  where?: Maybe<Auth_Roles_Bool_Exp>;
};


export type Query_RootAuth_Roles_By_PkArgs = {
  role: Scalars['String'];
};


export type Query_RootCarrier_SelectionArgs = {
  distinct_on?: Maybe<Array<Carrier_Selection_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Selection_Order_By>>;
  where?: Maybe<Carrier_Selection_Bool_Exp>;
};


export type Query_RootCarrier_Selection_AggregateArgs = {
  distinct_on?: Maybe<Array<Carrier_Selection_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Selection_Order_By>>;
  where?: Maybe<Carrier_Selection_Bool_Exp>;
};


export type Query_RootCarrier_Selection_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootCarriersArgs = {
  distinct_on?: Maybe<Array<Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Order_By>>;
  where?: Maybe<Carrier_Bool_Exp>;
};


export type Query_RootCarriers_AggregateArgs = {
  distinct_on?: Maybe<Array<Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Order_By>>;
  where?: Maybe<Carrier_Bool_Exp>;
};


export type Query_RootCarriers_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCustomersArgs = {
  distinct_on?: Maybe<Array<Customer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Order_By>>;
  where?: Maybe<Customer_Bool_Exp>;
};


export type Query_RootCustomers_AggregateArgs = {
  distinct_on?: Maybe<Array<Customer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Order_By>>;
  where?: Maybe<Customer_Bool_Exp>;
};


export type Query_RootCustomers_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootDraft_Fulfilment_ShipmentArgs = {
  distinct_on?: Maybe<Array<Draft_Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Draft_Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Draft_Fulfilment_Shipment_Bool_Exp>;
};


export type Query_RootDraft_Fulfilment_Shipment_AggregateArgs = {
  distinct_on?: Maybe<Array<Draft_Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Draft_Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Draft_Fulfilment_Shipment_Bool_Exp>;
};


export type Query_RootEvent_Core_Event_StoreArgs = {
  distinct_on?: Maybe<Array<Event_Core_Event_Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Event_Core_Event_Store_Order_By>>;
  where?: Maybe<Event_Core_Event_Store_Bool_Exp>;
};


export type Query_RootEvent_Core_Event_Store_AggregateArgs = {
  distinct_on?: Maybe<Array<Event_Core_Event_Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Event_Core_Event_Store_Order_By>>;
  where?: Maybe<Event_Core_Event_Store_Bool_Exp>;
};


export type Query_RootEvent_Core_Event_Store_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootFeature_FlagsArgs = {
  distinct_on?: Maybe<Array<Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Flag_Order_By>>;
  where?: Maybe<Feature_Flag_Bool_Exp>;
};


export type Query_RootFeature_Flags_AggregateArgs = {
  distinct_on?: Maybe<Array<Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Flag_Order_By>>;
  where?: Maybe<Feature_Flag_Bool_Exp>;
};


export type Query_RootFeature_Flags_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootFulfilment_Center_CarriersArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Carrier_Order_By>>;
  where?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
};


export type Query_RootFulfilment_Center_Carriers_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Carrier_Order_By>>;
  where?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
};


export type Query_RootFulfilment_Center_Carriers_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootFulfilment_CentersArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Order_By>>;
  where?: Maybe<Fulfilment_Center_Bool_Exp>;
};


export type Query_RootFulfilment_Centers_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Order_By>>;
  where?: Maybe<Fulfilment_Center_Bool_Exp>;
};


export type Query_RootFulfilment_Centers_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootFulfilment_Shipment_Line_ItemsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Line_Item_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
};


export type Query_RootFulfilment_Shipment_Line_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Line_Item_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
};


export type Query_RootFulfilment_Shipment_Line_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootFulfilment_Shipment_ParcelsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


export type Query_RootFulfilment_Shipment_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


export type Query_RootFulfilment_Shipment_Parcels_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


export type Query_RootFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


export type Query_RootFulfilment_Shipments_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGet_Carrier_SettingsArgs = {
  storeId: Scalars['uuid'];
};


export type Query_RootGet_Shipping_RatesArgs = {
  fulfilmentShipmentId?: Maybe<Scalars['uuid']>;
  orderReference?: Maybe<Scalars['String']>;
  shipment: RatesShipment;
  storeId: Scalars['uuid'];
};


export type Query_RootGet_Shopify_StoreArgs = {
  shopDomain: Scalars['String'];
};


export type Query_RootIntegration_SourceArgs = {
  distinct_on?: Maybe<Array<Integration_Source_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Integration_Source_Order_By>>;
  where?: Maybe<Integration_Source_Bool_Exp>;
};


export type Query_RootIntegration_Source_AggregateArgs = {
  distinct_on?: Maybe<Array<Integration_Source_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Integration_Source_Order_By>>;
  where?: Maybe<Integration_Source_Bool_Exp>;
};


export type Query_RootIntegration_Source_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootIntegrationsArgs = {
  distinct_on?: Maybe<Array<Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Integration_Order_By>>;
  where?: Maybe<Integration_Bool_Exp>;
};


export type Query_RootIntegrations_AggregateArgs = {
  distinct_on?: Maybe<Array<Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Integration_Order_By>>;
  where?: Maybe<Integration_Bool_Exp>;
};


export type Query_RootIntegrations_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootInventory_Item_QuantitiesArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


export type Query_RootInventory_Item_Quantities_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


export type Query_RootInventory_Item_Quantities_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootInventory_ItemsArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Order_By>>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};


export type Query_RootInventory_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Order_By>>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};


export type Query_RootInventory_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootInventory_Sync_Job_StatusArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Status_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Status_Bool_Exp>;
};


export type Query_RootInventory_Sync_Job_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Status_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Status_Bool_Exp>;
};


export type Query_RootInventory_Sync_Job_Status_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootInventory_Sync_JobsArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


export type Query_RootInventory_Sync_Jobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


export type Query_RootInventory_Sync_Jobs_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootLocationsArgs = {
  distinct_on?: Maybe<Array<Location_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Location_Order_By>>;
  where?: Maybe<Location_Bool_Exp>;
};


export type Query_RootLocations_AggregateArgs = {
  distinct_on?: Maybe<Array<Location_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Location_Order_By>>;
  where?: Maybe<Location_Bool_Exp>;
};


export type Query_RootLocations_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootManifestsArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


export type Query_RootManifests_AggregateArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


export type Query_RootManifests_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrganizationsArgs = {
  distinct_on?: Maybe<Array<Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Organization_Order_By>>;
  where?: Maybe<Organization_Bool_Exp>;
};


export type Query_RootOrganizations_AggregateArgs = {
  distinct_on?: Maybe<Array<Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Organization_Order_By>>;
  where?: Maybe<Organization_Bool_Exp>;
};


export type Query_RootOrganizations_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPacking_StatusesArgs = {
  distinct_on?: Maybe<Array<Packing_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Packing_Status_Order_By>>;
  where?: Maybe<Packing_Status_Bool_Exp>;
};


export type Query_RootPacking_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Packing_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Packing_Status_Order_By>>;
  where?: Maybe<Packing_Status_Bool_Exp>;
};


export type Query_RootPacking_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootParcel_TypesArgs = {
  distinct_on?: Maybe<Array<Parcel_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Parcel_Type_Order_By>>;
  where?: Maybe<Parcel_Type_Bool_Exp>;
};


export type Query_RootParcel_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Parcel_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Parcel_Type_Order_By>>;
  where?: Maybe<Parcel_Type_Bool_Exp>;
};


export type Query_RootParcel_Types_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPayment_StatusesArgs = {
  distinct_on?: Maybe<Array<Payment_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Status_Order_By>>;
  where?: Maybe<Payment_Status_Bool_Exp>;
};


export type Query_RootPayment_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootProduct_VariantsArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


export type Query_RootProduct_Variants_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


export type Query_RootProduct_Variants_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootProductsArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};


export type Query_RootProducts_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};


export type Query_RootProducts_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootRate_RequestsArgs = {
  distinct_on?: Maybe<Array<Rate_Request_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Rate_Request_Order_By>>;
  where?: Maybe<Rate_Request_Bool_Exp>;
};


export type Query_RootRate_Requests_AggregateArgs = {
  distinct_on?: Maybe<Array<Rate_Request_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Rate_Request_Order_By>>;
  where?: Maybe<Rate_Request_Bool_Exp>;
};


export type Query_RootRate_Requests_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRate_Selected_ByArgs = {
  distinct_on?: Maybe<Array<Rate_Selected_By_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Rate_Selected_By_Order_By>>;
  where?: Maybe<Rate_Selected_By_Bool_Exp>;
};


export type Query_RootRate_Selected_By_AggregateArgs = {
  distinct_on?: Maybe<Array<Rate_Selected_By_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Rate_Selected_By_Order_By>>;
  where?: Maybe<Rate_Selected_By_Bool_Exp>;
};


export type Query_RootRate_Selected_By_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootRelease_ChannelArgs = {
  distinct_on?: Maybe<Array<Release_Channel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Release_Channel_Order_By>>;
  where?: Maybe<Release_Channel_Bool_Exp>;
};


export type Query_RootRelease_Channel_AggregateArgs = {
  distinct_on?: Maybe<Array<Release_Channel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Release_Channel_Order_By>>;
  where?: Maybe<Release_Channel_Bool_Exp>;
};


export type Query_RootRelease_Channel_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootRetail_UnitsArgs = {
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


export type Query_RootRetail_Units_AggregateArgs = {
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


export type Query_RootRetail_Units_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootSales_ChannelArgs = {
  distinct_on?: Maybe<Array<Sales_Channel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Channel_Order_By>>;
  where?: Maybe<Sales_Channel_Bool_Exp>;
};


export type Query_RootSales_Channel_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Channel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Channel_Order_By>>;
  where?: Maybe<Sales_Channel_Bool_Exp>;
};


export type Query_RootSales_Channel_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootSales_Order_IntegrationArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Integration_Order_By>>;
  where?: Maybe<Sales_Order_Integration_Bool_Exp>;
};


export type Query_RootSales_Order_Integration_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Integration_Order_By>>;
  where?: Maybe<Sales_Order_Integration_Bool_Exp>;
};


export type Query_RootSales_Order_Integration_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootSales_Order_Line_ItemsArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Line_Item_Order_By>>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};


export type Query_RootSales_Order_Line_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Line_Item_Order_By>>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};


export type Query_RootSales_Order_Line_Items_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSales_Order_Shipment_ChargesArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Shipment_Charge_Order_By>>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};


export type Query_RootSales_Order_Shipment_Charges_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Shipment_Charge_Order_By>>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};


export type Query_RootSales_Order_Shipment_Charges_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSales_Order_StatusesArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Status_Order_By>>;
  where?: Maybe<Sales_Order_Status_Bool_Exp>;
};


export type Query_RootSales_Order_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Status_Order_By>>;
  where?: Maybe<Sales_Order_Status_Bool_Exp>;
};


export type Query_RootSales_Order_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootSales_Order_TagsArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Tag_Order_By>>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};


export type Query_RootSales_Order_Tags_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Tag_Order_By>>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};


export type Query_RootSales_Order_Tags_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootSales_OrdersArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


export type Query_RootSales_Orders_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


export type Query_RootSales_Orders_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSearch_Retail_UnitArgs = {
  args: Search_Retail_Unit_Args;
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


export type Query_RootSearch_Retail_Unit_AggregateArgs = {
  args: Search_Retail_Unit_Args;
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


export type Query_RootSearch_TagArgs = {
  args: Search_Tag_Args;
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


export type Query_RootSearch_Tag_AggregateArgs = {
  args: Search_Tag_Args;
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


export type Query_RootShipment_SourceArgs = {
  distinct_on?: Maybe<Array<Shipment_Source_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipment_Source_Order_By>>;
  where?: Maybe<Shipment_Source_Bool_Exp>;
};


export type Query_RootShipment_Source_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipment_Source_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipment_Source_Order_By>>;
  where?: Maybe<Shipment_Source_Bool_Exp>;
};


export type Query_RootShipment_Source_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootShipment_StatusesArgs = {
  distinct_on?: Maybe<Array<Shipment_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipment_Status_Order_By>>;
  where?: Maybe<Shipment_Status_Bool_Exp>;
};


export type Query_RootShipment_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipment_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipment_Status_Order_By>>;
  where?: Maybe<Shipment_Status_Bool_Exp>;
};


export type Query_RootShipment_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootShipping_AreasArgs = {
  distinct_on?: Maybe<Array<Shipping_Area_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Area_Order_By>>;
  where?: Maybe<Shipping_Area_Bool_Exp>;
};


export type Query_RootShipping_Areas_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Area_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Area_Order_By>>;
  where?: Maybe<Shipping_Area_Bool_Exp>;
};


export type Query_RootShipping_Areas_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootShipping_Margin_TypeArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Type_Order_By>>;
  where?: Maybe<Shipping_Margin_Type_Bool_Exp>;
};


export type Query_RootShipping_Margin_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Type_Order_By>>;
  where?: Maybe<Shipping_Margin_Type_Bool_Exp>;
};


export type Query_RootShipping_Margin_Type_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootShipping_MarginsArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Order_By>>;
  where?: Maybe<Shipping_Margin_Bool_Exp>;
};


export type Query_RootShipping_Margins_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Order_By>>;
  where?: Maybe<Shipping_Margin_Bool_Exp>;
};


export type Query_RootShipping_Margins_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootShipping_ProviderArgs = {
  distinct_on?: Maybe<Array<Shipping_Provider_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Provider_Order_By>>;
  where?: Maybe<Shipping_Provider_Bool_Exp>;
};


export type Query_RootShipping_Provider_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Provider_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Provider_Order_By>>;
  where?: Maybe<Shipping_Provider_Bool_Exp>;
};


export type Query_RootShipping_Provider_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootShipping_RatesArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


export type Query_RootShipping_Rates_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


export type Query_RootShipping_Rates_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootShopify_IntegrationsArgs = {
  distinct_on?: Maybe<Array<Shopify_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Integration_Order_By>>;
  where?: Maybe<Shopify_Integration_Bool_Exp>;
};


export type Query_RootShopify_Integrations_AggregateArgs = {
  distinct_on?: Maybe<Array<Shopify_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Integration_Order_By>>;
  where?: Maybe<Shopify_Integration_Bool_Exp>;
};


export type Query_RootShopify_Integrations_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootShopify_Order_ArchivesArgs = {
  distinct_on?: Maybe<Array<Shopify_Order_Archive_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Order_Archive_Order_By>>;
  where?: Maybe<Shopify_Order_Archive_Bool_Exp>;
};


export type Query_RootShopify_Order_Archives_AggregateArgs = {
  distinct_on?: Maybe<Array<Shopify_Order_Archive_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Order_Archive_Order_By>>;
  where?: Maybe<Shopify_Order_Archive_Bool_Exp>;
};


export type Query_RootShopify_Order_Archives_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootStock_Transfer_ItemsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


export type Query_RootStock_Transfer_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


export type Query_RootStock_Transfer_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootStock_Transfer_ParcelsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


export type Query_RootStock_Transfer_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


export type Query_RootStock_Transfer_Parcels_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootStock_Transfer_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};


export type Query_RootStock_Transfer_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};


export type Query_RootStock_Transfer_Shipments_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootStock_Transfer_StatusArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Status_Order_By>>;
  where?: Maybe<Stock_Transfer_Status_Bool_Exp>;
};


export type Query_RootStock_Transfer_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Status_Order_By>>;
  where?: Maybe<Stock_Transfer_Status_Bool_Exp>;
};


export type Query_RootStock_Transfer_Status_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootStock_TransfersArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Order_By>>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};


export type Query_RootStock_Transfers_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Order_By>>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};


export type Query_RootStock_Transfers_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootStore_Feature_FlagArgs = {
  distinct_on?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Feature_Flag_Order_By>>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};


export type Query_RootStore_Feature_Flag_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Feature_Flag_Order_By>>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};


export type Query_RootStore_Feature_Flag_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootStore_SettingArgs = {
  distinct_on?: Maybe<Array<Store_Setting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Setting_Order_By>>;
  where?: Maybe<Store_Setting_Bool_Exp>;
};


export type Query_RootStore_Setting_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Setting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Setting_Order_By>>;
  where?: Maybe<Store_Setting_Bool_Exp>;
};


export type Query_RootStore_Setting_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootStore_Setting_KeyArgs = {
  distinct_on?: Maybe<Array<Store_Setting_Key_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Setting_Key_Order_By>>;
  where?: Maybe<Store_Setting_Key_Bool_Exp>;
};


export type Query_RootStore_Setting_Key_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Setting_Key_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Setting_Key_Order_By>>;
  where?: Maybe<Store_Setting_Key_Bool_Exp>;
};


export type Query_RootStore_Setting_Key_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootStore_SlugArgs = {
  distinct_on?: Maybe<Array<Store_Slug_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Slug_Order_By>>;
  where?: Maybe<Store_Slug_Bool_Exp>;
};


export type Query_RootStore_Slug_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Slug_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Slug_Order_By>>;
  where?: Maybe<Store_Slug_Bool_Exp>;
};


export type Query_RootStore_Slug_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootStoresArgs = {
  distinct_on?: Maybe<Array<Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Order_By>>;
  where?: Maybe<Store_Bool_Exp>;
};


export type Query_RootStores_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Order_By>>;
  where?: Maybe<Store_Bool_Exp>;
};


export type Query_RootStores_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootTagsArgs = {
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


export type Query_RootTags_AggregateArgs = {
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


export type Query_RootTags_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootUser_OrganizationsArgs = {
  distinct_on?: Maybe<Array<User_Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Organization_Order_By>>;
  where?: Maybe<User_Organization_Bool_Exp>;
};


export type Query_RootUser_Organizations_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Organization_Order_By>>;
  where?: Maybe<User_Organization_Bool_Exp>;
};


export type Query_RootUser_Organizations_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUsersArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


export type Query_RootUsers_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


export type Query_RootUsers_By_PkArgs = {
  id: Scalars['uuid'];
};

/** columns and relationships of "rate_request" */
export type Rate_Request = {
  created_at: Scalars['timestamptz'];
  errors?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  fulfilment_shipment?: Maybe<Fulfilment_Shipment>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  fulfilment_shipment_rate_requested_for?: Maybe<Fulfilment_Shipment>;
  has_errors: Scalars['Boolean'];
  id: Scalars['uuid'];
  invalidated_at?: Maybe<Scalars['timestamptz']>;
  location_id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  shipping_rates: Array<Shipping_Rate>;
  /** An aggregate relationship */
  shipping_rates_aggregate: Shipping_Rate_Aggregate;
};


/** columns and relationships of "rate_request" */
export type Rate_RequestErrorsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "rate_request" */
export type Rate_RequestShipping_RatesArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


/** columns and relationships of "rate_request" */
export type Rate_RequestShipping_Rates_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};

/** aggregated selection of "rate_request" */
export type Rate_Request_Aggregate = {
  aggregate?: Maybe<Rate_Request_Aggregate_Fields>;
  nodes: Array<Rate_Request>;
};

/** aggregate fields of "rate_request" */
export type Rate_Request_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Rate_Request_Max_Fields>;
  min?: Maybe<Rate_Request_Min_Fields>;
};


/** aggregate fields of "rate_request" */
export type Rate_Request_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Rate_Request_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rate_Request_Append_Input = {
  errors?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "rate_request". All fields are combined with a logical 'AND'. */
export type Rate_Request_Bool_Exp = {
  _and?: Maybe<Array<Rate_Request_Bool_Exp>>;
  _not?: Maybe<Rate_Request_Bool_Exp>;
  _or?: Maybe<Array<Rate_Request_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  errors?: Maybe<Jsonb_Comparison_Exp>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipment_id?: Maybe<Uuid_Comparison_Exp>;
  fulfilment_shipment_rate_requested_for?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  has_errors?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invalidated_at?: Maybe<Timestamptz_Comparison_Exp>;
  location_id?: Maybe<Uuid_Comparison_Exp>;
  shipping_rates?: Maybe<Shipping_Rate_Bool_Exp>;
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "rate_request" */
export const Rate_Request_Constraint = {
  /** unique or primary key constraint on columns "id" */
  RateRequestPkey: 'rate_request_pkey'
} as const;

export type Rate_Request_Constraint = typeof Rate_Request_Constraint[keyof typeof Rate_Request_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rate_Request_Delete_At_Path_Input = {
  errors?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rate_Request_Delete_Elem_Input = {
  errors?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rate_Request_Delete_Key_Input = {
  errors?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "rate_request" */
export type Rate_Request_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  errors?: Maybe<Scalars['jsonb']>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment_Obj_Rel_Insert_Input>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  fulfilment_shipment_rate_requested_for?: Maybe<Fulfilment_Shipment_Obj_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  invalidated_at?: Maybe<Scalars['timestamptz']>;
  location_id?: Maybe<Scalars['uuid']>;
  shipping_rates?: Maybe<Shipping_Rate_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Rate_Request_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  invalidated_at?: Maybe<Scalars['timestamptz']>;
  location_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Rate_Request_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  invalidated_at?: Maybe<Scalars['timestamptz']>;
  location_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "rate_request" */
export type Rate_Request_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Rate_Request>;
};

/** input type for inserting object relation for remote table "rate_request" */
export type Rate_Request_Obj_Rel_Insert_Input = {
  data: Rate_Request_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Rate_Request_On_Conflict>;
};

/** on_conflict condition type for table "rate_request" */
export type Rate_Request_On_Conflict = {
  constraint: Rate_Request_Constraint;
  update_columns?: Array<Rate_Request_Update_Column>;
  where?: Maybe<Rate_Request_Bool_Exp>;
};

/** Ordering options when selecting data from "rate_request". */
export type Rate_Request_Order_By = {
  created_at?: Maybe<Order_By>;
  errors?: Maybe<Order_By>;
  fulfilment_shipment?: Maybe<Fulfilment_Shipment_Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  fulfilment_shipment_rate_requested_for?: Maybe<Fulfilment_Shipment_Order_By>;
  has_errors?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invalidated_at?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Order_By>;
};

/** primary key columns input for table: rate_request */
export type Rate_Request_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rate_Request_Prepend_Input = {
  errors?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "rate_request" */
export const Rate_Request_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Errors: 'errors',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  HasErrors: 'has_errors',
  /** column name */
  Id: 'id',
  /** column name */
  InvalidatedAt: 'invalidated_at',
  /** column name */
  LocationId: 'location_id'
} as const;

export type Rate_Request_Select_Column = typeof Rate_Request_Select_Column[keyof typeof Rate_Request_Select_Column];
/** input type for updating data in table "rate_request" */
export type Rate_Request_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  errors?: Maybe<Scalars['jsonb']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  invalidated_at?: Maybe<Scalars['timestamptz']>;
  location_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "rate_request" */
export type Rate_Request_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rate_Request_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rate_Request_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  errors?: Maybe<Scalars['jsonb']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  has_errors?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  invalidated_at?: Maybe<Scalars['timestamptz']>;
  location_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "rate_request" */
export const Rate_Request_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Errors: 'errors',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  Id: 'id',
  /** column name */
  InvalidatedAt: 'invalidated_at',
  /** column name */
  LocationId: 'location_id'
} as const;

export type Rate_Request_Update_Column = typeof Rate_Request_Update_Column[keyof typeof Rate_Request_Update_Column];
export type Rate_Request_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Rate_Request_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Rate_Request_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Rate_Request_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Rate_Request_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Rate_Request_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Rate_Request_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rate_Request_Bool_Exp;
};

/** columns and relationships of "rate_selected_by" */
export type Rate_Selected_By = {
  /** An array relationship */
  shipping_rates: Array<Shipping_Rate>;
  /** An aggregate relationship */
  shipping_rates_aggregate: Shipping_Rate_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "rate_selected_by" */
export type Rate_Selected_ByShipping_RatesArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


/** columns and relationships of "rate_selected_by" */
export type Rate_Selected_ByShipping_Rates_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};

/** aggregated selection of "rate_selected_by" */
export type Rate_Selected_By_Aggregate = {
  aggregate?: Maybe<Rate_Selected_By_Aggregate_Fields>;
  nodes: Array<Rate_Selected_By>;
};

/** aggregate fields of "rate_selected_by" */
export type Rate_Selected_By_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Rate_Selected_By_Max_Fields>;
  min?: Maybe<Rate_Selected_By_Min_Fields>;
};


/** aggregate fields of "rate_selected_by" */
export type Rate_Selected_By_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Rate_Selected_By_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "rate_selected_by". All fields are combined with a logical 'AND'. */
export type Rate_Selected_By_Bool_Exp = {
  _and?: Maybe<Array<Rate_Selected_By_Bool_Exp>>;
  _not?: Maybe<Rate_Selected_By_Bool_Exp>;
  _or?: Maybe<Array<Rate_Selected_By_Bool_Exp>>;
  shipping_rates?: Maybe<Shipping_Rate_Bool_Exp>;
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rate_selected_by" */
export const Rate_Selected_By_Constraint = {
  /** unique or primary key constraint on columns "value" */
  RateSelectedByPkey: 'rate_selected_by_pkey'
} as const;

export type Rate_Selected_By_Constraint = typeof Rate_Selected_By_Constraint[keyof typeof Rate_Selected_By_Constraint];
export const Rate_Selected_By_Enum = {
  Manual: 'MANUAL',
  Skutopia: 'SKUTOPIA'
} as const;

export type Rate_Selected_By_Enum = typeof Rate_Selected_By_Enum[keyof typeof Rate_Selected_By_Enum];
/** Boolean expression to compare columns of type "rate_selected_by_enum". All fields are combined with logical 'AND'. */
export type Rate_Selected_By_Enum_Comparison_Exp = {
  _eq?: Maybe<Rate_Selected_By_Enum>;
  _in?: Maybe<Array<Rate_Selected_By_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Rate_Selected_By_Enum>;
  _nin?: Maybe<Array<Rate_Selected_By_Enum>>;
};

/** input type for inserting data into table "rate_selected_by" */
export type Rate_Selected_By_Insert_Input = {
  shipping_rates?: Maybe<Shipping_Rate_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Rate_Selected_By_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Rate_Selected_By_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "rate_selected_by" */
export type Rate_Selected_By_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Rate_Selected_By>;
};

/** input type for inserting object relation for remote table "rate_selected_by" */
export type Rate_Selected_By_Obj_Rel_Insert_Input = {
  data: Rate_Selected_By_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Rate_Selected_By_On_Conflict>;
};

/** on_conflict condition type for table "rate_selected_by" */
export type Rate_Selected_By_On_Conflict = {
  constraint: Rate_Selected_By_Constraint;
  update_columns?: Array<Rate_Selected_By_Update_Column>;
  where?: Maybe<Rate_Selected_By_Bool_Exp>;
};

/** Ordering options when selecting data from "rate_selected_by". */
export type Rate_Selected_By_Order_By = {
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: rate_selected_by */
export type Rate_Selected_By_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "rate_selected_by" */
export const Rate_Selected_By_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Rate_Selected_By_Select_Column = typeof Rate_Selected_By_Select_Column[keyof typeof Rate_Selected_By_Select_Column];
/** input type for updating data in table "rate_selected_by" */
export type Rate_Selected_By_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "rate_selected_by" */
export type Rate_Selected_By_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rate_Selected_By_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rate_Selected_By_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "rate_selected_by" */
export const Rate_Selected_By_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Rate_Selected_By_Update_Column = typeof Rate_Selected_By_Update_Column[keyof typeof Rate_Selected_By_Update_Column];
export type Rate_Selected_By_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Rate_Selected_By_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rate_Selected_By_Bool_Exp;
};

/** columns and relationships of "release_channel" */
export type Release_Channel = {
  value: Scalars['String'];
};

/** aggregated selection of "release_channel" */
export type Release_Channel_Aggregate = {
  aggregate?: Maybe<Release_Channel_Aggregate_Fields>;
  nodes: Array<Release_Channel>;
};

/** aggregate fields of "release_channel" */
export type Release_Channel_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Release_Channel_Max_Fields>;
  min?: Maybe<Release_Channel_Min_Fields>;
};


/** aggregate fields of "release_channel" */
export type Release_Channel_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Release_Channel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "release_channel". All fields are combined with a logical 'AND'. */
export type Release_Channel_Bool_Exp = {
  _and?: Maybe<Array<Release_Channel_Bool_Exp>>;
  _not?: Maybe<Release_Channel_Bool_Exp>;
  _or?: Maybe<Array<Release_Channel_Bool_Exp>>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "release_channel" */
export const Release_Channel_Constraint = {
  /** unique or primary key constraint on columns "value" */
  ReleaseChannelPkey: 'release_channel_pkey'
} as const;

export type Release_Channel_Constraint = typeof Release_Channel_Constraint[keyof typeof Release_Channel_Constraint];
export const Release_Channel_Enum = {
  Alpha: 'ALPHA',
  Beta: 'BETA',
  Stable: 'STABLE'
} as const;

export type Release_Channel_Enum = typeof Release_Channel_Enum[keyof typeof Release_Channel_Enum];
/** Boolean expression to compare columns of type "release_channel_enum". All fields are combined with logical 'AND'. */
export type Release_Channel_Enum_Comparison_Exp = {
  _eq?: Maybe<Release_Channel_Enum>;
  _in?: Maybe<Array<Release_Channel_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Release_Channel_Enum>;
  _nin?: Maybe<Array<Release_Channel_Enum>>;
};

/** input type for inserting data into table "release_channel" */
export type Release_Channel_Insert_Input = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Release_Channel_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Release_Channel_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "release_channel" */
export type Release_Channel_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Release_Channel>;
};

/** on_conflict condition type for table "release_channel" */
export type Release_Channel_On_Conflict = {
  constraint: Release_Channel_Constraint;
  update_columns?: Array<Release_Channel_Update_Column>;
  where?: Maybe<Release_Channel_Bool_Exp>;
};

/** Ordering options when selecting data from "release_channel". */
export type Release_Channel_Order_By = {
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: release_channel */
export type Release_Channel_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "release_channel" */
export const Release_Channel_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Release_Channel_Select_Column = typeof Release_Channel_Select_Column[keyof typeof Release_Channel_Select_Column];
/** input type for updating data in table "release_channel" */
export type Release_Channel_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "release_channel" */
export type Release_Channel_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Release_Channel_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Release_Channel_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "release_channel" */
export const Release_Channel_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Release_Channel_Update_Column = typeof Release_Channel_Update_Column[keyof typeof Release_Channel_Update_Column];
export type Release_Channel_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Release_Channel_Set_Input>;
  /** filter the rows which have to be updated */
  where: Release_Channel_Bool_Exp;
};

/** Table to store retail unit. */
export type Retail_Unit = {
  barcode?: Maybe<Scalars['String']>;
  computed_title?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  height?: Maybe<Scalars['numeric']>;
  id: Scalars['bigint'];
  /** An array relationship */
  inventory_items: Array<Inventory_Item>;
  /** An aggregate relationship */
  inventory_items_aggregate: Inventory_Item_Aggregate;
  is_default: Scalars['Boolean'];
  length?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  /** An object relationship */
  product_variant: Product_Variant;
  product_variant_id: Scalars['bigint'];
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  weight?: Maybe<Scalars['Int']>;
  width?: Maybe<Scalars['numeric']>;
};


/** Table to store retail unit. */
export type Retail_UnitInventory_ItemsArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Order_By>>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};


/** Table to store retail unit. */
export type Retail_UnitInventory_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Order_By>>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};

/** aggregated selection of "retail_unit" */
export type Retail_Unit_Aggregate = {
  aggregate?: Maybe<Retail_Unit_Aggregate_Fields>;
  nodes: Array<Retail_Unit>;
};

export type Retail_Unit_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Retail_Unit_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Retail_Unit_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Retail_Unit_Aggregate_Bool_Exp_Count>;
};

export type Retail_Unit_Aggregate_Bool_Exp_Bool_And = {
  arguments: Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Retail_Unit_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Retail_Unit_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Retail_Unit_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Retail_Unit_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Retail_Unit_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Retail_Unit_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "retail_unit" */
export type Retail_Unit_Aggregate_Fields = {
  avg?: Maybe<Retail_Unit_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Retail_Unit_Max_Fields>;
  min?: Maybe<Retail_Unit_Min_Fields>;
  stddev?: Maybe<Retail_Unit_Stddev_Fields>;
  stddev_pop?: Maybe<Retail_Unit_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Retail_Unit_Stddev_Samp_Fields>;
  sum?: Maybe<Retail_Unit_Sum_Fields>;
  var_pop?: Maybe<Retail_Unit_Var_Pop_Fields>;
  var_samp?: Maybe<Retail_Unit_Var_Samp_Fields>;
  variance?: Maybe<Retail_Unit_Variance_Fields>;
};


/** aggregate fields of "retail_unit" */
export type Retail_Unit_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Retail_Unit_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "retail_unit" */
export type Retail_Unit_Aggregate_Order_By = {
  avg?: Maybe<Retail_Unit_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Retail_Unit_Max_Order_By>;
  min?: Maybe<Retail_Unit_Min_Order_By>;
  stddev?: Maybe<Retail_Unit_Stddev_Order_By>;
  stddev_pop?: Maybe<Retail_Unit_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Retail_Unit_Stddev_Samp_Order_By>;
  sum?: Maybe<Retail_Unit_Sum_Order_By>;
  var_pop?: Maybe<Retail_Unit_Var_Pop_Order_By>;
  var_samp?: Maybe<Retail_Unit_Var_Samp_Order_By>;
  variance?: Maybe<Retail_Unit_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "retail_unit" */
export type Retail_Unit_Arr_Rel_Insert_Input = {
  data: Array<Retail_Unit_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Retail_Unit_On_Conflict>;
};

/** aggregate avg on columns */
export type Retail_Unit_Avg_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  product_variant_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "retail_unit" */
export type Retail_Unit_Avg_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "retail_unit". All fields are combined with a logical 'AND'. */
export type Retail_Unit_Bool_Exp = {
  _and?: Maybe<Array<Retail_Unit_Bool_Exp>>;
  _not?: Maybe<Retail_Unit_Bool_Exp>;
  _or?: Maybe<Array<Retail_Unit_Bool_Exp>>;
  barcode?: Maybe<String_Comparison_Exp>;
  computed_title?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  height?: Maybe<Numeric_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  inventory_items?: Maybe<Inventory_Item_Bool_Exp>;
  inventory_items_aggregate?: Maybe<Inventory_Item_Aggregate_Bool_Exp>;
  is_default?: Maybe<Boolean_Comparison_Exp>;
  length?: Maybe<Numeric_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  product_variant?: Maybe<Product_Variant_Bool_Exp>;
  product_variant_id?: Maybe<Bigint_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  weight?: Maybe<Int_Comparison_Exp>;
  width?: Maybe<Numeric_Comparison_Exp>;
};

/** unique or primary key constraints on table "retail_unit" */
export const Retail_Unit_Constraint = {
  /** unique or primary key constraint on columns "id" */
  RetailUnitPk: 'retail_unit_pk',
  /** unique or primary key constraint on columns "product_variant_id", "is_default" */
  RetailUnitProductVariantIdIsDefaultTrueKey: 'retail_unit_product_variant_id_is_default_true_key'
} as const;

export type Retail_Unit_Constraint = typeof Retail_Unit_Constraint[keyof typeof Retail_Unit_Constraint];
/** input type for incrementing numeric columns in table "retail_unit" */
export type Retail_Unit_Inc_Input = {
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  length?: Maybe<Scalars['numeric']>;
  product_variant_id?: Maybe<Scalars['bigint']>;
  weight?: Maybe<Scalars['Int']>;
  width?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "retail_unit" */
export type Retail_Unit_Insert_Input = {
  barcode?: Maybe<Scalars['String']>;
  computed_title?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  inventory_items?: Maybe<Inventory_Item_Arr_Rel_Insert_Input>;
  is_default?: Maybe<Scalars['Boolean']>;
  length?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  product_variant?: Maybe<Product_Variant_Obj_Rel_Insert_Input>;
  product_variant_id?: Maybe<Scalars['bigint']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['Int']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type Retail_Unit_Max_Fields = {
  barcode?: Maybe<Scalars['String']>;
  computed_title?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  length?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  product_variant_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['Int']>;
  width?: Maybe<Scalars['numeric']>;
};

/** order by max() on columns of table "retail_unit" */
export type Retail_Unit_Max_Order_By = {
  barcode?: Maybe<Order_By>;
  computed_title?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Retail_Unit_Min_Fields = {
  barcode?: Maybe<Scalars['String']>;
  computed_title?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  length?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  product_variant_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['Int']>;
  width?: Maybe<Scalars['numeric']>;
};

/** order by min() on columns of table "retail_unit" */
export type Retail_Unit_Min_Order_By = {
  barcode?: Maybe<Order_By>;
  computed_title?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** response of any mutation on the table "retail_unit" */
export type Retail_Unit_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Retail_Unit>;
};

/** input type for inserting object relation for remote table "retail_unit" */
export type Retail_Unit_Obj_Rel_Insert_Input = {
  data: Retail_Unit_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Retail_Unit_On_Conflict>;
};

/** on_conflict condition type for table "retail_unit" */
export type Retail_Unit_On_Conflict = {
  constraint: Retail_Unit_Constraint;
  update_columns?: Array<Retail_Unit_Update_Column>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};

/** Ordering options when selecting data from "retail_unit". */
export type Retail_Unit_Order_By = {
  barcode?: Maybe<Order_By>;
  computed_title?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  inventory_items_aggregate?: Maybe<Inventory_Item_Aggregate_Order_By>;
  is_default?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  product_variant?: Maybe<Product_Variant_Order_By>;
  product_variant_id?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** primary key columns input for table: retail_unit */
export type Retail_Unit_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "retail_unit" */
export const Retail_Unit_Select_Column = {
  /** column name */
  Barcode: 'barcode',
  /** column name */
  ComputedTitle: 'computed_title',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Height: 'height',
  /** column name */
  Id: 'id',
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  Length: 'length',
  /** column name */
  Name: 'name',
  /** column name */
  ProductVariantId: 'product_variant_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  Weight: 'weight',
  /** column name */
  Width: 'width'
} as const;

export type Retail_Unit_Select_Column = typeof Retail_Unit_Select_Column[keyof typeof Retail_Unit_Select_Column];
/** select "retail_unit_aggregate_bool_exp_bool_and_arguments_columns" columns of table "retail_unit" */
export const Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  IsDefault: 'is_default'
} as const;

export type Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "retail_unit_aggregate_bool_exp_bool_or_arguments_columns" columns of table "retail_unit" */
export const Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  IsDefault: 'is_default'
} as const;

export type Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Retail_Unit_Select_Column_Retail_Unit_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "retail_unit" */
export type Retail_Unit_Set_Input = {
  barcode?: Maybe<Scalars['String']>;
  computed_title?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  is_default?: Maybe<Scalars['Boolean']>;
  length?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  product_variant_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['Int']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type Retail_Unit_Stddev_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  product_variant_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "retail_unit" */
export type Retail_Unit_Stddev_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Retail_Unit_Stddev_Pop_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  product_variant_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "retail_unit" */
export type Retail_Unit_Stddev_Pop_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Retail_Unit_Stddev_Samp_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  product_variant_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "retail_unit" */
export type Retail_Unit_Stddev_Samp_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** Streaming cursor of the table "retail_unit" */
export type Retail_Unit_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Retail_Unit_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Retail_Unit_Stream_Cursor_Value_Input = {
  barcode?: Maybe<Scalars['String']>;
  computed_title?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  is_default?: Maybe<Scalars['Boolean']>;
  length?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  product_variant_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['Int']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type Retail_Unit_Sum_Fields = {
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  length?: Maybe<Scalars['numeric']>;
  product_variant_id?: Maybe<Scalars['bigint']>;
  weight?: Maybe<Scalars['Int']>;
  width?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "retail_unit" */
export type Retail_Unit_Sum_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** update columns of table "retail_unit" */
export const Retail_Unit_Update_Column = {
  /** column name */
  Barcode: 'barcode',
  /** column name */
  ComputedTitle: 'computed_title',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Height: 'height',
  /** column name */
  Id: 'id',
  /** column name */
  IsDefault: 'is_default',
  /** column name */
  Length: 'length',
  /** column name */
  Name: 'name',
  /** column name */
  ProductVariantId: 'product_variant_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  Weight: 'weight',
  /** column name */
  Width: 'width'
} as const;

export type Retail_Unit_Update_Column = typeof Retail_Unit_Update_Column[keyof typeof Retail_Unit_Update_Column];
export type Retail_Unit_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Retail_Unit_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Retail_Unit_Set_Input>;
  /** filter the rows which have to be updated */
  where: Retail_Unit_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Retail_Unit_Var_Pop_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  product_variant_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "retail_unit" */
export type Retail_Unit_Var_Pop_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Retail_Unit_Var_Samp_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  product_variant_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "retail_unit" */
export type Retail_Unit_Var_Samp_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Retail_Unit_Variance_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  product_variant_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "retail_unit" */
export type Retail_Unit_Variance_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  product_variant_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** columns and relationships of "sales_channel" */
export type Sales_Channel = {
  comment?: Maybe<Scalars['String']>;
  /** An array relationship */
  sales_orders: Array<Sales_Order>;
  /** An aggregate relationship */
  sales_orders_aggregate: Sales_Order_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "sales_channel" */
export type Sales_ChannelSales_OrdersArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "sales_channel" */
export type Sales_ChannelSales_Orders_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};

/** aggregated selection of "sales_channel" */
export type Sales_Channel_Aggregate = {
  aggregate?: Maybe<Sales_Channel_Aggregate_Fields>;
  nodes: Array<Sales_Channel>;
};

/** aggregate fields of "sales_channel" */
export type Sales_Channel_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Sales_Channel_Max_Fields>;
  min?: Maybe<Sales_Channel_Min_Fields>;
};


/** aggregate fields of "sales_channel" */
export type Sales_Channel_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Sales_Channel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "sales_channel". All fields are combined with a logical 'AND'. */
export type Sales_Channel_Bool_Exp = {
  _and?: Maybe<Array<Sales_Channel_Bool_Exp>>;
  _not?: Maybe<Sales_Channel_Bool_Exp>;
  _or?: Maybe<Array<Sales_Channel_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  sales_orders?: Maybe<Sales_Order_Bool_Exp>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "sales_channel" */
export const Sales_Channel_Constraint = {
  /** unique or primary key constraint on columns "value" */
  SalesChannelPkey: 'sales_channel_pkey'
} as const;

export type Sales_Channel_Constraint = typeof Sales_Channel_Constraint[keyof typeof Sales_Channel_Constraint];
export const Sales_Channel_Enum = {
  Shopify: 'SHOPIFY',
  Skutopia: 'SKUTOPIA'
} as const;

export type Sales_Channel_Enum = typeof Sales_Channel_Enum[keyof typeof Sales_Channel_Enum];
/** Boolean expression to compare columns of type "sales_channel_enum". All fields are combined with logical 'AND'. */
export type Sales_Channel_Enum_Comparison_Exp = {
  _eq?: Maybe<Sales_Channel_Enum>;
  _in?: Maybe<Array<Sales_Channel_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Sales_Channel_Enum>;
  _nin?: Maybe<Array<Sales_Channel_Enum>>;
};

/** input type for inserting data into table "sales_channel" */
export type Sales_Channel_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  sales_orders?: Maybe<Sales_Order_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Sales_Channel_Max_Fields = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Sales_Channel_Min_Fields = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "sales_channel" */
export type Sales_Channel_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Sales_Channel>;
};

/** input type for inserting object relation for remote table "sales_channel" */
export type Sales_Channel_Obj_Rel_Insert_Input = {
  data: Sales_Channel_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Sales_Channel_On_Conflict>;
};

/** on_conflict condition type for table "sales_channel" */
export type Sales_Channel_On_Conflict = {
  constraint: Sales_Channel_Constraint;
  update_columns?: Array<Sales_Channel_Update_Column>;
  where?: Maybe<Sales_Channel_Bool_Exp>;
};

/** Ordering options when selecting data from "sales_channel". */
export type Sales_Channel_Order_By = {
  comment?: Maybe<Order_By>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: sales_channel */
export type Sales_Channel_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "sales_channel" */
export const Sales_Channel_Select_Column = {
  /** column name */
  Comment: 'comment',
  /** column name */
  Value: 'value'
} as const;

export type Sales_Channel_Select_Column = typeof Sales_Channel_Select_Column[keyof typeof Sales_Channel_Select_Column];
/** input type for updating data in table "sales_channel" */
export type Sales_Channel_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "sales_channel" */
export type Sales_Channel_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Sales_Channel_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Sales_Channel_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "sales_channel" */
export const Sales_Channel_Update_Column = {
  /** column name */
  Comment: 'comment',
  /** column name */
  Value: 'value'
} as const;

export type Sales_Channel_Update_Column = typeof Sales_Channel_Update_Column[keyof typeof Sales_Channel_Update_Column];
export type Sales_Channel_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Sales_Channel_Set_Input>;
  /** filter the rows which have to be updated */
  where: Sales_Channel_Bool_Exp;
};

/** columns and relationships of "sales_order" */
export type Sales_Order = {
  /** An object relationship */
  billing_address?: Maybe<Address>;
  billing_address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  customer?: Maybe<Customer>;
  customer_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  draft_fulfilment_shipment?: Maybe<Draft_Fulfilment_Shipment>;
  first_name?: Maybe<Scalars['String']>;
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  id: Scalars['uuid'];
  last_name?: Maybe<Scalars['String']>;
  line_items?: Maybe<Scalars['jsonb']>;
  note?: Maybe<Scalars['String']>;
  order_reference?: Maybe<Scalars['String']>;
  packaging_rule_id?: Maybe<Scalars['uuid']>;
  packing_status: Packing_Status_Enum;
  /** An object relationship */
  packing_status_by_packing_status: Packing_Status;
  payment_status: Payment_Status_Enum;
  /** An object relationship */
  payment_status_by_payment_status: Payment_Status;
  pick_cost: Scalars['Int'];
  /** An object relationship */
  sales_channel?: Maybe<Sales_Channel>;
  /** An array relationship */
  sales_order_line_items: Array<Sales_Order_Line_Item>;
  /** An aggregate relationship */
  sales_order_line_items_aggregate: Sales_Order_Line_Item_Aggregate;
  /** An array relationship */
  sales_order_shipment_charges: Array<Sales_Order_Shipment_Charge>;
  /** An aggregate relationship */
  sales_order_shipment_charges_aggregate: Sales_Order_Shipment_Charge_Aggregate;
  /** An object relationship */
  sales_order_status: Sales_Order_Status;
  /** An array relationship */
  sales_order_tags: Array<Sales_Order_Tag>;
  /** An aggregate relationship */
  sales_order_tags_aggregate: Sales_Order_Tag_Aggregate;
  /** An object relationship */
  shipping_address?: Maybe<Address>;
  shipping_address_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Sales_Channel_Enum>;
  status: Sales_Order_Status_Enum;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  total_cost: Scalars['Int'];
  total_price: Scalars['Int'];
  total_weight_gram: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "sales_order" */
export type Sales_OrderFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "sales_order" */
export type Sales_OrderFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "sales_order" */
export type Sales_OrderLine_ItemsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "sales_order" */
export type Sales_OrderSales_Order_Line_ItemsArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Line_Item_Order_By>>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};


/** columns and relationships of "sales_order" */
export type Sales_OrderSales_Order_Line_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Line_Item_Order_By>>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};


/** columns and relationships of "sales_order" */
export type Sales_OrderSales_Order_Shipment_ChargesArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Shipment_Charge_Order_By>>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};


/** columns and relationships of "sales_order" */
export type Sales_OrderSales_Order_Shipment_Charges_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Shipment_Charge_Order_By>>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};


/** columns and relationships of "sales_order" */
export type Sales_OrderSales_Order_TagsArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Tag_Order_By>>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};


/** columns and relationships of "sales_order" */
export type Sales_OrderSales_Order_Tags_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Tag_Order_By>>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};

/** aggregated selection of "sales_order" */
export type Sales_Order_Aggregate = {
  aggregate?: Maybe<Sales_Order_Aggregate_Fields>;
  nodes: Array<Sales_Order>;
};

export type Sales_Order_Aggregate_Bool_Exp = {
  count?: Maybe<Sales_Order_Aggregate_Bool_Exp_Count>;
};

export type Sales_Order_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Sales_Order_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Sales_Order_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "sales_order" */
export type Sales_Order_Aggregate_Fields = {
  avg?: Maybe<Sales_Order_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Sales_Order_Max_Fields>;
  min?: Maybe<Sales_Order_Min_Fields>;
  stddev?: Maybe<Sales_Order_Stddev_Fields>;
  stddev_pop?: Maybe<Sales_Order_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Sales_Order_Stddev_Samp_Fields>;
  sum?: Maybe<Sales_Order_Sum_Fields>;
  var_pop?: Maybe<Sales_Order_Var_Pop_Fields>;
  var_samp?: Maybe<Sales_Order_Var_Samp_Fields>;
  variance?: Maybe<Sales_Order_Variance_Fields>;
};


/** aggregate fields of "sales_order" */
export type Sales_Order_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Sales_Order_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "sales_order" */
export type Sales_Order_Aggregate_Order_By = {
  avg?: Maybe<Sales_Order_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Sales_Order_Max_Order_By>;
  min?: Maybe<Sales_Order_Min_Order_By>;
  stddev?: Maybe<Sales_Order_Stddev_Order_By>;
  stddev_pop?: Maybe<Sales_Order_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Sales_Order_Stddev_Samp_Order_By>;
  sum?: Maybe<Sales_Order_Sum_Order_By>;
  var_pop?: Maybe<Sales_Order_Var_Pop_Order_By>;
  var_samp?: Maybe<Sales_Order_Var_Samp_Order_By>;
  variance?: Maybe<Sales_Order_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Sales_Order_Append_Input = {
  line_items?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "sales_order" */
export type Sales_Order_Arr_Rel_Insert_Input = {
  data: Array<Sales_Order_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Sales_Order_On_Conflict>;
};

/** aggregate avg on columns */
export type Sales_Order_Avg_Fields = {
  pick_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
  total_weight_gram?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "sales_order" */
export type Sales_Order_Avg_Order_By = {
  pick_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "sales_order". All fields are combined with a logical 'AND'. */
export type Sales_Order_Bool_Exp = {
  _and?: Maybe<Array<Sales_Order_Bool_Exp>>;
  _not?: Maybe<Sales_Order_Bool_Exp>;
  _or?: Maybe<Array<Sales_Order_Bool_Exp>>;
  billing_address?: Maybe<Address_Bool_Exp>;
  billing_address_id?: Maybe<Uuid_Comparison_Exp>;
  contact_number?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customer?: Maybe<Customer_Bool_Exp>;
  customer_id?: Maybe<Uuid_Comparison_Exp>;
  draft_fulfilment_shipment?: Maybe<Draft_Fulfilment_Shipment_Bool_Exp>;
  first_name?: Maybe<String_Comparison_Exp>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  last_name?: Maybe<String_Comparison_Exp>;
  line_items?: Maybe<Jsonb_Comparison_Exp>;
  note?: Maybe<String_Comparison_Exp>;
  order_reference?: Maybe<String_Comparison_Exp>;
  packaging_rule_id?: Maybe<Uuid_Comparison_Exp>;
  packing_status?: Maybe<Packing_Status_Enum_Comparison_Exp>;
  packing_status_by_packing_status?: Maybe<Packing_Status_Bool_Exp>;
  payment_status?: Maybe<Payment_Status_Enum_Comparison_Exp>;
  payment_status_by_payment_status?: Maybe<Payment_Status_Bool_Exp>;
  pick_cost?: Maybe<Int_Comparison_Exp>;
  sales_channel?: Maybe<Sales_Channel_Bool_Exp>;
  sales_order_line_items?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
  sales_order_line_items_aggregate?: Maybe<Sales_Order_Line_Item_Aggregate_Bool_Exp>;
  sales_order_shipment_charges?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
  sales_order_shipment_charges_aggregate?: Maybe<Sales_Order_Shipment_Charge_Aggregate_Bool_Exp>;
  sales_order_status?: Maybe<Sales_Order_Status_Bool_Exp>;
  sales_order_tags?: Maybe<Sales_Order_Tag_Bool_Exp>;
  sales_order_tags_aggregate?: Maybe<Sales_Order_Tag_Aggregate_Bool_Exp>;
  shipping_address?: Maybe<Address_Bool_Exp>;
  shipping_address_id?: Maybe<Uuid_Comparison_Exp>;
  source?: Maybe<Sales_Channel_Enum_Comparison_Exp>;
  status?: Maybe<Sales_Order_Status_Enum_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  total_cost?: Maybe<Int_Comparison_Exp>;
  total_price?: Maybe<Int_Comparison_Exp>;
  total_weight_gram?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "sales_order" */
export const Sales_Order_Constraint = {
  /** unique or primary key constraint on columns "id" */
  SalesOrderPkey: 'sales_order_pkey'
} as const;

export type Sales_Order_Constraint = typeof Sales_Order_Constraint[keyof typeof Sales_Order_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Sales_Order_Delete_At_Path_Input = {
  line_items?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Sales_Order_Delete_Elem_Input = {
  line_items?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Sales_Order_Delete_Key_Input = {
  line_items?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "sales_order" */
export type Sales_Order_Inc_Input = {
  pick_cost?: Maybe<Scalars['Int']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['Int']>;
  total_weight_gram?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "sales_order" */
export type Sales_Order_Insert_Input = {
  billing_address?: Maybe<Address_Obj_Rel_Insert_Input>;
  billing_address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer?: Maybe<Customer_Obj_Rel_Insert_Input>;
  customer_id?: Maybe<Scalars['uuid']>;
  draft_fulfilment_shipment?: Maybe<Draft_Fulfilment_Shipment_Obj_Rel_Insert_Input>;
  first_name?: Maybe<Scalars['String']>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  line_items?: Maybe<Scalars['jsonb']>;
  note?: Maybe<Scalars['String']>;
  order_reference?: Maybe<Scalars['String']>;
  packaging_rule_id?: Maybe<Scalars['uuid']>;
  packing_status?: Maybe<Packing_Status_Enum>;
  packing_status_by_packing_status?: Maybe<Packing_Status_Obj_Rel_Insert_Input>;
  payment_status?: Maybe<Payment_Status_Enum>;
  payment_status_by_payment_status?: Maybe<Payment_Status_Obj_Rel_Insert_Input>;
  pick_cost?: Maybe<Scalars['Int']>;
  sales_channel?: Maybe<Sales_Channel_Obj_Rel_Insert_Input>;
  sales_order_line_items?: Maybe<Sales_Order_Line_Item_Arr_Rel_Insert_Input>;
  sales_order_shipment_charges?: Maybe<Sales_Order_Shipment_Charge_Arr_Rel_Insert_Input>;
  sales_order_status?: Maybe<Sales_Order_Status_Obj_Rel_Insert_Input>;
  sales_order_tags?: Maybe<Sales_Order_Tag_Arr_Rel_Insert_Input>;
  shipping_address?: Maybe<Address_Obj_Rel_Insert_Input>;
  shipping_address_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Sales_Channel_Enum>;
  status?: Maybe<Sales_Order_Status_Enum>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['Int']>;
  total_weight_gram?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "sales_order_integration" */
export type Sales_Order_Integration = {
  created_at: Scalars['timestamptz'];
  external_entity_id: Scalars['String'];
  id: Scalars['bigint'];
  integration_id: Scalars['bigint'];
  sales_order_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "sales_order_integration" */
export type Sales_Order_Integration_Aggregate = {
  aggregate?: Maybe<Sales_Order_Integration_Aggregate_Fields>;
  nodes: Array<Sales_Order_Integration>;
};

/** aggregate fields of "sales_order_integration" */
export type Sales_Order_Integration_Aggregate_Fields = {
  avg?: Maybe<Sales_Order_Integration_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Sales_Order_Integration_Max_Fields>;
  min?: Maybe<Sales_Order_Integration_Min_Fields>;
  stddev?: Maybe<Sales_Order_Integration_Stddev_Fields>;
  stddev_pop?: Maybe<Sales_Order_Integration_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Sales_Order_Integration_Stddev_Samp_Fields>;
  sum?: Maybe<Sales_Order_Integration_Sum_Fields>;
  var_pop?: Maybe<Sales_Order_Integration_Var_Pop_Fields>;
  var_samp?: Maybe<Sales_Order_Integration_Var_Samp_Fields>;
  variance?: Maybe<Sales_Order_Integration_Variance_Fields>;
};


/** aggregate fields of "sales_order_integration" */
export type Sales_Order_Integration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Sales_Order_Integration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Sales_Order_Integration_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "sales_order_integration". All fields are combined with a logical 'AND'. */
export type Sales_Order_Integration_Bool_Exp = {
  _and?: Maybe<Array<Sales_Order_Integration_Bool_Exp>>;
  _not?: Maybe<Sales_Order_Integration_Bool_Exp>;
  _or?: Maybe<Array<Sales_Order_Integration_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  external_entity_id?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  integration_id?: Maybe<Bigint_Comparison_Exp>;
  sales_order_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "sales_order_integration" */
export const Sales_Order_Integration_Constraint = {
  /** unique or primary key constraint on columns "external_entity_id", "integration_id" */
  SalesOrderIntegrationIntegrationIdExternalEntityId: 'sales_order_integration_integration_id_external_entity_id',
  /** unique or primary key constraint on columns "id" */
  SalesOrderIntegrationPk: 'sales_order_integration_pk'
} as const;

export type Sales_Order_Integration_Constraint = typeof Sales_Order_Integration_Constraint[keyof typeof Sales_Order_Integration_Constraint];
/** input type for incrementing numeric columns in table "sales_order_integration" */
export type Sales_Order_Integration_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "sales_order_integration" */
export type Sales_Order_Integration_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Sales_Order_Integration_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Sales_Order_Integration_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "sales_order_integration" */
export type Sales_Order_Integration_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Sales_Order_Integration>;
};

/** on_conflict condition type for table "sales_order_integration" */
export type Sales_Order_Integration_On_Conflict = {
  constraint: Sales_Order_Integration_Constraint;
  update_columns?: Array<Sales_Order_Integration_Update_Column>;
  where?: Maybe<Sales_Order_Integration_Bool_Exp>;
};

/** Ordering options when selecting data from "sales_order_integration". */
export type Sales_Order_Integration_Order_By = {
  created_at?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  integration_id?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: sales_order_integration */
export type Sales_Order_Integration_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "sales_order_integration" */
export const Sales_Order_Integration_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  IntegrationId: 'integration_id',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Sales_Order_Integration_Select_Column = typeof Sales_Order_Integration_Select_Column[keyof typeof Sales_Order_Integration_Select_Column];
/** input type for updating data in table "sales_order_integration" */
export type Sales_Order_Integration_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Sales_Order_Integration_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Sales_Order_Integration_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Sales_Order_Integration_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "sales_order_integration" */
export type Sales_Order_Integration_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Sales_Order_Integration_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Sales_Order_Integration_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Sales_Order_Integration_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  integration_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "sales_order_integration" */
export const Sales_Order_Integration_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  IntegrationId: 'integration_id',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Sales_Order_Integration_Update_Column = typeof Sales_Order_Integration_Update_Column[keyof typeof Sales_Order_Integration_Update_Column];
export type Sales_Order_Integration_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Sales_Order_Integration_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Sales_Order_Integration_Set_Input>;
  /** filter the rows which have to be updated */
  where: Sales_Order_Integration_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Sales_Order_Integration_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Sales_Order_Integration_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Sales_Order_Integration_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  integration_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "sales_order_line_item" */
export type Sales_Order_Line_Item = {
  barcode?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  customs_info?: Maybe<Scalars['jsonb']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  image_url?: Maybe<Scalars['String']>;
  integrations: Scalars['jsonb'];
  is_digital: Scalars['Boolean'];
  name: Scalars['String'];
  original_response?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  packingStatusByPackingStatus: Packing_Status;
  packing_status: Packing_Status_Enum;
  parent_line_item_id?: Maybe<Scalars['uuid']>;
  price: Scalars['Int'];
  price_currency_code: Scalars['String'];
  quantity: Scalars['Int'];
  quantity_fulfillable: Scalars['Int'];
  quantity_packed: Scalars['Int'];
  /** An object relationship */
  sales_order: Sales_Order;
  sales_order_id: Scalars['uuid'];
  sku?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  variant_title?: Maybe<Scalars['String']>;
  vendor?: Maybe<Scalars['String']>;
  weight_gram: Scalars['Int'];
};


/** columns and relationships of "sales_order_line_item" */
export type Sales_Order_Line_ItemCustoms_InfoArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "sales_order_line_item" */
export type Sales_Order_Line_ItemIntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "sales_order_line_item" */
export type Sales_Order_Line_ItemOriginal_ResponseArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "sales_order_line_item" */
export type Sales_Order_Line_Item_Aggregate = {
  aggregate?: Maybe<Sales_Order_Line_Item_Aggregate_Fields>;
  nodes: Array<Sales_Order_Line_Item>;
};

export type Sales_Order_Line_Item_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Sales_Order_Line_Item_Aggregate_Bool_Exp_Count>;
};

export type Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_And = {
  arguments: Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Sales_Order_Line_Item_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "sales_order_line_item" */
export type Sales_Order_Line_Item_Aggregate_Fields = {
  avg?: Maybe<Sales_Order_Line_Item_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Sales_Order_Line_Item_Max_Fields>;
  min?: Maybe<Sales_Order_Line_Item_Min_Fields>;
  stddev?: Maybe<Sales_Order_Line_Item_Stddev_Fields>;
  stddev_pop?: Maybe<Sales_Order_Line_Item_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Sales_Order_Line_Item_Stddev_Samp_Fields>;
  sum?: Maybe<Sales_Order_Line_Item_Sum_Fields>;
  var_pop?: Maybe<Sales_Order_Line_Item_Var_Pop_Fields>;
  var_samp?: Maybe<Sales_Order_Line_Item_Var_Samp_Fields>;
  variance?: Maybe<Sales_Order_Line_Item_Variance_Fields>;
};


/** aggregate fields of "sales_order_line_item" */
export type Sales_Order_Line_Item_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Aggregate_Order_By = {
  avg?: Maybe<Sales_Order_Line_Item_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Sales_Order_Line_Item_Max_Order_By>;
  min?: Maybe<Sales_Order_Line_Item_Min_Order_By>;
  stddev?: Maybe<Sales_Order_Line_Item_Stddev_Order_By>;
  stddev_pop?: Maybe<Sales_Order_Line_Item_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Sales_Order_Line_Item_Stddev_Samp_Order_By>;
  sum?: Maybe<Sales_Order_Line_Item_Sum_Order_By>;
  var_pop?: Maybe<Sales_Order_Line_Item_Var_Pop_Order_By>;
  var_samp?: Maybe<Sales_Order_Line_Item_Var_Samp_Order_By>;
  variance?: Maybe<Sales_Order_Line_Item_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Sales_Order_Line_Item_Append_Input = {
  customs_info?: Maybe<Scalars['jsonb']>;
  integrations?: Maybe<Scalars['jsonb']>;
  original_response?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "sales_order_line_item" */
export type Sales_Order_Line_Item_Arr_Rel_Insert_Input = {
  data: Array<Sales_Order_Line_Item_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Sales_Order_Line_Item_On_Conflict>;
};

/** aggregate avg on columns */
export type Sales_Order_Line_Item_Avg_Fields = {
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_fulfillable?: Maybe<Scalars['Float']>;
  quantity_packed?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Avg_Order_By = {
  price?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "sales_order_line_item". All fields are combined with a logical 'AND'. */
export type Sales_Order_Line_Item_Bool_Exp = {
  _and?: Maybe<Array<Sales_Order_Line_Item_Bool_Exp>>;
  _not?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
  _or?: Maybe<Array<Sales_Order_Line_Item_Bool_Exp>>;
  barcode?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customs_info?: Maybe<Jsonb_Comparison_Exp>;
  fulfilment_service?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  image_url?: Maybe<String_Comparison_Exp>;
  integrations?: Maybe<Jsonb_Comparison_Exp>;
  is_digital?: Maybe<Boolean_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  original_response?: Maybe<Jsonb_Comparison_Exp>;
  packingStatusByPackingStatus?: Maybe<Packing_Status_Bool_Exp>;
  packing_status?: Maybe<Packing_Status_Enum_Comparison_Exp>;
  parent_line_item_id?: Maybe<Uuid_Comparison_Exp>;
  price?: Maybe<Int_Comparison_Exp>;
  price_currency_code?: Maybe<String_Comparison_Exp>;
  quantity?: Maybe<Int_Comparison_Exp>;
  quantity_fulfillable?: Maybe<Int_Comparison_Exp>;
  quantity_packed?: Maybe<Int_Comparison_Exp>;
  sales_order?: Maybe<Sales_Order_Bool_Exp>;
  sales_order_id?: Maybe<Uuid_Comparison_Exp>;
  sku?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  variant_title?: Maybe<String_Comparison_Exp>;
  vendor?: Maybe<String_Comparison_Exp>;
  weight_gram?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "sales_order_line_item" */
export const Sales_Order_Line_Item_Constraint = {
  /** unique or primary key constraint on columns "id" */
  SalesOrderLineItemPkey: 'sales_order_line_item_pkey'
} as const;

export type Sales_Order_Line_Item_Constraint = typeof Sales_Order_Line_Item_Constraint[keyof typeof Sales_Order_Line_Item_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Sales_Order_Line_Item_Delete_At_Path_Input = {
  customs_info?: Maybe<Array<Scalars['String']>>;
  integrations?: Maybe<Array<Scalars['String']>>;
  original_response?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Sales_Order_Line_Item_Delete_Elem_Input = {
  customs_info?: Maybe<Scalars['Int']>;
  integrations?: Maybe<Scalars['Int']>;
  original_response?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Sales_Order_Line_Item_Delete_Key_Input = {
  customs_info?: Maybe<Scalars['String']>;
  integrations?: Maybe<Scalars['String']>;
  original_response?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "sales_order_line_item" */
export type Sales_Order_Line_Item_Inc_Input = {
  price?: Maybe<Scalars['Int']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_fulfillable?: Maybe<Scalars['Int']>;
  quantity_packed?: Maybe<Scalars['Int']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "sales_order_line_item" */
export type Sales_Order_Line_Item_Insert_Input = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customs_info?: Maybe<Scalars['jsonb']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  integrations?: Maybe<Scalars['jsonb']>;
  is_digital?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  original_response?: Maybe<Scalars['jsonb']>;
  packingStatusByPackingStatus?: Maybe<Packing_Status_Obj_Rel_Insert_Input>;
  packing_status?: Maybe<Packing_Status_Enum>;
  parent_line_item_id?: Maybe<Scalars['uuid']>;
  price?: Maybe<Scalars['Int']>;
  price_currency_code?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_fulfillable?: Maybe<Scalars['Int']>;
  quantity_packed?: Maybe<Scalars['Int']>;
  sales_order?: Maybe<Sales_Order_Obj_Rel_Insert_Input>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  variant_title?: Maybe<Scalars['String']>;
  vendor?: Maybe<Scalars['String']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Sales_Order_Line_Item_Max_Fields = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  parent_line_item_id?: Maybe<Scalars['uuid']>;
  price?: Maybe<Scalars['Int']>;
  price_currency_code?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_fulfillable?: Maybe<Scalars['Int']>;
  quantity_packed?: Maybe<Scalars['Int']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  variant_title?: Maybe<Scalars['String']>;
  vendor?: Maybe<Scalars['String']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Max_Order_By = {
  barcode?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fulfilment_service?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  parent_line_item_id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_currency_code?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  sku?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  variant_title?: Maybe<Order_By>;
  vendor?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Sales_Order_Line_Item_Min_Fields = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  parent_line_item_id?: Maybe<Scalars['uuid']>;
  price?: Maybe<Scalars['Int']>;
  price_currency_code?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_fulfillable?: Maybe<Scalars['Int']>;
  quantity_packed?: Maybe<Scalars['Int']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  variant_title?: Maybe<Scalars['String']>;
  vendor?: Maybe<Scalars['String']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Min_Order_By = {
  barcode?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  fulfilment_service?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  parent_line_item_id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_currency_code?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  sku?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  variant_title?: Maybe<Order_By>;
  vendor?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** response of any mutation on the table "sales_order_line_item" */
export type Sales_Order_Line_Item_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Sales_Order_Line_Item>;
};

/** input type for inserting object relation for remote table "sales_order_line_item" */
export type Sales_Order_Line_Item_Obj_Rel_Insert_Input = {
  data: Sales_Order_Line_Item_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Sales_Order_Line_Item_On_Conflict>;
};

/** on_conflict condition type for table "sales_order_line_item" */
export type Sales_Order_Line_Item_On_Conflict = {
  constraint: Sales_Order_Line_Item_Constraint;
  update_columns?: Array<Sales_Order_Line_Item_Update_Column>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};

/** Ordering options when selecting data from "sales_order_line_item". */
export type Sales_Order_Line_Item_Order_By = {
  barcode?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customs_info?: Maybe<Order_By>;
  fulfilment_service?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  integrations?: Maybe<Order_By>;
  is_digital?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  original_response?: Maybe<Order_By>;
  packingStatusByPackingStatus?: Maybe<Packing_Status_Order_By>;
  packing_status?: Maybe<Order_By>;
  parent_line_item_id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_currency_code?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  sales_order?: Maybe<Sales_Order_Order_By>;
  sales_order_id?: Maybe<Order_By>;
  sku?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  variant_title?: Maybe<Order_By>;
  vendor?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** primary key columns input for table: sales_order_line_item */
export type Sales_Order_Line_Item_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Sales_Order_Line_Item_Prepend_Input = {
  customs_info?: Maybe<Scalars['jsonb']>;
  integrations?: Maybe<Scalars['jsonb']>;
  original_response?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "sales_order_line_item" */
export const Sales_Order_Line_Item_Select_Column = {
  /** column name */
  Barcode: 'barcode',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  CustomsInfo: 'customs_info',
  /** column name */
  FulfilmentService: 'fulfilment_service',
  /** column name */
  Id: 'id',
  /** column name */
  ImageUrl: 'image_url',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  IsDigital: 'is_digital',
  /** column name */
  Name: 'name',
  /** column name */
  OriginalResponse: 'original_response',
  /** column name */
  PackingStatus: 'packing_status',
  /** column name */
  ParentLineItemId: 'parent_line_item_id',
  /** column name */
  Price: 'price',
  /** column name */
  PriceCurrencyCode: 'price_currency_code',
  /** column name */
  Quantity: 'quantity',
  /** column name */
  QuantityFulfillable: 'quantity_fulfillable',
  /** column name */
  QuantityPacked: 'quantity_packed',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  Sku: 'sku',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  VariantTitle: 'variant_title',
  /** column name */
  Vendor: 'vendor',
  /** column name */
  WeightGram: 'weight_gram'
} as const;

export type Sales_Order_Line_Item_Select_Column = typeof Sales_Order_Line_Item_Select_Column[keyof typeof Sales_Order_Line_Item_Select_Column];
/** select "sales_order_line_item_aggregate_bool_exp_bool_and_arguments_columns" columns of table "sales_order_line_item" */
export const Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  IsDigital: 'is_digital'
} as const;

export type Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "sales_order_line_item_aggregate_bool_exp_bool_or_arguments_columns" columns of table "sales_order_line_item" */
export const Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  IsDigital: 'is_digital'
} as const;

export type Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Sales_Order_Line_Item_Select_Column_Sales_Order_Line_Item_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "sales_order_line_item" */
export type Sales_Order_Line_Item_Set_Input = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customs_info?: Maybe<Scalars['jsonb']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  integrations?: Maybe<Scalars['jsonb']>;
  is_digital?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  original_response?: Maybe<Scalars['jsonb']>;
  packing_status?: Maybe<Packing_Status_Enum>;
  parent_line_item_id?: Maybe<Scalars['uuid']>;
  price?: Maybe<Scalars['Int']>;
  price_currency_code?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_fulfillable?: Maybe<Scalars['Int']>;
  quantity_packed?: Maybe<Scalars['Int']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  variant_title?: Maybe<Scalars['String']>;
  vendor?: Maybe<Scalars['String']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Sales_Order_Line_Item_Stddev_Fields = {
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_fulfillable?: Maybe<Scalars['Float']>;
  quantity_packed?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Stddev_Order_By = {
  price?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Sales_Order_Line_Item_Stddev_Pop_Fields = {
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_fulfillable?: Maybe<Scalars['Float']>;
  quantity_packed?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Stddev_Pop_Order_By = {
  price?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Sales_Order_Line_Item_Stddev_Samp_Fields = {
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_fulfillable?: Maybe<Scalars['Float']>;
  quantity_packed?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Stddev_Samp_Order_By = {
  price?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** Streaming cursor of the table "sales_order_line_item" */
export type Sales_Order_Line_Item_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Sales_Order_Line_Item_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Sales_Order_Line_Item_Stream_Cursor_Value_Input = {
  barcode?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customs_info?: Maybe<Scalars['jsonb']>;
  fulfilment_service?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  integrations?: Maybe<Scalars['jsonb']>;
  is_digital?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  original_response?: Maybe<Scalars['jsonb']>;
  packing_status?: Maybe<Packing_Status_Enum>;
  parent_line_item_id?: Maybe<Scalars['uuid']>;
  price?: Maybe<Scalars['Int']>;
  price_currency_code?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_fulfillable?: Maybe<Scalars['Int']>;
  quantity_packed?: Maybe<Scalars['Int']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  sku?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  variant_title?: Maybe<Scalars['String']>;
  vendor?: Maybe<Scalars['String']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Sales_Order_Line_Item_Sum_Fields = {
  price?: Maybe<Scalars['Int']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_fulfillable?: Maybe<Scalars['Int']>;
  quantity_packed?: Maybe<Scalars['Int']>;
  weight_gram?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Sum_Order_By = {
  price?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** update columns of table "sales_order_line_item" */
export const Sales_Order_Line_Item_Update_Column = {
  /** column name */
  Barcode: 'barcode',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  CustomsInfo: 'customs_info',
  /** column name */
  FulfilmentService: 'fulfilment_service',
  /** column name */
  Id: 'id',
  /** column name */
  ImageUrl: 'image_url',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  IsDigital: 'is_digital',
  /** column name */
  Name: 'name',
  /** column name */
  OriginalResponse: 'original_response',
  /** column name */
  PackingStatus: 'packing_status',
  /** column name */
  ParentLineItemId: 'parent_line_item_id',
  /** column name */
  Price: 'price',
  /** column name */
  PriceCurrencyCode: 'price_currency_code',
  /** column name */
  Quantity: 'quantity',
  /** column name */
  QuantityFulfillable: 'quantity_fulfillable',
  /** column name */
  QuantityPacked: 'quantity_packed',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  Sku: 'sku',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  VariantTitle: 'variant_title',
  /** column name */
  Vendor: 'vendor',
  /** column name */
  WeightGram: 'weight_gram'
} as const;

export type Sales_Order_Line_Item_Update_Column = typeof Sales_Order_Line_Item_Update_Column[keyof typeof Sales_Order_Line_Item_Update_Column];
export type Sales_Order_Line_Item_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Sales_Order_Line_Item_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Sales_Order_Line_Item_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Sales_Order_Line_Item_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Sales_Order_Line_Item_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Sales_Order_Line_Item_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Sales_Order_Line_Item_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Sales_Order_Line_Item_Set_Input>;
  /** filter the rows which have to be updated */
  where: Sales_Order_Line_Item_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Sales_Order_Line_Item_Var_Pop_Fields = {
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_fulfillable?: Maybe<Scalars['Float']>;
  quantity_packed?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Var_Pop_Order_By = {
  price?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Sales_Order_Line_Item_Var_Samp_Fields = {
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_fulfillable?: Maybe<Scalars['Float']>;
  quantity_packed?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Var_Samp_Order_By = {
  price?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Sales_Order_Line_Item_Variance_Fields = {
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_fulfillable?: Maybe<Scalars['Float']>;
  quantity_packed?: Maybe<Scalars['Float']>;
  weight_gram?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "sales_order_line_item" */
export type Sales_Order_Line_Item_Variance_Order_By = {
  price?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_fulfillable?: Maybe<Order_By>;
  quantity_packed?: Maybe<Order_By>;
  weight_gram?: Maybe<Order_By>;
};

/** aggregate max on columns */
export type Sales_Order_Max_Fields = {
  billing_address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['uuid']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  order_reference?: Maybe<Scalars['String']>;
  packaging_rule_id?: Maybe<Scalars['uuid']>;
  pick_cost?: Maybe<Scalars['Int']>;
  shipping_address_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['Int']>;
  total_weight_gram?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "sales_order" */
export type Sales_Order_Max_Order_By = {
  billing_address_id?: Maybe<Order_By>;
  contact_number?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  first_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_name?: Maybe<Order_By>;
  note?: Maybe<Order_By>;
  order_reference?: Maybe<Order_By>;
  packaging_rule_id?: Maybe<Order_By>;
  pick_cost?: Maybe<Order_By>;
  shipping_address_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Sales_Order_Min_Fields = {
  billing_address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['uuid']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  order_reference?: Maybe<Scalars['String']>;
  packaging_rule_id?: Maybe<Scalars['uuid']>;
  pick_cost?: Maybe<Scalars['Int']>;
  shipping_address_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['Int']>;
  total_weight_gram?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "sales_order" */
export type Sales_Order_Min_Order_By = {
  billing_address_id?: Maybe<Order_By>;
  contact_number?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  first_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_name?: Maybe<Order_By>;
  note?: Maybe<Order_By>;
  order_reference?: Maybe<Order_By>;
  packaging_rule_id?: Maybe<Order_By>;
  pick_cost?: Maybe<Order_By>;
  shipping_address_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "sales_order" */
export type Sales_Order_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Sales_Order>;
};

/** input type for inserting object relation for remote table "sales_order" */
export type Sales_Order_Obj_Rel_Insert_Input = {
  data: Sales_Order_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Sales_Order_On_Conflict>;
};

/** on_conflict condition type for table "sales_order" */
export type Sales_Order_On_Conflict = {
  constraint: Sales_Order_Constraint;
  update_columns?: Array<Sales_Order_Update_Column>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};

/** Ordering options when selecting data from "sales_order". */
export type Sales_Order_Order_By = {
  billing_address?: Maybe<Address_Order_By>;
  billing_address_id?: Maybe<Order_By>;
  contact_number?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer?: Maybe<Customer_Order_By>;
  customer_id?: Maybe<Order_By>;
  draft_fulfilment_shipment?: Maybe<Draft_Fulfilment_Shipment_Order_By>;
  first_name?: Maybe<Order_By>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  last_name?: Maybe<Order_By>;
  line_items?: Maybe<Order_By>;
  note?: Maybe<Order_By>;
  order_reference?: Maybe<Order_By>;
  packaging_rule_id?: Maybe<Order_By>;
  packing_status?: Maybe<Order_By>;
  packing_status_by_packing_status?: Maybe<Packing_Status_Order_By>;
  payment_status?: Maybe<Order_By>;
  payment_status_by_payment_status?: Maybe<Payment_Status_Order_By>;
  pick_cost?: Maybe<Order_By>;
  sales_channel?: Maybe<Sales_Channel_Order_By>;
  sales_order_line_items_aggregate?: Maybe<Sales_Order_Line_Item_Aggregate_Order_By>;
  sales_order_shipment_charges_aggregate?: Maybe<Sales_Order_Shipment_Charge_Aggregate_Order_By>;
  sales_order_status?: Maybe<Sales_Order_Status_Order_By>;
  sales_order_tags_aggregate?: Maybe<Sales_Order_Tag_Aggregate_Order_By>;
  shipping_address?: Maybe<Address_Order_By>;
  shipping_address_id?: Maybe<Order_By>;
  source?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: sales_order */
export type Sales_Order_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Sales_Order_Prepend_Input = {
  line_items?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "sales_order" */
export const Sales_Order_Select_Column = {
  /** column name */
  BillingAddressId: 'billing_address_id',
  /** column name */
  ContactNumber: 'contact_number',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  CustomerId: 'customer_id',
  /** column name */
  FirstName: 'first_name',
  /** column name */
  Id: 'id',
  /** column name */
  LastName: 'last_name',
  /** column name */
  LineItems: 'line_items',
  /** column name */
  Note: 'note',
  /** column name */
  OrderReference: 'order_reference',
  /** column name */
  PackagingRuleId: 'packaging_rule_id',
  /** column name */
  PackingStatus: 'packing_status',
  /** column name */
  PaymentStatus: 'payment_status',
  /** column name */
  PickCost: 'pick_cost',
  /** column name */
  ShippingAddressId: 'shipping_address_id',
  /** column name */
  Source: 'source',
  /** column name */
  Status: 'status',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  TotalCost: 'total_cost',
  /** column name */
  TotalPrice: 'total_price',
  /** column name */
  TotalWeightGram: 'total_weight_gram',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Sales_Order_Select_Column = typeof Sales_Order_Select_Column[keyof typeof Sales_Order_Select_Column];
/** input type for updating data in table "sales_order" */
export type Sales_Order_Set_Input = {
  billing_address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['uuid']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  line_items?: Maybe<Scalars['jsonb']>;
  note?: Maybe<Scalars['String']>;
  order_reference?: Maybe<Scalars['String']>;
  packaging_rule_id?: Maybe<Scalars['uuid']>;
  packing_status?: Maybe<Packing_Status_Enum>;
  payment_status?: Maybe<Payment_Status_Enum>;
  pick_cost?: Maybe<Scalars['Int']>;
  shipping_address_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Sales_Channel_Enum>;
  status?: Maybe<Sales_Order_Status_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['Int']>;
  total_weight_gram?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge = {
  category?: Maybe<Scalars['String']>;
  courier?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  discounted_price: Scalars['Int'];
  id: Scalars['uuid'];
  integrations?: Maybe<Scalars['jsonb']>;
  name?: Maybe<Scalars['String']>;
  price: Scalars['Int'];
  /** An object relationship */
  sales_order: Sales_Order;
  sales_order_id: Scalars['uuid'];
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  type?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "sales_order_shipment_charge" */
export type Sales_Order_Shipment_ChargeIntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Aggregate = {
  aggregate?: Maybe<Sales_Order_Shipment_Charge_Aggregate_Fields>;
  nodes: Array<Sales_Order_Shipment_Charge>;
};

export type Sales_Order_Shipment_Charge_Aggregate_Bool_Exp = {
  count?: Maybe<Sales_Order_Shipment_Charge_Aggregate_Bool_Exp_Count>;
};

export type Sales_Order_Shipment_Charge_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Aggregate_Fields = {
  avg?: Maybe<Sales_Order_Shipment_Charge_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Sales_Order_Shipment_Charge_Max_Fields>;
  min?: Maybe<Sales_Order_Shipment_Charge_Min_Fields>;
  stddev?: Maybe<Sales_Order_Shipment_Charge_Stddev_Fields>;
  stddev_pop?: Maybe<Sales_Order_Shipment_Charge_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Sales_Order_Shipment_Charge_Stddev_Samp_Fields>;
  sum?: Maybe<Sales_Order_Shipment_Charge_Sum_Fields>;
  var_pop?: Maybe<Sales_Order_Shipment_Charge_Var_Pop_Fields>;
  var_samp?: Maybe<Sales_Order_Shipment_Charge_Var_Samp_Fields>;
  variance?: Maybe<Sales_Order_Shipment_Charge_Variance_Fields>;
};


/** aggregate fields of "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Aggregate_Order_By = {
  avg?: Maybe<Sales_Order_Shipment_Charge_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Sales_Order_Shipment_Charge_Max_Order_By>;
  min?: Maybe<Sales_Order_Shipment_Charge_Min_Order_By>;
  stddev?: Maybe<Sales_Order_Shipment_Charge_Stddev_Order_By>;
  stddev_pop?: Maybe<Sales_Order_Shipment_Charge_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Sales_Order_Shipment_Charge_Stddev_Samp_Order_By>;
  sum?: Maybe<Sales_Order_Shipment_Charge_Sum_Order_By>;
  var_pop?: Maybe<Sales_Order_Shipment_Charge_Var_Pop_Order_By>;
  var_samp?: Maybe<Sales_Order_Shipment_Charge_Var_Samp_Order_By>;
  variance?: Maybe<Sales_Order_Shipment_Charge_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Sales_Order_Shipment_Charge_Append_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Arr_Rel_Insert_Input = {
  data: Array<Sales_Order_Shipment_Charge_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Sales_Order_Shipment_Charge_On_Conflict>;
};

/** aggregate avg on columns */
export type Sales_Order_Shipment_Charge_Avg_Fields = {
  discounted_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Avg_Order_By = {
  discounted_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "sales_order_shipment_charge". All fields are combined with a logical 'AND'. */
export type Sales_Order_Shipment_Charge_Bool_Exp = {
  _and?: Maybe<Array<Sales_Order_Shipment_Charge_Bool_Exp>>;
  _not?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
  _or?: Maybe<Array<Sales_Order_Shipment_Charge_Bool_Exp>>;
  category?: Maybe<String_Comparison_Exp>;
  courier?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  discounted_price?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  integrations?: Maybe<Jsonb_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Int_Comparison_Exp>;
  sales_order?: Maybe<Sales_Order_Bool_Exp>;
  sales_order_id?: Maybe<Uuid_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "sales_order_shipment_charge" */
export const Sales_Order_Shipment_Charge_Constraint = {
  /** unique or primary key constraint on columns "id" */
  SalesOrderShipmentChargePkey: 'sales_order_shipment_charge_pkey'
} as const;

export type Sales_Order_Shipment_Charge_Constraint = typeof Sales_Order_Shipment_Charge_Constraint[keyof typeof Sales_Order_Shipment_Charge_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Sales_Order_Shipment_Charge_Delete_At_Path_Input = {
  integrations?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Sales_Order_Shipment_Charge_Delete_Elem_Input = {
  integrations?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Sales_Order_Shipment_Charge_Delete_Key_Input = {
  integrations?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Inc_Input = {
  discounted_price?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Insert_Input = {
  category?: Maybe<Scalars['String']>;
  courier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discounted_price?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  name?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Int']>;
  sales_order?: Maybe<Sales_Order_Obj_Rel_Insert_Input>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Sales_Order_Shipment_Charge_Max_Fields = {
  category?: Maybe<Scalars['String']>;
  courier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discounted_price?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Int']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Max_Order_By = {
  category?: Maybe<Order_By>;
  courier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  discounted_price?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Sales_Order_Shipment_Charge_Min_Fields = {
  category?: Maybe<Scalars['String']>;
  courier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discounted_price?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Int']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Min_Order_By = {
  category?: Maybe<Order_By>;
  courier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  discounted_price?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Sales_Order_Shipment_Charge>;
};

/** on_conflict condition type for table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_On_Conflict = {
  constraint: Sales_Order_Shipment_Charge_Constraint;
  update_columns?: Array<Sales_Order_Shipment_Charge_Update_Column>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};

/** Ordering options when selecting data from "sales_order_shipment_charge". */
export type Sales_Order_Shipment_Charge_Order_By = {
  category?: Maybe<Order_By>;
  courier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  discounted_price?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  integrations?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  sales_order?: Maybe<Sales_Order_Order_By>;
  sales_order_id?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: sales_order_shipment_charge */
export type Sales_Order_Shipment_Charge_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Sales_Order_Shipment_Charge_Prepend_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "sales_order_shipment_charge" */
export const Sales_Order_Shipment_Charge_Select_Column = {
  /** column name */
  Category: 'category',
  /** column name */
  Courier: 'courier',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DiscountedPrice: 'discounted_price',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  Name: 'name',
  /** column name */
  Price: 'price',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Type: 'type',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Sales_Order_Shipment_Charge_Select_Column = typeof Sales_Order_Shipment_Charge_Select_Column[keyof typeof Sales_Order_Shipment_Charge_Select_Column];
/** input type for updating data in table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Set_Input = {
  category?: Maybe<Scalars['String']>;
  courier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discounted_price?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  name?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Int']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Sales_Order_Shipment_Charge_Stddev_Fields = {
  discounted_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Stddev_Order_By = {
  discounted_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Sales_Order_Shipment_Charge_Stddev_Pop_Fields = {
  discounted_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Stddev_Pop_Order_By = {
  discounted_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Sales_Order_Shipment_Charge_Stddev_Samp_Fields = {
  discounted_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Stddev_Samp_Order_By = {
  discounted_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
};

/** Streaming cursor of the table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Sales_Order_Shipment_Charge_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Sales_Order_Shipment_Charge_Stream_Cursor_Value_Input = {
  category?: Maybe<Scalars['String']>;
  courier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discounted_price?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  name?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Int']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Sales_Order_Shipment_Charge_Sum_Fields = {
  discounted_price?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Sum_Order_By = {
  discounted_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
};

/** update columns of table "sales_order_shipment_charge" */
export const Sales_Order_Shipment_Charge_Update_Column = {
  /** column name */
  Category: 'category',
  /** column name */
  Courier: 'courier',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DiscountedPrice: 'discounted_price',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  Name: 'name',
  /** column name */
  Price: 'price',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  Type: 'type',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Sales_Order_Shipment_Charge_Update_Column = typeof Sales_Order_Shipment_Charge_Update_Column[keyof typeof Sales_Order_Shipment_Charge_Update_Column];
export type Sales_Order_Shipment_Charge_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Sales_Order_Shipment_Charge_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Sales_Order_Shipment_Charge_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Sales_Order_Shipment_Charge_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Sales_Order_Shipment_Charge_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Sales_Order_Shipment_Charge_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Sales_Order_Shipment_Charge_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Sales_Order_Shipment_Charge_Set_Input>;
  /** filter the rows which have to be updated */
  where: Sales_Order_Shipment_Charge_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Sales_Order_Shipment_Charge_Var_Pop_Fields = {
  discounted_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Var_Pop_Order_By = {
  discounted_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Sales_Order_Shipment_Charge_Var_Samp_Fields = {
  discounted_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Var_Samp_Order_By = {
  discounted_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Sales_Order_Shipment_Charge_Variance_Fields = {
  discounted_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "sales_order_shipment_charge" */
export type Sales_Order_Shipment_Charge_Variance_Order_By = {
  discounted_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
};

/** columns and relationships of "sales_order_status" */
export type Sales_Order_Status = {
  /** An array relationship */
  sales_orders: Array<Sales_Order>;
  /** An aggregate relationship */
  sales_orders_aggregate: Sales_Order_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "sales_order_status" */
export type Sales_Order_StatusSales_OrdersArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "sales_order_status" */
export type Sales_Order_StatusSales_Orders_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};

/** aggregated selection of "sales_order_status" */
export type Sales_Order_Status_Aggregate = {
  aggregate?: Maybe<Sales_Order_Status_Aggregate_Fields>;
  nodes: Array<Sales_Order_Status>;
};

/** aggregate fields of "sales_order_status" */
export type Sales_Order_Status_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Sales_Order_Status_Max_Fields>;
  min?: Maybe<Sales_Order_Status_Min_Fields>;
};


/** aggregate fields of "sales_order_status" */
export type Sales_Order_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Sales_Order_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "sales_order_status". All fields are combined with a logical 'AND'. */
export type Sales_Order_Status_Bool_Exp = {
  _and?: Maybe<Array<Sales_Order_Status_Bool_Exp>>;
  _not?: Maybe<Sales_Order_Status_Bool_Exp>;
  _or?: Maybe<Array<Sales_Order_Status_Bool_Exp>>;
  sales_orders?: Maybe<Sales_Order_Bool_Exp>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "sales_order_status" */
export const Sales_Order_Status_Constraint = {
  /** unique or primary key constraint on columns "value" */
  SalesOrderStatusPkey: 'sales_order_status_pkey'
} as const;

export type Sales_Order_Status_Constraint = typeof Sales_Order_Status_Constraint[keyof typeof Sales_Order_Status_Constraint];
export const Sales_Order_Status_Enum = {
  Active: 'ACTIVE',
  Archived: 'ARCHIVED',
  Cancelled: 'CANCELLED',
  Complete: 'COMPLETE',
  Draft: 'DRAFT'
} as const;

export type Sales_Order_Status_Enum = typeof Sales_Order_Status_Enum[keyof typeof Sales_Order_Status_Enum];
/** Boolean expression to compare columns of type "sales_order_status_enum". All fields are combined with logical 'AND'. */
export type Sales_Order_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Sales_Order_Status_Enum>;
  _in?: Maybe<Array<Sales_Order_Status_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Sales_Order_Status_Enum>;
  _nin?: Maybe<Array<Sales_Order_Status_Enum>>;
};

/** input type for inserting data into table "sales_order_status" */
export type Sales_Order_Status_Insert_Input = {
  sales_orders?: Maybe<Sales_Order_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Sales_Order_Status_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Sales_Order_Status_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "sales_order_status" */
export type Sales_Order_Status_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Sales_Order_Status>;
};

/** input type for inserting object relation for remote table "sales_order_status" */
export type Sales_Order_Status_Obj_Rel_Insert_Input = {
  data: Sales_Order_Status_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Sales_Order_Status_On_Conflict>;
};

/** on_conflict condition type for table "sales_order_status" */
export type Sales_Order_Status_On_Conflict = {
  constraint: Sales_Order_Status_Constraint;
  update_columns?: Array<Sales_Order_Status_Update_Column>;
  where?: Maybe<Sales_Order_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "sales_order_status". */
export type Sales_Order_Status_Order_By = {
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: sales_order_status */
export type Sales_Order_Status_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "sales_order_status" */
export const Sales_Order_Status_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Sales_Order_Status_Select_Column = typeof Sales_Order_Status_Select_Column[keyof typeof Sales_Order_Status_Select_Column];
/** input type for updating data in table "sales_order_status" */
export type Sales_Order_Status_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "sales_order_status" */
export type Sales_Order_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Sales_Order_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Sales_Order_Status_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "sales_order_status" */
export const Sales_Order_Status_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Sales_Order_Status_Update_Column = typeof Sales_Order_Status_Update_Column[keyof typeof Sales_Order_Status_Update_Column];
export type Sales_Order_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Sales_Order_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Sales_Order_Status_Bool_Exp;
};

/** aggregate stddev on columns */
export type Sales_Order_Stddev_Fields = {
  pick_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
  total_weight_gram?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "sales_order" */
export type Sales_Order_Stddev_Order_By = {
  pick_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Sales_Order_Stddev_Pop_Fields = {
  pick_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
  total_weight_gram?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "sales_order" */
export type Sales_Order_Stddev_Pop_Order_By = {
  pick_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Sales_Order_Stddev_Samp_Fields = {
  pick_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
  total_weight_gram?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "sales_order" */
export type Sales_Order_Stddev_Samp_Order_By = {
  pick_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
};

/** Streaming cursor of the table "sales_order" */
export type Sales_Order_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Sales_Order_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Sales_Order_Stream_Cursor_Value_Input = {
  billing_address_id?: Maybe<Scalars['uuid']>;
  contact_number?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['uuid']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  line_items?: Maybe<Scalars['jsonb']>;
  note?: Maybe<Scalars['String']>;
  order_reference?: Maybe<Scalars['String']>;
  packaging_rule_id?: Maybe<Scalars['uuid']>;
  packing_status?: Maybe<Packing_Status_Enum>;
  payment_status?: Maybe<Payment_Status_Enum>;
  pick_cost?: Maybe<Scalars['Int']>;
  shipping_address_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Sales_Channel_Enum>;
  status?: Maybe<Sales_Order_Status_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['Int']>;
  total_weight_gram?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Sales_Order_Sum_Fields = {
  pick_cost?: Maybe<Scalars['Int']>;
  total_cost?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['Int']>;
  total_weight_gram?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "sales_order" */
export type Sales_Order_Sum_Order_By = {
  pick_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
};

/** Two column uniqueness on order and tag id prevents duplicate joins */
export type Sales_Order_Tag = {
  created_at: Scalars['timestamptz'];
  id: Scalars['bigint'];
  /** An object relationship */
  sales_order: Sales_Order;
  sales_order_id: Scalars['uuid'];
  source: Sales_Channel_Enum;
  /** An object relationship */
  store?: Maybe<Store>;
  store_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  tag: Tag;
  tag_id: Scalars['bigint'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "sales_order_tag" */
export type Sales_Order_Tag_Aggregate = {
  aggregate?: Maybe<Sales_Order_Tag_Aggregate_Fields>;
  nodes: Array<Sales_Order_Tag>;
};

export type Sales_Order_Tag_Aggregate_Bool_Exp = {
  count?: Maybe<Sales_Order_Tag_Aggregate_Bool_Exp_Count>;
};

export type Sales_Order_Tag_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Sales_Order_Tag_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "sales_order_tag" */
export type Sales_Order_Tag_Aggregate_Fields = {
  avg?: Maybe<Sales_Order_Tag_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Sales_Order_Tag_Max_Fields>;
  min?: Maybe<Sales_Order_Tag_Min_Fields>;
  stddev?: Maybe<Sales_Order_Tag_Stddev_Fields>;
  stddev_pop?: Maybe<Sales_Order_Tag_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Sales_Order_Tag_Stddev_Samp_Fields>;
  sum?: Maybe<Sales_Order_Tag_Sum_Fields>;
  var_pop?: Maybe<Sales_Order_Tag_Var_Pop_Fields>;
  var_samp?: Maybe<Sales_Order_Tag_Var_Samp_Fields>;
  variance?: Maybe<Sales_Order_Tag_Variance_Fields>;
};


/** aggregate fields of "sales_order_tag" */
export type Sales_Order_Tag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "sales_order_tag" */
export type Sales_Order_Tag_Aggregate_Order_By = {
  avg?: Maybe<Sales_Order_Tag_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Sales_Order_Tag_Max_Order_By>;
  min?: Maybe<Sales_Order_Tag_Min_Order_By>;
  stddev?: Maybe<Sales_Order_Tag_Stddev_Order_By>;
  stddev_pop?: Maybe<Sales_Order_Tag_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Sales_Order_Tag_Stddev_Samp_Order_By>;
  sum?: Maybe<Sales_Order_Tag_Sum_Order_By>;
  var_pop?: Maybe<Sales_Order_Tag_Var_Pop_Order_By>;
  var_samp?: Maybe<Sales_Order_Tag_Var_Samp_Order_By>;
  variance?: Maybe<Sales_Order_Tag_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "sales_order_tag" */
export type Sales_Order_Tag_Arr_Rel_Insert_Input = {
  data: Array<Sales_Order_Tag_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Sales_Order_Tag_On_Conflict>;
};

/** aggregate avg on columns */
export type Sales_Order_Tag_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  tag_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Avg_Order_By = {
  id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "sales_order_tag". All fields are combined with a logical 'AND'. */
export type Sales_Order_Tag_Bool_Exp = {
  _and?: Maybe<Array<Sales_Order_Tag_Bool_Exp>>;
  _not?: Maybe<Sales_Order_Tag_Bool_Exp>;
  _or?: Maybe<Array<Sales_Order_Tag_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  sales_order?: Maybe<Sales_Order_Bool_Exp>;
  sales_order_id?: Maybe<Uuid_Comparison_Exp>;
  source?: Maybe<Sales_Channel_Enum_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  tag?: Maybe<Tag_Bool_Exp>;
  tag_id?: Maybe<Bigint_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "sales_order_tag" */
export const Sales_Order_Tag_Constraint = {
  /** unique or primary key constraint on columns "id" */
  SalesOrderTagPkey: 'sales_order_tag_pkey',
  /** unique or primary key constraint on columns "tag_id", "sales_order_id" */
  SalesOrderTagSalesOrderIdTagIdKey: 'sales_order_tag_sales_order_id_tag_id_key'
} as const;

export type Sales_Order_Tag_Constraint = typeof Sales_Order_Tag_Constraint[keyof typeof Sales_Order_Tag_Constraint];
/** input type for incrementing numeric columns in table "sales_order_tag" */
export type Sales_Order_Tag_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  tag_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "sales_order_tag" */
export type Sales_Order_Tag_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  sales_order?: Maybe<Sales_Order_Obj_Rel_Insert_Input>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Sales_Channel_Enum>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  tag?: Maybe<Tag_Obj_Rel_Insert_Input>;
  tag_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Sales_Order_Tag_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  tag_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Sales_Order_Tag_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
  tag_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  sales_order_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "sales_order_tag" */
export type Sales_Order_Tag_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Sales_Order_Tag>;
};

/** on_conflict condition type for table "sales_order_tag" */
export type Sales_Order_Tag_On_Conflict = {
  constraint: Sales_Order_Tag_Constraint;
  update_columns?: Array<Sales_Order_Tag_Update_Column>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};

/** Ordering options when selecting data from "sales_order_tag". */
export type Sales_Order_Tag_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  sales_order?: Maybe<Sales_Order_Order_By>;
  sales_order_id?: Maybe<Order_By>;
  source?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  tag?: Maybe<Tag_Order_By>;
  tag_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: sales_order_tag */
export type Sales_Order_Tag_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "sales_order_tag" */
export const Sales_Order_Tag_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  TagId: 'tag_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Sales_Order_Tag_Select_Column = typeof Sales_Order_Tag_Select_Column[keyof typeof Sales_Order_Tag_Select_Column];
/** input type for updating data in table "sales_order_tag" */
export type Sales_Order_Tag_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Sales_Channel_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  tag_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Sales_Order_Tag_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  tag_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Sales_Order_Tag_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  tag_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Sales_Order_Tag_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  tag_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "sales_order_tag" */
export type Sales_Order_Tag_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Sales_Order_Tag_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Sales_Order_Tag_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  sales_order_id?: Maybe<Scalars['uuid']>;
  source?: Maybe<Sales_Channel_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  tag_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Sales_Order_Tag_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  tag_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Sum_Order_By = {
  id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
};

/** update columns of table "sales_order_tag" */
export const Sales_Order_Tag_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  SalesOrderId: 'sales_order_id',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  TagId: 'tag_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Sales_Order_Tag_Update_Column = typeof Sales_Order_Tag_Update_Column[keyof typeof Sales_Order_Tag_Update_Column];
export type Sales_Order_Tag_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Sales_Order_Tag_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Sales_Order_Tag_Set_Input>;
  /** filter the rows which have to be updated */
  where: Sales_Order_Tag_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Sales_Order_Tag_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  tag_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Sales_Order_Tag_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  tag_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Sales_Order_Tag_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  tag_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "sales_order_tag" */
export type Sales_Order_Tag_Variance_Order_By = {
  id?: Maybe<Order_By>;
  tag_id?: Maybe<Order_By>;
};

/** update columns of table "sales_order" */
export const Sales_Order_Update_Column = {
  /** column name */
  BillingAddressId: 'billing_address_id',
  /** column name */
  ContactNumber: 'contact_number',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  CustomerId: 'customer_id',
  /** column name */
  FirstName: 'first_name',
  /** column name */
  Id: 'id',
  /** column name */
  LastName: 'last_name',
  /** column name */
  LineItems: 'line_items',
  /** column name */
  Note: 'note',
  /** column name */
  OrderReference: 'order_reference',
  /** column name */
  PackagingRuleId: 'packaging_rule_id',
  /** column name */
  PackingStatus: 'packing_status',
  /** column name */
  PaymentStatus: 'payment_status',
  /** column name */
  PickCost: 'pick_cost',
  /** column name */
  ShippingAddressId: 'shipping_address_id',
  /** column name */
  Source: 'source',
  /** column name */
  Status: 'status',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  TotalCost: 'total_cost',
  /** column name */
  TotalPrice: 'total_price',
  /** column name */
  TotalWeightGram: 'total_weight_gram',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Sales_Order_Update_Column = typeof Sales_Order_Update_Column[keyof typeof Sales_Order_Update_Column];
export type Sales_Order_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Sales_Order_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Sales_Order_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Sales_Order_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Sales_Order_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Sales_Order_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Sales_Order_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Sales_Order_Set_Input>;
  /** filter the rows which have to be updated */
  where: Sales_Order_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Sales_Order_Var_Pop_Fields = {
  pick_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
  total_weight_gram?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "sales_order" */
export type Sales_Order_Var_Pop_Order_By = {
  pick_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Sales_Order_Var_Samp_Fields = {
  pick_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
  total_weight_gram?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "sales_order" */
export type Sales_Order_Var_Samp_Order_By = {
  pick_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Sales_Order_Variance_Fields = {
  pick_cost?: Maybe<Scalars['Float']>;
  total_cost?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
  total_weight_gram?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "sales_order" */
export type Sales_Order_Variance_Order_By = {
  pick_cost?: Maybe<Order_By>;
  total_cost?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
  total_weight_gram?: Maybe<Order_By>;
};

export type Search_Retail_Unit_Args = {
  max_retail_units?: Maybe<Scalars['Int']>;
  search_term?: Maybe<Scalars['String']>;
  storeid?: Maybe<Scalars['uuid']>;
};

export type Search_Tag_Args = {
  search?: Maybe<Scalars['String']>;
  storeid?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "shipment_source" */
export type Shipment_Source = {
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "shipment_source" */
export type Shipment_SourceFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "shipment_source" */
export type Shipment_SourceFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};

/** aggregated selection of "shipment_source" */
export type Shipment_Source_Aggregate = {
  aggregate?: Maybe<Shipment_Source_Aggregate_Fields>;
  nodes: Array<Shipment_Source>;
};

/** aggregate fields of "shipment_source" */
export type Shipment_Source_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Shipment_Source_Max_Fields>;
  min?: Maybe<Shipment_Source_Min_Fields>;
};


/** aggregate fields of "shipment_source" */
export type Shipment_Source_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Shipment_Source_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "shipment_source". All fields are combined with a logical 'AND'. */
export type Shipment_Source_Bool_Exp = {
  _and?: Maybe<Array<Shipment_Source_Bool_Exp>>;
  _not?: Maybe<Shipment_Source_Bool_Exp>;
  _or?: Maybe<Array<Shipment_Source_Bool_Exp>>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "shipment_source" */
export const Shipment_Source_Constraint = {
  /** unique or primary key constraint on columns "value" */
  ShipmentSourcePkey: 'shipment_source_pkey'
} as const;

export type Shipment_Source_Constraint = typeof Shipment_Source_Constraint[keyof typeof Shipment_Source_Constraint];
export const Shipment_Source_Enum = {
  External: 'EXTERNAL',
  Skutopia: 'SKUTOPIA'
} as const;

export type Shipment_Source_Enum = typeof Shipment_Source_Enum[keyof typeof Shipment_Source_Enum];
/** Boolean expression to compare columns of type "shipment_source_enum". All fields are combined with logical 'AND'. */
export type Shipment_Source_Enum_Comparison_Exp = {
  _eq?: Maybe<Shipment_Source_Enum>;
  _in?: Maybe<Array<Shipment_Source_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Shipment_Source_Enum>;
  _nin?: Maybe<Array<Shipment_Source_Enum>>;
};

/** input type for inserting data into table "shipment_source" */
export type Shipment_Source_Insert_Input = {
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Shipment_Source_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Shipment_Source_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "shipment_source" */
export type Shipment_Source_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shipment_Source>;
};

/** input type for inserting object relation for remote table "shipment_source" */
export type Shipment_Source_Obj_Rel_Insert_Input = {
  data: Shipment_Source_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Shipment_Source_On_Conflict>;
};

/** on_conflict condition type for table "shipment_source" */
export type Shipment_Source_On_Conflict = {
  constraint: Shipment_Source_Constraint;
  update_columns?: Array<Shipment_Source_Update_Column>;
  where?: Maybe<Shipment_Source_Bool_Exp>;
};

/** Ordering options when selecting data from "shipment_source". */
export type Shipment_Source_Order_By = {
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: shipment_source */
export type Shipment_Source_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "shipment_source" */
export const Shipment_Source_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Shipment_Source_Select_Column = typeof Shipment_Source_Select_Column[keyof typeof Shipment_Source_Select_Column];
/** input type for updating data in table "shipment_source" */
export type Shipment_Source_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "shipment_source" */
export type Shipment_Source_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Shipment_Source_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Shipment_Source_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "shipment_source" */
export const Shipment_Source_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Shipment_Source_Update_Column = typeof Shipment_Source_Update_Column[keyof typeof Shipment_Source_Update_Column];
export type Shipment_Source_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Shipment_Source_Set_Input>;
  /** filter the rows which have to be updated */
  where: Shipment_Source_Bool_Exp;
};

/** columns and relationships of "shipment_status" */
export type Shipment_Status = {
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "shipment_status" */
export type Shipment_StatusFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "shipment_status" */
export type Shipment_StatusFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};

/** aggregated selection of "shipment_status" */
export type Shipment_Status_Aggregate = {
  aggregate?: Maybe<Shipment_Status_Aggregate_Fields>;
  nodes: Array<Shipment_Status>;
};

/** aggregate fields of "shipment_status" */
export type Shipment_Status_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Shipment_Status_Max_Fields>;
  min?: Maybe<Shipment_Status_Min_Fields>;
};


/** aggregate fields of "shipment_status" */
export type Shipment_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Shipment_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "shipment_status". All fields are combined with a logical 'AND'. */
export type Shipment_Status_Bool_Exp = {
  _and?: Maybe<Array<Shipment_Status_Bool_Exp>>;
  _not?: Maybe<Shipment_Status_Bool_Exp>;
  _or?: Maybe<Array<Shipment_Status_Bool_Exp>>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "shipment_status" */
export const Shipment_Status_Constraint = {
  /** unique or primary key constraint on columns "value" */
  ShipmentStatusPkey: 'shipment_status_pkey'
} as const;

export type Shipment_Status_Constraint = typeof Shipment_Status_Constraint[keyof typeof Shipment_Status_Constraint];
export const Shipment_Status_Enum = {
  Cancelled: 'CANCELLED',
  Draft: 'DRAFT',
  ProcessingAtSkutopia: 'PROCESSING_AT_SKUTOPIA',
  Received: 'RECEIVED',
  Shipped: 'SHIPPED',
  Unsent: 'UNSENT'
} as const;

export type Shipment_Status_Enum = typeof Shipment_Status_Enum[keyof typeof Shipment_Status_Enum];
/** Boolean expression to compare columns of type "shipment_status_enum". All fields are combined with logical 'AND'. */
export type Shipment_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Shipment_Status_Enum>;
  _in?: Maybe<Array<Shipment_Status_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Shipment_Status_Enum>;
  _nin?: Maybe<Array<Shipment_Status_Enum>>;
};

/** input type for inserting data into table "shipment_status" */
export type Shipment_Status_Insert_Input = {
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Shipment_Status_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Shipment_Status_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "shipment_status" */
export type Shipment_Status_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shipment_Status>;
};

/** input type for inserting object relation for remote table "shipment_status" */
export type Shipment_Status_Obj_Rel_Insert_Input = {
  data: Shipment_Status_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Shipment_Status_On_Conflict>;
};

/** on_conflict condition type for table "shipment_status" */
export type Shipment_Status_On_Conflict = {
  constraint: Shipment_Status_Constraint;
  update_columns?: Array<Shipment_Status_Update_Column>;
  where?: Maybe<Shipment_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "shipment_status". */
export type Shipment_Status_Order_By = {
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: shipment_status */
export type Shipment_Status_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "shipment_status" */
export const Shipment_Status_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Shipment_Status_Select_Column = typeof Shipment_Status_Select_Column[keyof typeof Shipment_Status_Select_Column];
/** input type for updating data in table "shipment_status" */
export type Shipment_Status_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "shipment_status" */
export type Shipment_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Shipment_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Shipment_Status_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "shipment_status" */
export const Shipment_Status_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Shipment_Status_Update_Column = typeof Shipment_Status_Update_Column[keyof typeof Shipment_Status_Update_Column];
export type Shipment_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Shipment_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Shipment_Status_Bool_Exp;
};

/** columns and relationships of "shipping_area" */
export type Shipping_Area = {
  created_at: Scalars['timestamptz'];
  definition: Scalars['String'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  postcode_max: Scalars['Int'];
  postcode_min: Scalars['Int'];
  type: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "shipping_area" */
export type Shipping_Area_Aggregate = {
  aggregate?: Maybe<Shipping_Area_Aggregate_Fields>;
  nodes: Array<Shipping_Area>;
};

/** aggregate fields of "shipping_area" */
export type Shipping_Area_Aggregate_Fields = {
  avg?: Maybe<Shipping_Area_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Shipping_Area_Max_Fields>;
  min?: Maybe<Shipping_Area_Min_Fields>;
  stddev?: Maybe<Shipping_Area_Stddev_Fields>;
  stddev_pop?: Maybe<Shipping_Area_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Shipping_Area_Stddev_Samp_Fields>;
  sum?: Maybe<Shipping_Area_Sum_Fields>;
  var_pop?: Maybe<Shipping_Area_Var_Pop_Fields>;
  var_samp?: Maybe<Shipping_Area_Var_Samp_Fields>;
  variance?: Maybe<Shipping_Area_Variance_Fields>;
};


/** aggregate fields of "shipping_area" */
export type Shipping_Area_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Shipping_Area_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Shipping_Area_Avg_Fields = {
  postcode_max?: Maybe<Scalars['Float']>;
  postcode_min?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "shipping_area". All fields are combined with a logical 'AND'. */
export type Shipping_Area_Bool_Exp = {
  _and?: Maybe<Array<Shipping_Area_Bool_Exp>>;
  _not?: Maybe<Shipping_Area_Bool_Exp>;
  _or?: Maybe<Array<Shipping_Area_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  definition?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  postcode_max?: Maybe<Int_Comparison_Exp>;
  postcode_min?: Maybe<Int_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "shipping_area" */
export const Shipping_Area_Constraint = {
  /** unique or primary key constraint on columns "id" */
  ShippingAreaPkey: 'shipping_area_pkey'
} as const;

export type Shipping_Area_Constraint = typeof Shipping_Area_Constraint[keyof typeof Shipping_Area_Constraint];
/** input type for incrementing numeric columns in table "shipping_area" */
export type Shipping_Area_Inc_Input = {
  postcode_max?: Maybe<Scalars['Int']>;
  postcode_min?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "shipping_area" */
export type Shipping_Area_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  definition?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  postcode_max?: Maybe<Scalars['Int']>;
  postcode_min?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Shipping_Area_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  definition?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  postcode_max?: Maybe<Scalars['Int']>;
  postcode_min?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Shipping_Area_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  definition?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  postcode_max?: Maybe<Scalars['Int']>;
  postcode_min?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "shipping_area" */
export type Shipping_Area_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shipping_Area>;
};

/** on_conflict condition type for table "shipping_area" */
export type Shipping_Area_On_Conflict = {
  constraint: Shipping_Area_Constraint;
  update_columns?: Array<Shipping_Area_Update_Column>;
  where?: Maybe<Shipping_Area_Bool_Exp>;
};

/** Ordering options when selecting data from "shipping_area". */
export type Shipping_Area_Order_By = {
  created_at?: Maybe<Order_By>;
  definition?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  postcode_max?: Maybe<Order_By>;
  postcode_min?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: shipping_area */
export type Shipping_Area_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "shipping_area" */
export const Shipping_Area_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Definition: 'definition',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  PostcodeMax: 'postcode_max',
  /** column name */
  PostcodeMin: 'postcode_min',
  /** column name */
  Type: 'type',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Shipping_Area_Select_Column = typeof Shipping_Area_Select_Column[keyof typeof Shipping_Area_Select_Column];
/** input type for updating data in table "shipping_area" */
export type Shipping_Area_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  definition?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  postcode_max?: Maybe<Scalars['Int']>;
  postcode_min?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Shipping_Area_Stddev_Fields = {
  postcode_max?: Maybe<Scalars['Float']>;
  postcode_min?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Shipping_Area_Stddev_Pop_Fields = {
  postcode_max?: Maybe<Scalars['Float']>;
  postcode_min?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Shipping_Area_Stddev_Samp_Fields = {
  postcode_max?: Maybe<Scalars['Float']>;
  postcode_min?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "shipping_area" */
export type Shipping_Area_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Shipping_Area_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Shipping_Area_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  definition?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  postcode_max?: Maybe<Scalars['Int']>;
  postcode_min?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Shipping_Area_Sum_Fields = {
  postcode_max?: Maybe<Scalars['Int']>;
  postcode_min?: Maybe<Scalars['Int']>;
};

/** update columns of table "shipping_area" */
export const Shipping_Area_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Definition: 'definition',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  PostcodeMax: 'postcode_max',
  /** column name */
  PostcodeMin: 'postcode_min',
  /** column name */
  Type: 'type',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Shipping_Area_Update_Column = typeof Shipping_Area_Update_Column[keyof typeof Shipping_Area_Update_Column];
export type Shipping_Area_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Shipping_Area_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Shipping_Area_Set_Input>;
  /** filter the rows which have to be updated */
  where: Shipping_Area_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Shipping_Area_Var_Pop_Fields = {
  postcode_max?: Maybe<Scalars['Float']>;
  postcode_min?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Shipping_Area_Var_Samp_Fields = {
  postcode_max?: Maybe<Scalars['Float']>;
  postcode_min?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Shipping_Area_Variance_Fields = {
  postcode_max?: Maybe<Scalars['Float']>;
  postcode_min?: Maybe<Scalars['Float']>;
};

/** This is an append only table, records should not be updated */
export type Shipping_Margin = {
  carrier_slug: Scalars['String'];
  created_at: Scalars['timestamptz'];
  expired_at?: Maybe<Scalars['timestamptz']>;
  flat_amount: Scalars['numeric'];
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  id: Scalars['uuid'];
  multiplier: Scalars['numeric'];
  name?: Maybe<Scalars['String']>;
  /** An object relationship */
  shipping_margin_type: Shipping_Margin_Type;
  type: Shipping_Margin_Type_Enum;
};


/** This is an append only table, records should not be updated */
export type Shipping_MarginFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** This is an append only table, records should not be updated */
export type Shipping_MarginFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};

/** aggregated selection of "shipping_margin" */
export type Shipping_Margin_Aggregate = {
  aggregate?: Maybe<Shipping_Margin_Aggregate_Fields>;
  nodes: Array<Shipping_Margin>;
};

export type Shipping_Margin_Aggregate_Bool_Exp = {
  count?: Maybe<Shipping_Margin_Aggregate_Bool_Exp_Count>;
};

export type Shipping_Margin_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Shipping_Margin_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Shipping_Margin_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "shipping_margin" */
export type Shipping_Margin_Aggregate_Fields = {
  avg?: Maybe<Shipping_Margin_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Shipping_Margin_Max_Fields>;
  min?: Maybe<Shipping_Margin_Min_Fields>;
  stddev?: Maybe<Shipping_Margin_Stddev_Fields>;
  stddev_pop?: Maybe<Shipping_Margin_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Shipping_Margin_Stddev_Samp_Fields>;
  sum?: Maybe<Shipping_Margin_Sum_Fields>;
  var_pop?: Maybe<Shipping_Margin_Var_Pop_Fields>;
  var_samp?: Maybe<Shipping_Margin_Var_Samp_Fields>;
  variance?: Maybe<Shipping_Margin_Variance_Fields>;
};


/** aggregate fields of "shipping_margin" */
export type Shipping_Margin_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Shipping_Margin_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "shipping_margin" */
export type Shipping_Margin_Aggregate_Order_By = {
  avg?: Maybe<Shipping_Margin_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Shipping_Margin_Max_Order_By>;
  min?: Maybe<Shipping_Margin_Min_Order_By>;
  stddev?: Maybe<Shipping_Margin_Stddev_Order_By>;
  stddev_pop?: Maybe<Shipping_Margin_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Shipping_Margin_Stddev_Samp_Order_By>;
  sum?: Maybe<Shipping_Margin_Sum_Order_By>;
  var_pop?: Maybe<Shipping_Margin_Var_Pop_Order_By>;
  var_samp?: Maybe<Shipping_Margin_Var_Samp_Order_By>;
  variance?: Maybe<Shipping_Margin_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "shipping_margin" */
export type Shipping_Margin_Arr_Rel_Insert_Input = {
  data: Array<Shipping_Margin_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Shipping_Margin_On_Conflict>;
};

/** aggregate avg on columns */
export type Shipping_Margin_Avg_Fields = {
  flat_amount?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "shipping_margin" */
export type Shipping_Margin_Avg_Order_By = {
  flat_amount?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "shipping_margin". All fields are combined with a logical 'AND'. */
export type Shipping_Margin_Bool_Exp = {
  _and?: Maybe<Array<Shipping_Margin_Bool_Exp>>;
  _not?: Maybe<Shipping_Margin_Bool_Exp>;
  _or?: Maybe<Array<Shipping_Margin_Bool_Exp>>;
  carrier_slug?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  expired_at?: Maybe<Timestamptz_Comparison_Exp>;
  flat_amount?: Maybe<Numeric_Comparison_Exp>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  multiplier?: Maybe<Numeric_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  shipping_margin_type?: Maybe<Shipping_Margin_Type_Bool_Exp>;
  type?: Maybe<Shipping_Margin_Type_Enum_Comparison_Exp>;
};

/** unique or primary key constraints on table "shipping_margin" */
export const Shipping_Margin_Constraint = {
  /** unique or primary key constraint on columns "id" */
  ShippingMarginPkey: 'shipping_margin_pkey'
} as const;

export type Shipping_Margin_Constraint = typeof Shipping_Margin_Constraint[keyof typeof Shipping_Margin_Constraint];
/** input type for incrementing numeric columns in table "shipping_margin" */
export type Shipping_Margin_Inc_Input = {
  flat_amount?: Maybe<Scalars['numeric']>;
  multiplier?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "shipping_margin" */
export type Shipping_Margin_Insert_Input = {
  carrier_slug?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expired_at?: Maybe<Scalars['timestamptz']>;
  flat_amount?: Maybe<Scalars['numeric']>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  multiplier?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  shipping_margin_type?: Maybe<Shipping_Margin_Type_Obj_Rel_Insert_Input>;
  type?: Maybe<Shipping_Margin_Type_Enum>;
};

/** aggregate max on columns */
export type Shipping_Margin_Max_Fields = {
  carrier_slug?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expired_at?: Maybe<Scalars['timestamptz']>;
  flat_amount?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['uuid']>;
  multiplier?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "shipping_margin" */
export type Shipping_Margin_Max_Order_By = {
  carrier_slug?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  expired_at?: Maybe<Order_By>;
  flat_amount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Shipping_Margin_Min_Fields = {
  carrier_slug?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expired_at?: Maybe<Scalars['timestamptz']>;
  flat_amount?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['uuid']>;
  multiplier?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "shipping_margin" */
export type Shipping_Margin_Min_Order_By = {
  carrier_slug?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  expired_at?: Maybe<Order_By>;
  flat_amount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** response of any mutation on the table "shipping_margin" */
export type Shipping_Margin_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shipping_Margin>;
};

/** input type for inserting object relation for remote table "shipping_margin" */
export type Shipping_Margin_Obj_Rel_Insert_Input = {
  data: Shipping_Margin_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Shipping_Margin_On_Conflict>;
};

/** on_conflict condition type for table "shipping_margin" */
export type Shipping_Margin_On_Conflict = {
  constraint: Shipping_Margin_Constraint;
  update_columns?: Array<Shipping_Margin_Update_Column>;
  where?: Maybe<Shipping_Margin_Bool_Exp>;
};

/** Ordering options when selecting data from "shipping_margin". */
export type Shipping_Margin_Order_By = {
  carrier_slug?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  expired_at?: Maybe<Order_By>;
  flat_amount?: Maybe<Order_By>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  shipping_margin_type?: Maybe<Shipping_Margin_Type_Order_By>;
  type?: Maybe<Order_By>;
};

/** primary key columns input for table: shipping_margin */
export type Shipping_Margin_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "shipping_margin" */
export const Shipping_Margin_Select_Column = {
  /** column name */
  CarrierSlug: 'carrier_slug',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExpiredAt: 'expired_at',
  /** column name */
  FlatAmount: 'flat_amount',
  /** column name */
  Id: 'id',
  /** column name */
  Multiplier: 'multiplier',
  /** column name */
  Name: 'name',
  /** column name */
  Type: 'type'
} as const;

export type Shipping_Margin_Select_Column = typeof Shipping_Margin_Select_Column[keyof typeof Shipping_Margin_Select_Column];
/** input type for updating data in table "shipping_margin" */
export type Shipping_Margin_Set_Input = {
  carrier_slug?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expired_at?: Maybe<Scalars['timestamptz']>;
  flat_amount?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['uuid']>;
  multiplier?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Shipping_Margin_Type_Enum>;
};

/** aggregate stddev on columns */
export type Shipping_Margin_Stddev_Fields = {
  flat_amount?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "shipping_margin" */
export type Shipping_Margin_Stddev_Order_By = {
  flat_amount?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Shipping_Margin_Stddev_Pop_Fields = {
  flat_amount?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "shipping_margin" */
export type Shipping_Margin_Stddev_Pop_Order_By = {
  flat_amount?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Shipping_Margin_Stddev_Samp_Fields = {
  flat_amount?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "shipping_margin" */
export type Shipping_Margin_Stddev_Samp_Order_By = {
  flat_amount?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
};

/** Streaming cursor of the table "shipping_margin" */
export type Shipping_Margin_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Shipping_Margin_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Shipping_Margin_Stream_Cursor_Value_Input = {
  carrier_slug?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  expired_at?: Maybe<Scalars['timestamptz']>;
  flat_amount?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['uuid']>;
  multiplier?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Shipping_Margin_Type_Enum>;
};

/** aggregate sum on columns */
export type Shipping_Margin_Sum_Fields = {
  flat_amount?: Maybe<Scalars['numeric']>;
  multiplier?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "shipping_margin" */
export type Shipping_Margin_Sum_Order_By = {
  flat_amount?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
};

/** columns and relationships of "shipping_margin_type" */
export type Shipping_Margin_Type = {
  comment?: Maybe<Scalars['String']>;
  /** An array relationship */
  shipping_margins: Array<Shipping_Margin>;
  /** An aggregate relationship */
  shipping_margins_aggregate: Shipping_Margin_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "shipping_margin_type" */
export type Shipping_Margin_TypeShipping_MarginsArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Order_By>>;
  where?: Maybe<Shipping_Margin_Bool_Exp>;
};


/** columns and relationships of "shipping_margin_type" */
export type Shipping_Margin_TypeShipping_Margins_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Order_By>>;
  where?: Maybe<Shipping_Margin_Bool_Exp>;
};

/** aggregated selection of "shipping_margin_type" */
export type Shipping_Margin_Type_Aggregate = {
  aggregate?: Maybe<Shipping_Margin_Type_Aggregate_Fields>;
  nodes: Array<Shipping_Margin_Type>;
};

/** aggregate fields of "shipping_margin_type" */
export type Shipping_Margin_Type_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Shipping_Margin_Type_Max_Fields>;
  min?: Maybe<Shipping_Margin_Type_Min_Fields>;
};


/** aggregate fields of "shipping_margin_type" */
export type Shipping_Margin_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Shipping_Margin_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "shipping_margin_type". All fields are combined with a logical 'AND'. */
export type Shipping_Margin_Type_Bool_Exp = {
  _and?: Maybe<Array<Shipping_Margin_Type_Bool_Exp>>;
  _not?: Maybe<Shipping_Margin_Type_Bool_Exp>;
  _or?: Maybe<Array<Shipping_Margin_Type_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  shipping_margins?: Maybe<Shipping_Margin_Bool_Exp>;
  shipping_margins_aggregate?: Maybe<Shipping_Margin_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "shipping_margin_type" */
export const Shipping_Margin_Type_Constraint = {
  /** unique or primary key constraint on columns "value" */
  ShippingMarginTypePkey: 'shipping_margin_type_pkey'
} as const;

export type Shipping_Margin_Type_Constraint = typeof Shipping_Margin_Type_Constraint[keyof typeof Shipping_Margin_Type_Constraint];
export const Shipping_Margin_Type_Enum = {
  DistantStateCapital: 'DISTANT_STATE_CAPITAL',
  DistantStateMetro: 'DISTANT_STATE_METRO',
  DistantStateRemote: 'DISTANT_STATE_REMOTE',
  NearStateCapital: 'NEAR_STATE_CAPITAL',
  NearStateMetro: 'NEAR_STATE_METRO',
  NearStateRemote: 'NEAR_STATE_REMOTE',
  SameStateLocal: 'SAME_STATE_LOCAL',
  SameStateMetro: 'SAME_STATE_METRO',
  SameStateRemote: 'SAME_STATE_REMOTE'
} as const;

export type Shipping_Margin_Type_Enum = typeof Shipping_Margin_Type_Enum[keyof typeof Shipping_Margin_Type_Enum];
/** Boolean expression to compare columns of type "shipping_margin_type_enum". All fields are combined with logical 'AND'. */
export type Shipping_Margin_Type_Enum_Comparison_Exp = {
  _eq?: Maybe<Shipping_Margin_Type_Enum>;
  _in?: Maybe<Array<Shipping_Margin_Type_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Shipping_Margin_Type_Enum>;
  _nin?: Maybe<Array<Shipping_Margin_Type_Enum>>;
};

/** input type for inserting data into table "shipping_margin_type" */
export type Shipping_Margin_Type_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  shipping_margins?: Maybe<Shipping_Margin_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Shipping_Margin_Type_Max_Fields = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Shipping_Margin_Type_Min_Fields = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "shipping_margin_type" */
export type Shipping_Margin_Type_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shipping_Margin_Type>;
};

/** input type for inserting object relation for remote table "shipping_margin_type" */
export type Shipping_Margin_Type_Obj_Rel_Insert_Input = {
  data: Shipping_Margin_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Shipping_Margin_Type_On_Conflict>;
};

/** on_conflict condition type for table "shipping_margin_type" */
export type Shipping_Margin_Type_On_Conflict = {
  constraint: Shipping_Margin_Type_Constraint;
  update_columns?: Array<Shipping_Margin_Type_Update_Column>;
  where?: Maybe<Shipping_Margin_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "shipping_margin_type". */
export type Shipping_Margin_Type_Order_By = {
  comment?: Maybe<Order_By>;
  shipping_margins_aggregate?: Maybe<Shipping_Margin_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: shipping_margin_type */
export type Shipping_Margin_Type_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "shipping_margin_type" */
export const Shipping_Margin_Type_Select_Column = {
  /** column name */
  Comment: 'comment',
  /** column name */
  Value: 'value'
} as const;

export type Shipping_Margin_Type_Select_Column = typeof Shipping_Margin_Type_Select_Column[keyof typeof Shipping_Margin_Type_Select_Column];
/** input type for updating data in table "shipping_margin_type" */
export type Shipping_Margin_Type_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "shipping_margin_type" */
export type Shipping_Margin_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Shipping_Margin_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Shipping_Margin_Type_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "shipping_margin_type" */
export const Shipping_Margin_Type_Update_Column = {
  /** column name */
  Comment: 'comment',
  /** column name */
  Value: 'value'
} as const;

export type Shipping_Margin_Type_Update_Column = typeof Shipping_Margin_Type_Update_Column[keyof typeof Shipping_Margin_Type_Update_Column];
export type Shipping_Margin_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Shipping_Margin_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Shipping_Margin_Type_Bool_Exp;
};

/** update columns of table "shipping_margin" */
export const Shipping_Margin_Update_Column = {
  /** column name */
  CarrierSlug: 'carrier_slug',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExpiredAt: 'expired_at',
  /** column name */
  FlatAmount: 'flat_amount',
  /** column name */
  Id: 'id',
  /** column name */
  Multiplier: 'multiplier',
  /** column name */
  Name: 'name',
  /** column name */
  Type: 'type'
} as const;

export type Shipping_Margin_Update_Column = typeof Shipping_Margin_Update_Column[keyof typeof Shipping_Margin_Update_Column];
export type Shipping_Margin_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Shipping_Margin_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Shipping_Margin_Set_Input>;
  /** filter the rows which have to be updated */
  where: Shipping_Margin_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Shipping_Margin_Var_Pop_Fields = {
  flat_amount?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "shipping_margin" */
export type Shipping_Margin_Var_Pop_Order_By = {
  flat_amount?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Shipping_Margin_Var_Samp_Fields = {
  flat_amount?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "shipping_margin" */
export type Shipping_Margin_Var_Samp_Order_By = {
  flat_amount?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Shipping_Margin_Variance_Fields = {
  flat_amount?: Maybe<Scalars['Float']>;
  multiplier?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "shipping_margin" */
export type Shipping_Margin_Variance_Order_By = {
  flat_amount?: Maybe<Order_By>;
  multiplier?: Maybe<Order_By>;
};

/** columns and relationships of "shipping_provider" */
export type Shipping_Provider = {
  /** An array relationship */
  carriers: Array<Carrier>;
  /** An aggregate relationship */
  carriers_aggregate: Carrier_Aggregate;
  /** An array relationship */
  shipping_rates: Array<Shipping_Rate>;
  /** An aggregate relationship */
  shipping_rates_aggregate: Shipping_Rate_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "shipping_provider" */
export type Shipping_ProviderCarriersArgs = {
  distinct_on?: Maybe<Array<Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Order_By>>;
  where?: Maybe<Carrier_Bool_Exp>;
};


/** columns and relationships of "shipping_provider" */
export type Shipping_ProviderCarriers_AggregateArgs = {
  distinct_on?: Maybe<Array<Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Order_By>>;
  where?: Maybe<Carrier_Bool_Exp>;
};


/** columns and relationships of "shipping_provider" */
export type Shipping_ProviderShipping_RatesArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


/** columns and relationships of "shipping_provider" */
export type Shipping_ProviderShipping_Rates_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};

/** aggregated selection of "shipping_provider" */
export type Shipping_Provider_Aggregate = {
  aggregate?: Maybe<Shipping_Provider_Aggregate_Fields>;
  nodes: Array<Shipping_Provider>;
};

/** aggregate fields of "shipping_provider" */
export type Shipping_Provider_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Shipping_Provider_Max_Fields>;
  min?: Maybe<Shipping_Provider_Min_Fields>;
};


/** aggregate fields of "shipping_provider" */
export type Shipping_Provider_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Shipping_Provider_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "shipping_provider". All fields are combined with a logical 'AND'. */
export type Shipping_Provider_Bool_Exp = {
  _and?: Maybe<Array<Shipping_Provider_Bool_Exp>>;
  _not?: Maybe<Shipping_Provider_Bool_Exp>;
  _or?: Maybe<Array<Shipping_Provider_Bool_Exp>>;
  carriers?: Maybe<Carrier_Bool_Exp>;
  carriers_aggregate?: Maybe<Carrier_Aggregate_Bool_Exp>;
  shipping_rates?: Maybe<Shipping_Rate_Bool_Exp>;
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "shipping_provider" */
export const Shipping_Provider_Constraint = {
  /** unique or primary key constraint on columns "value" */
  ShippingProviderPkey: 'shipping_provider_pkey'
} as const;

export type Shipping_Provider_Constraint = typeof Shipping_Provider_Constraint[keyof typeof Shipping_Provider_Constraint];
export const Shipping_Provider_Enum = {
  DeliveryDomain: 'DELIVERY_DOMAIN',
  Shiptopia: 'SHIPTOPIA',
  ShipEngine: 'SHIP_ENGINE'
} as const;

export type Shipping_Provider_Enum = typeof Shipping_Provider_Enum[keyof typeof Shipping_Provider_Enum];
/** Boolean expression to compare columns of type "shipping_provider_enum". All fields are combined with logical 'AND'. */
export type Shipping_Provider_Enum_Comparison_Exp = {
  _eq?: Maybe<Shipping_Provider_Enum>;
  _in?: Maybe<Array<Shipping_Provider_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Shipping_Provider_Enum>;
  _nin?: Maybe<Array<Shipping_Provider_Enum>>;
};

/** input type for inserting data into table "shipping_provider" */
export type Shipping_Provider_Insert_Input = {
  carriers?: Maybe<Carrier_Arr_Rel_Insert_Input>;
  shipping_rates?: Maybe<Shipping_Rate_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Shipping_Provider_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Shipping_Provider_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "shipping_provider" */
export type Shipping_Provider_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shipping_Provider>;
};

/** input type for inserting object relation for remote table "shipping_provider" */
export type Shipping_Provider_Obj_Rel_Insert_Input = {
  data: Shipping_Provider_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Shipping_Provider_On_Conflict>;
};

/** on_conflict condition type for table "shipping_provider" */
export type Shipping_Provider_On_Conflict = {
  constraint: Shipping_Provider_Constraint;
  update_columns?: Array<Shipping_Provider_Update_Column>;
  where?: Maybe<Shipping_Provider_Bool_Exp>;
};

/** Ordering options when selecting data from "shipping_provider". */
export type Shipping_Provider_Order_By = {
  carriers_aggregate?: Maybe<Carrier_Aggregate_Order_By>;
  shipping_rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: shipping_provider */
export type Shipping_Provider_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "shipping_provider" */
export const Shipping_Provider_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Shipping_Provider_Select_Column = typeof Shipping_Provider_Select_Column[keyof typeof Shipping_Provider_Select_Column];
/** input type for updating data in table "shipping_provider" */
export type Shipping_Provider_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "shipping_provider" */
export type Shipping_Provider_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Shipping_Provider_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Shipping_Provider_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "shipping_provider" */
export const Shipping_Provider_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Shipping_Provider_Update_Column = typeof Shipping_Provider_Update_Column[keyof typeof Shipping_Provider_Update_Column];
export type Shipping_Provider_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Shipping_Provider_Set_Input>;
  /** filter the rows which have to be updated */
  where: Shipping_Provider_Bool_Exp;
};

/** columns and relationships of "shipping_rate" */
export type Shipping_Rate = {
  amount: Scalars['Int'];
  carrier: Scalars['String'];
  carrier_code?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  currency: Scalars['String'];
  delivery_days?: Maybe<Scalars['Int']>;
  errors: Scalars['jsonb'];
  external_entity_id: Scalars['String'];
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  id: Scalars['uuid'];
  integrations?: Maybe<Scalars['jsonb']>;
  location_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  rate_request: Rate_Request;
  rate_request_id: Scalars['uuid'];
  /** An object relationship */
  rate_selected_by?: Maybe<Rate_Selected_By>;
  selected_by?: Maybe<Rate_Selected_By_Enum>;
  service: Scalars['String'];
  service_code: Scalars['String'];
  /** An object relationship */
  shipping_provider: Shipping_Provider;
  source: Shipping_Provider_Enum;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
};


/** columns and relationships of "shipping_rate" */
export type Shipping_RateErrorsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "shipping_rate" */
export type Shipping_RateFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "shipping_rate" */
export type Shipping_RateFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "shipping_rate" */
export type Shipping_RateIntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "shipping_rate" */
export type Shipping_Rate_Aggregate = {
  aggregate?: Maybe<Shipping_Rate_Aggregate_Fields>;
  nodes: Array<Shipping_Rate>;
};

export type Shipping_Rate_Aggregate_Bool_Exp = {
  count?: Maybe<Shipping_Rate_Aggregate_Bool_Exp_Count>;
};

export type Shipping_Rate_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Shipping_Rate_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Shipping_Rate_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "shipping_rate" */
export type Shipping_Rate_Aggregate_Fields = {
  avg?: Maybe<Shipping_Rate_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Shipping_Rate_Max_Fields>;
  min?: Maybe<Shipping_Rate_Min_Fields>;
  stddev?: Maybe<Shipping_Rate_Stddev_Fields>;
  stddev_pop?: Maybe<Shipping_Rate_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Shipping_Rate_Stddev_Samp_Fields>;
  sum?: Maybe<Shipping_Rate_Sum_Fields>;
  var_pop?: Maybe<Shipping_Rate_Var_Pop_Fields>;
  var_samp?: Maybe<Shipping_Rate_Var_Samp_Fields>;
  variance?: Maybe<Shipping_Rate_Variance_Fields>;
};


/** aggregate fields of "shipping_rate" */
export type Shipping_Rate_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Shipping_Rate_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "shipping_rate" */
export type Shipping_Rate_Aggregate_Order_By = {
  avg?: Maybe<Shipping_Rate_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Shipping_Rate_Max_Order_By>;
  min?: Maybe<Shipping_Rate_Min_Order_By>;
  stddev?: Maybe<Shipping_Rate_Stddev_Order_By>;
  stddev_pop?: Maybe<Shipping_Rate_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Shipping_Rate_Stddev_Samp_Order_By>;
  sum?: Maybe<Shipping_Rate_Sum_Order_By>;
  var_pop?: Maybe<Shipping_Rate_Var_Pop_Order_By>;
  var_samp?: Maybe<Shipping_Rate_Var_Samp_Order_By>;
  variance?: Maybe<Shipping_Rate_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Shipping_Rate_Append_Input = {
  errors?: Maybe<Scalars['jsonb']>;
  integrations?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "shipping_rate" */
export type Shipping_Rate_Arr_Rel_Insert_Input = {
  data: Array<Shipping_Rate_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Shipping_Rate_On_Conflict>;
};

/** aggregate avg on columns */
export type Shipping_Rate_Avg_Fields = {
  amount?: Maybe<Scalars['Float']>;
  delivery_days?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "shipping_rate" */
export type Shipping_Rate_Avg_Order_By = {
  amount?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "shipping_rate". All fields are combined with a logical 'AND'. */
export type Shipping_Rate_Bool_Exp = {
  _and?: Maybe<Array<Shipping_Rate_Bool_Exp>>;
  _not?: Maybe<Shipping_Rate_Bool_Exp>;
  _or?: Maybe<Array<Shipping_Rate_Bool_Exp>>;
  amount?: Maybe<Int_Comparison_Exp>;
  carrier?: Maybe<String_Comparison_Exp>;
  carrier_code?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  currency?: Maybe<String_Comparison_Exp>;
  delivery_days?: Maybe<Int_Comparison_Exp>;
  errors?: Maybe<Jsonb_Comparison_Exp>;
  external_entity_id?: Maybe<String_Comparison_Exp>;
  fulfilment_shipment_id?: Maybe<Uuid_Comparison_Exp>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  integrations?: Maybe<Jsonb_Comparison_Exp>;
  location_id?: Maybe<Uuid_Comparison_Exp>;
  rate_request?: Maybe<Rate_Request_Bool_Exp>;
  rate_request_id?: Maybe<Uuid_Comparison_Exp>;
  rate_selected_by?: Maybe<Rate_Selected_By_Bool_Exp>;
  selected_by?: Maybe<Rate_Selected_By_Enum_Comparison_Exp>;
  service?: Maybe<String_Comparison_Exp>;
  service_code?: Maybe<String_Comparison_Exp>;
  shipping_provider?: Maybe<Shipping_Provider_Bool_Exp>;
  source?: Maybe<Shipping_Provider_Enum_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "shipping_rate" */
export const Shipping_Rate_Constraint = {
  /** unique or primary key constraint on columns "id" */
  ShippingRatePkey: 'shipping_rate_pkey'
} as const;

export type Shipping_Rate_Constraint = typeof Shipping_Rate_Constraint[keyof typeof Shipping_Rate_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Shipping_Rate_Delete_At_Path_Input = {
  errors?: Maybe<Array<Scalars['String']>>;
  integrations?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Shipping_Rate_Delete_Elem_Input = {
  errors?: Maybe<Scalars['Int']>;
  integrations?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Shipping_Rate_Delete_Key_Input = {
  errors?: Maybe<Scalars['String']>;
  integrations?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "shipping_rate" */
export type Shipping_Rate_Inc_Input = {
  amount?: Maybe<Scalars['Int']>;
  delivery_days?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "shipping_rate" */
export type Shipping_Rate_Insert_Input = {
  amount?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  carrier_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  delivery_days?: Maybe<Scalars['Int']>;
  errors?: Maybe<Scalars['jsonb']>;
  external_entity_id?: Maybe<Scalars['String']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  location_id?: Maybe<Scalars['uuid']>;
  rate_request?: Maybe<Rate_Request_Obj_Rel_Insert_Input>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  rate_selected_by?: Maybe<Rate_Selected_By_Obj_Rel_Insert_Input>;
  selected_by?: Maybe<Rate_Selected_By_Enum>;
  service?: Maybe<Scalars['String']>;
  service_code?: Maybe<Scalars['String']>;
  shipping_provider?: Maybe<Shipping_Provider_Obj_Rel_Insert_Input>;
  source?: Maybe<Shipping_Provider_Enum>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Shipping_Rate_Max_Fields = {
  amount?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  carrier_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  delivery_days?: Maybe<Scalars['Int']>;
  external_entity_id?: Maybe<Scalars['String']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  location_id?: Maybe<Scalars['uuid']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  service?: Maybe<Scalars['String']>;
  service_code?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "shipping_rate" */
export type Shipping_Rate_Max_Order_By = {
  amount?: Maybe<Order_By>;
  carrier?: Maybe<Order_By>;
  carrier_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  currency?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  rate_request_id?: Maybe<Order_By>;
  service?: Maybe<Order_By>;
  service_code?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Shipping_Rate_Min_Fields = {
  amount?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  carrier_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  delivery_days?: Maybe<Scalars['Int']>;
  external_entity_id?: Maybe<Scalars['String']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  location_id?: Maybe<Scalars['uuid']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  service?: Maybe<Scalars['String']>;
  service_code?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "shipping_rate" */
export type Shipping_Rate_Min_Order_By = {
  amount?: Maybe<Order_By>;
  carrier?: Maybe<Order_By>;
  carrier_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  currency?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  rate_request_id?: Maybe<Order_By>;
  service?: Maybe<Order_By>;
  service_code?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "shipping_rate" */
export type Shipping_Rate_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shipping_Rate>;
};

/** input type for inserting object relation for remote table "shipping_rate" */
export type Shipping_Rate_Obj_Rel_Insert_Input = {
  data: Shipping_Rate_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Shipping_Rate_On_Conflict>;
};

/** on_conflict condition type for table "shipping_rate" */
export type Shipping_Rate_On_Conflict = {
  constraint: Shipping_Rate_Constraint;
  update_columns?: Array<Shipping_Rate_Update_Column>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};

/** Ordering options when selecting data from "shipping_rate". */
export type Shipping_Rate_Order_By = {
  amount?: Maybe<Order_By>;
  carrier?: Maybe<Order_By>;
  carrier_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  currency?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
  errors?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  fulfilment_shipment_id?: Maybe<Order_By>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  integrations?: Maybe<Order_By>;
  location_id?: Maybe<Order_By>;
  rate_request?: Maybe<Rate_Request_Order_By>;
  rate_request_id?: Maybe<Order_By>;
  rate_selected_by?: Maybe<Rate_Selected_By_Order_By>;
  selected_by?: Maybe<Order_By>;
  service?: Maybe<Order_By>;
  service_code?: Maybe<Order_By>;
  shipping_provider?: Maybe<Shipping_Provider_Order_By>;
  source?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
};

/** primary key columns input for table: shipping_rate */
export type Shipping_Rate_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Shipping_Rate_Prepend_Input = {
  errors?: Maybe<Scalars['jsonb']>;
  integrations?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "shipping_rate" */
export const Shipping_Rate_Select_Column = {
  /** column name */
  Amount: 'amount',
  /** column name */
  Carrier: 'carrier',
  /** column name */
  CarrierCode: 'carrier_code',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Currency: 'currency',
  /** column name */
  DeliveryDays: 'delivery_days',
  /** column name */
  Errors: 'errors',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  LocationId: 'location_id',
  /** column name */
  RateRequestId: 'rate_request_id',
  /** column name */
  SelectedBy: 'selected_by',
  /** column name */
  Service: 'service',
  /** column name */
  ServiceCode: 'service_code',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id'
} as const;

export type Shipping_Rate_Select_Column = typeof Shipping_Rate_Select_Column[keyof typeof Shipping_Rate_Select_Column];
/** input type for updating data in table "shipping_rate" */
export type Shipping_Rate_Set_Input = {
  amount?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  carrier_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  delivery_days?: Maybe<Scalars['Int']>;
  errors?: Maybe<Scalars['jsonb']>;
  external_entity_id?: Maybe<Scalars['String']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  location_id?: Maybe<Scalars['uuid']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  selected_by?: Maybe<Rate_Selected_By_Enum>;
  service?: Maybe<Scalars['String']>;
  service_code?: Maybe<Scalars['String']>;
  source?: Maybe<Shipping_Provider_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Shipping_Rate_Stddev_Fields = {
  amount?: Maybe<Scalars['Float']>;
  delivery_days?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "shipping_rate" */
export type Shipping_Rate_Stddev_Order_By = {
  amount?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Shipping_Rate_Stddev_Pop_Fields = {
  amount?: Maybe<Scalars['Float']>;
  delivery_days?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "shipping_rate" */
export type Shipping_Rate_Stddev_Pop_Order_By = {
  amount?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Shipping_Rate_Stddev_Samp_Fields = {
  amount?: Maybe<Scalars['Float']>;
  delivery_days?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "shipping_rate" */
export type Shipping_Rate_Stddev_Samp_Order_By = {
  amount?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
};

/** Streaming cursor of the table "shipping_rate" */
export type Shipping_Rate_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Shipping_Rate_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Shipping_Rate_Stream_Cursor_Value_Input = {
  amount?: Maybe<Scalars['Int']>;
  carrier?: Maybe<Scalars['String']>;
  carrier_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  delivery_days?: Maybe<Scalars['Int']>;
  errors?: Maybe<Scalars['jsonb']>;
  external_entity_id?: Maybe<Scalars['String']>;
  fulfilment_shipment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  integrations?: Maybe<Scalars['jsonb']>;
  location_id?: Maybe<Scalars['uuid']>;
  rate_request_id?: Maybe<Scalars['uuid']>;
  selected_by?: Maybe<Rate_Selected_By_Enum>;
  service?: Maybe<Scalars['String']>;
  service_code?: Maybe<Scalars['String']>;
  source?: Maybe<Shipping_Provider_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Shipping_Rate_Sum_Fields = {
  amount?: Maybe<Scalars['Int']>;
  delivery_days?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "shipping_rate" */
export type Shipping_Rate_Sum_Order_By = {
  amount?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
};

/** update columns of table "shipping_rate" */
export const Shipping_Rate_Update_Column = {
  /** column name */
  Amount: 'amount',
  /** column name */
  Carrier: 'carrier',
  /** column name */
  CarrierCode: 'carrier_code',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Currency: 'currency',
  /** column name */
  DeliveryDays: 'delivery_days',
  /** column name */
  Errors: 'errors',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  FulfilmentShipmentId: 'fulfilment_shipment_id',
  /** column name */
  Id: 'id',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  LocationId: 'location_id',
  /** column name */
  RateRequestId: 'rate_request_id',
  /** column name */
  SelectedBy: 'selected_by',
  /** column name */
  Service: 'service',
  /** column name */
  ServiceCode: 'service_code',
  /** column name */
  Source: 'source',
  /** column name */
  StoreId: 'store_id'
} as const;

export type Shipping_Rate_Update_Column = typeof Shipping_Rate_Update_Column[keyof typeof Shipping_Rate_Update_Column];
export type Shipping_Rate_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Shipping_Rate_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Shipping_Rate_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Shipping_Rate_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Shipping_Rate_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Shipping_Rate_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Shipping_Rate_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Shipping_Rate_Set_Input>;
  /** filter the rows which have to be updated */
  where: Shipping_Rate_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Shipping_Rate_Var_Pop_Fields = {
  amount?: Maybe<Scalars['Float']>;
  delivery_days?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "shipping_rate" */
export type Shipping_Rate_Var_Pop_Order_By = {
  amount?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Shipping_Rate_Var_Samp_Fields = {
  amount?: Maybe<Scalars['Float']>;
  delivery_days?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "shipping_rate" */
export type Shipping_Rate_Var_Samp_Order_By = {
  amount?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Shipping_Rate_Variance_Fields = {
  amount?: Maybe<Scalars['Float']>;
  delivery_days?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "shipping_rate" */
export type Shipping_Rate_Variance_Order_By = {
  amount?: Maybe<Order_By>;
  delivery_days?: Maybe<Order_By>;
};

/** columns and relationships of "shopify.integration" */
export type Shopify_Integration = {
  connected_at?: Maybe<Scalars['timestamptz']>;
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  is_active: Scalars['Boolean'];
  scope?: Maybe<Scalars['jsonb']>;
  shop_access_token?: Maybe<Scalars['String']>;
  shop_access_token_iv_hex?: Maybe<Scalars['String']>;
  shop_domain: Scalars['String'];
  /** An object relationship */
  store?: Maybe<Store>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "shopify.integration" */
export type Shopify_IntegrationScopeArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "shopify.integration" */
export type Shopify_Integration_Aggregate = {
  aggregate?: Maybe<Shopify_Integration_Aggregate_Fields>;
  nodes: Array<Shopify_Integration>;
};

export type Shopify_Integration_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Shopify_Integration_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Shopify_Integration_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Shopify_Integration_Aggregate_Bool_Exp_Count>;
};

export type Shopify_Integration_Aggregate_Bool_Exp_Bool_And = {
  arguments: Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Shopify_Integration_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Shopify_Integration_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Shopify_Integration_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Shopify_Integration_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Shopify_Integration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Shopify_Integration_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "shopify.integration" */
export type Shopify_Integration_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Shopify_Integration_Max_Fields>;
  min?: Maybe<Shopify_Integration_Min_Fields>;
};


/** aggregate fields of "shopify.integration" */
export type Shopify_Integration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Shopify_Integration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "shopify.integration" */
export type Shopify_Integration_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Shopify_Integration_Max_Order_By>;
  min?: Maybe<Shopify_Integration_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Shopify_Integration_Append_Input = {
  scope?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "shopify.integration" */
export type Shopify_Integration_Arr_Rel_Insert_Input = {
  data: Array<Shopify_Integration_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Shopify_Integration_On_Conflict>;
};

/** Boolean expression to filter rows from the table "shopify.integration". All fields are combined with a logical 'AND'. */
export type Shopify_Integration_Bool_Exp = {
  _and?: Maybe<Array<Shopify_Integration_Bool_Exp>>;
  _not?: Maybe<Shopify_Integration_Bool_Exp>;
  _or?: Maybe<Array<Shopify_Integration_Bool_Exp>>;
  connected_at?: Maybe<Timestamptz_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  scope?: Maybe<Jsonb_Comparison_Exp>;
  shop_access_token?: Maybe<String_Comparison_Exp>;
  shop_access_token_iv_hex?: Maybe<String_Comparison_Exp>;
  shop_domain?: Maybe<String_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "shopify.integration" */
export const Shopify_Integration_Constraint = {
  /** unique or primary key constraint on columns "id" */
  IntegrationPkey: 'integration_pkey',
  /** unique or primary key constraint on columns "shop_domain" */
  IntegrationShopDomainKey: 'integration_shop_domain_key'
} as const;

export type Shopify_Integration_Constraint = typeof Shopify_Integration_Constraint[keyof typeof Shopify_Integration_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Shopify_Integration_Delete_At_Path_Input = {
  scope?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Shopify_Integration_Delete_Elem_Input = {
  scope?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Shopify_Integration_Delete_Key_Input = {
  scope?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "shopify.integration" */
export type Shopify_Integration_Insert_Input = {
  connected_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  scope?: Maybe<Scalars['jsonb']>;
  shop_access_token?: Maybe<Scalars['String']>;
  shop_access_token_iv_hex?: Maybe<Scalars['String']>;
  shop_domain?: Maybe<Scalars['String']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Shopify_Integration_Max_Fields = {
  connected_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  shop_access_token?: Maybe<Scalars['String']>;
  shop_access_token_iv_hex?: Maybe<Scalars['String']>;
  shop_domain?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "shopify.integration" */
export type Shopify_Integration_Max_Order_By = {
  connected_at?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  shop_access_token?: Maybe<Order_By>;
  shop_access_token_iv_hex?: Maybe<Order_By>;
  shop_domain?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Shopify_Integration_Min_Fields = {
  connected_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  shop_access_token?: Maybe<Scalars['String']>;
  shop_access_token_iv_hex?: Maybe<Scalars['String']>;
  shop_domain?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "shopify.integration" */
export type Shopify_Integration_Min_Order_By = {
  connected_at?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  shop_access_token?: Maybe<Order_By>;
  shop_access_token_iv_hex?: Maybe<Order_By>;
  shop_domain?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "shopify.integration" */
export type Shopify_Integration_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shopify_Integration>;
};

/** input type for inserting object relation for remote table "shopify.integration" */
export type Shopify_Integration_Obj_Rel_Insert_Input = {
  data: Shopify_Integration_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Shopify_Integration_On_Conflict>;
};

/** on_conflict condition type for table "shopify.integration" */
export type Shopify_Integration_On_Conflict = {
  constraint: Shopify_Integration_Constraint;
  update_columns?: Array<Shopify_Integration_Update_Column>;
  where?: Maybe<Shopify_Integration_Bool_Exp>;
};

/** Ordering options when selecting data from "shopify.integration". */
export type Shopify_Integration_Order_By = {
  connected_at?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  scope?: Maybe<Order_By>;
  shop_access_token?: Maybe<Order_By>;
  shop_access_token_iv_hex?: Maybe<Order_By>;
  shop_domain?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: shopify.integration */
export type Shopify_Integration_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Shopify_Integration_Prepend_Input = {
  scope?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "shopify.integration" */
export const Shopify_Integration_Select_Column = {
  /** column name */
  ConnectedAt: 'connected_at',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  IsActive: 'is_active',
  /** column name */
  Scope: 'scope',
  /** column name */
  ShopAccessToken: 'shop_access_token',
  /** column name */
  ShopAccessTokenIvHex: 'shop_access_token_iv_hex',
  /** column name */
  ShopDomain: 'shop_domain',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Shopify_Integration_Select_Column = typeof Shopify_Integration_Select_Column[keyof typeof Shopify_Integration_Select_Column];
/** select "shopify_integration_aggregate_bool_exp_bool_and_arguments_columns" columns of table "shopify.integration" */
export const Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  IsActive: 'is_active'
} as const;

export type Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "shopify_integration_aggregate_bool_exp_bool_or_arguments_columns" columns of table "shopify.integration" */
export const Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  IsActive: 'is_active'
} as const;

export type Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Shopify_Integration_Select_Column_Shopify_Integration_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "shopify.integration" */
export type Shopify_Integration_Set_Input = {
  connected_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  scope?: Maybe<Scalars['jsonb']>;
  shop_access_token?: Maybe<Scalars['String']>;
  shop_access_token_iv_hex?: Maybe<Scalars['String']>;
  shop_domain?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "shopify_integration" */
export type Shopify_Integration_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Shopify_Integration_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Shopify_Integration_Stream_Cursor_Value_Input = {
  connected_at?: Maybe<Scalars['timestamptz']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  scope?: Maybe<Scalars['jsonb']>;
  shop_access_token?: Maybe<Scalars['String']>;
  shop_access_token_iv_hex?: Maybe<Scalars['String']>;
  shop_domain?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "shopify.integration" */
export const Shopify_Integration_Update_Column = {
  /** column name */
  ConnectedAt: 'connected_at',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  IsActive: 'is_active',
  /** column name */
  Scope: 'scope',
  /** column name */
  ShopAccessToken: 'shop_access_token',
  /** column name */
  ShopAccessTokenIvHex: 'shop_access_token_iv_hex',
  /** column name */
  ShopDomain: 'shop_domain',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Shopify_Integration_Update_Column = typeof Shopify_Integration_Update_Column[keyof typeof Shopify_Integration_Update_Column];
export type Shopify_Integration_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Shopify_Integration_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Shopify_Integration_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Shopify_Integration_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Shopify_Integration_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Shopify_Integration_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Shopify_Integration_Set_Input>;
  /** filter the rows which have to be updated */
  where: Shopify_Integration_Bool_Exp;
};

/** This is an append only table of received Shopify webhook payloads. */
export type Shopify_Order_Archive = {
  created_at: Scalars['timestamptz'];
  external_entity_id: Scalars['String'];
  id: Scalars['uuid'];
  payload: Scalars['jsonb'];
};


/** This is an append only table of received Shopify webhook payloads. */
export type Shopify_Order_ArchivePayloadArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "shopify.order_archive" */
export type Shopify_Order_Archive_Aggregate = {
  aggregate?: Maybe<Shopify_Order_Archive_Aggregate_Fields>;
  nodes: Array<Shopify_Order_Archive>;
};

/** aggregate fields of "shopify.order_archive" */
export type Shopify_Order_Archive_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Shopify_Order_Archive_Max_Fields>;
  min?: Maybe<Shopify_Order_Archive_Min_Fields>;
};


/** aggregate fields of "shopify.order_archive" */
export type Shopify_Order_Archive_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Shopify_Order_Archive_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Shopify_Order_Archive_Append_Input = {
  payload?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "shopify.order_archive". All fields are combined with a logical 'AND'. */
export type Shopify_Order_Archive_Bool_Exp = {
  _and?: Maybe<Array<Shopify_Order_Archive_Bool_Exp>>;
  _not?: Maybe<Shopify_Order_Archive_Bool_Exp>;
  _or?: Maybe<Array<Shopify_Order_Archive_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  external_entity_id?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  payload?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "shopify.order_archive" */
export const Shopify_Order_Archive_Constraint = {
  /** unique or primary key constraint on columns "id" */
  OrderArchivePkey: 'order_archive_pkey'
} as const;

export type Shopify_Order_Archive_Constraint = typeof Shopify_Order_Archive_Constraint[keyof typeof Shopify_Order_Archive_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Shopify_Order_Archive_Delete_At_Path_Input = {
  payload?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Shopify_Order_Archive_Delete_Elem_Input = {
  payload?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Shopify_Order_Archive_Delete_Key_Input = {
  payload?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "shopify.order_archive" */
export type Shopify_Order_Archive_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  payload?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Shopify_Order_Archive_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Shopify_Order_Archive_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "shopify.order_archive" */
export type Shopify_Order_Archive_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shopify_Order_Archive>;
};

/** on_conflict condition type for table "shopify.order_archive" */
export type Shopify_Order_Archive_On_Conflict = {
  constraint: Shopify_Order_Archive_Constraint;
  update_columns?: Array<Shopify_Order_Archive_Update_Column>;
  where?: Maybe<Shopify_Order_Archive_Bool_Exp>;
};

/** Ordering options when selecting data from "shopify.order_archive". */
export type Shopify_Order_Archive_Order_By = {
  created_at?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  payload?: Maybe<Order_By>;
};

/** primary key columns input for table: shopify.order_archive */
export type Shopify_Order_Archive_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Shopify_Order_Archive_Prepend_Input = {
  payload?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "shopify.order_archive" */
export const Shopify_Order_Archive_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  Payload: 'payload'
} as const;

export type Shopify_Order_Archive_Select_Column = typeof Shopify_Order_Archive_Select_Column[keyof typeof Shopify_Order_Archive_Select_Column];
/** input type for updating data in table "shopify.order_archive" */
export type Shopify_Order_Archive_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  payload?: Maybe<Scalars['jsonb']>;
};

/** Streaming cursor of the table "shopify_order_archive" */
export type Shopify_Order_Archive_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Shopify_Order_Archive_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Shopify_Order_Archive_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  payload?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "shopify.order_archive" */
export const Shopify_Order_Archive_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  Id: 'id',
  /** column name */
  Payload: 'payload'
} as const;

export type Shopify_Order_Archive_Update_Column = typeof Shopify_Order_Archive_Update_Column[keyof typeof Shopify_Order_Archive_Update_Column];
export type Shopify_Order_Archive_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Shopify_Order_Archive_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Shopify_Order_Archive_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Shopify_Order_Archive_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Shopify_Order_Archive_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Shopify_Order_Archive_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Shopify_Order_Archive_Set_Input>;
  /** filter the rows which have to be updated */
  where: Shopify_Order_Archive_Bool_Exp;
};

/** columns and relationships of "stock_transfer" */
export type Stock_Transfer = {
  created_at: Scalars['timestamptz'];
  external_entity_id?: Maybe<Scalars['String']>;
  finalised_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['bigint'];
  label_path?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  reference_number: Scalars['Int'];
  status: Stock_Transfer_Status_Enum;
  /** An object relationship */
  stock_transfer_status: Stock_Transfer_Status;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  /** An array relationship */
  transfer_items: Array<Stock_Transfer_Item>;
  /** An aggregate relationship */
  transfer_items_aggregate: Stock_Transfer_Item_Aggregate;
  /** An array relationship */
  transfer_parcels: Array<Stock_Transfer_Parcel>;
  /** An aggregate relationship */
  transfer_parcels_aggregate: Stock_Transfer_Parcel_Aggregate;
  /** An array relationship */
  transfer_shipments: Array<Stock_Transfer_Shipment>;
  /** An aggregate relationship */
  transfer_shipments_aggregate: Stock_Transfer_Shipment_Aggregate;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "stock_transfer" */
export type Stock_TransferTransfer_ItemsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


/** columns and relationships of "stock_transfer" */
export type Stock_TransferTransfer_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


/** columns and relationships of "stock_transfer" */
export type Stock_TransferTransfer_ParcelsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


/** columns and relationships of "stock_transfer" */
export type Stock_TransferTransfer_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


/** columns and relationships of "stock_transfer" */
export type Stock_TransferTransfer_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};


/** columns and relationships of "stock_transfer" */
export type Stock_TransferTransfer_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};

/** aggregated selection of "stock_transfer" */
export type Stock_Transfer_Aggregate = {
  aggregate?: Maybe<Stock_Transfer_Aggregate_Fields>;
  nodes: Array<Stock_Transfer>;
};

export type Stock_Transfer_Aggregate_Bool_Exp = {
  count?: Maybe<Stock_Transfer_Aggregate_Bool_Exp_Count>;
};

export type Stock_Transfer_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Stock_Transfer_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Stock_Transfer_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "stock_transfer" */
export type Stock_Transfer_Aggregate_Fields = {
  avg?: Maybe<Stock_Transfer_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Stock_Transfer_Max_Fields>;
  min?: Maybe<Stock_Transfer_Min_Fields>;
  stddev?: Maybe<Stock_Transfer_Stddev_Fields>;
  stddev_pop?: Maybe<Stock_Transfer_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Stock_Transfer_Stddev_Samp_Fields>;
  sum?: Maybe<Stock_Transfer_Sum_Fields>;
  var_pop?: Maybe<Stock_Transfer_Var_Pop_Fields>;
  var_samp?: Maybe<Stock_Transfer_Var_Samp_Fields>;
  variance?: Maybe<Stock_Transfer_Variance_Fields>;
};


/** aggregate fields of "stock_transfer" */
export type Stock_Transfer_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Stock_Transfer_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stock_transfer" */
export type Stock_Transfer_Aggregate_Order_By = {
  avg?: Maybe<Stock_Transfer_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Stock_Transfer_Max_Order_By>;
  min?: Maybe<Stock_Transfer_Min_Order_By>;
  stddev?: Maybe<Stock_Transfer_Stddev_Order_By>;
  stddev_pop?: Maybe<Stock_Transfer_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Stock_Transfer_Stddev_Samp_Order_By>;
  sum?: Maybe<Stock_Transfer_Sum_Order_By>;
  var_pop?: Maybe<Stock_Transfer_Var_Pop_Order_By>;
  var_samp?: Maybe<Stock_Transfer_Var_Samp_Order_By>;
  variance?: Maybe<Stock_Transfer_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "stock_transfer" */
export type Stock_Transfer_Arr_Rel_Insert_Input = {
  data: Array<Stock_Transfer_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Stock_Transfer_On_Conflict>;
};

/** aggregate avg on columns */
export type Stock_Transfer_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  reference_number?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stock_transfer" */
export type Stock_Transfer_Avg_Order_By = {
  id?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "stock_transfer". All fields are combined with a logical 'AND'. */
export type Stock_Transfer_Bool_Exp = {
  _and?: Maybe<Array<Stock_Transfer_Bool_Exp>>;
  _not?: Maybe<Stock_Transfer_Bool_Exp>;
  _or?: Maybe<Array<Stock_Transfer_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  external_entity_id?: Maybe<String_Comparison_Exp>;
  finalised_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  label_path?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  notes?: Maybe<String_Comparison_Exp>;
  reference_number?: Maybe<Int_Comparison_Exp>;
  status?: Maybe<Stock_Transfer_Status_Enum_Comparison_Exp>;
  stock_transfer_status?: Maybe<Stock_Transfer_Status_Bool_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  transfer_items?: Maybe<Stock_Transfer_Item_Bool_Exp>;
  transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Bool_Exp>;
  transfer_parcels?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
  transfer_parcels_aggregate?: Maybe<Stock_Transfer_Parcel_Aggregate_Bool_Exp>;
  transfer_shipments?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
  transfer_shipments_aggregate?: Maybe<Stock_Transfer_Shipment_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "stock_transfer" */
export const Stock_Transfer_Constraint = {
  /** unique or primary key constraint on columns "id" */
  StockTransferPk: 'stock_transfer_pk',
  /** unique or primary key constraint on columns "store_id", "reference_number" */
  StockTransferUniqueReferenceNumberForStoreId: 'stock_transfer_unique_reference_number_for_store_id'
} as const;

export type Stock_Transfer_Constraint = typeof Stock_Transfer_Constraint[keyof typeof Stock_Transfer_Constraint];
/** input type for incrementing numeric columns in table "stock_transfer" */
export type Stock_Transfer_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  reference_number?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "stock_transfer" */
export type Stock_Transfer_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  finalised_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  reference_number?: Maybe<Scalars['Int']>;
  status?: Maybe<Stock_Transfer_Status_Enum>;
  stock_transfer_status?: Maybe<Stock_Transfer_Status_Obj_Rel_Insert_Input>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  transfer_items?: Maybe<Stock_Transfer_Item_Arr_Rel_Insert_Input>;
  transfer_parcels?: Maybe<Stock_Transfer_Parcel_Arr_Rel_Insert_Input>;
  transfer_shipments?: Maybe<Stock_Transfer_Shipment_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "stock_transfer_item" */
export type Stock_Transfer_Item = {
  created_at: Scalars['timestamptz'];
  id: Scalars['bigint'];
  /** An object relationship */
  inventory_item: Inventory_Item;
  inventory_item_id: Scalars['bigint'];
  /** An object relationship */
  location?: Maybe<Location>;
  quantity: Scalars['Int'];
  quantity_received: Scalars['Int'];
  source_location_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  stock_transfer: Stock_Transfer;
  stock_transfer_id: Scalars['bigint'];
  /** An object relationship */
  stock_transfer_parcel?: Maybe<Stock_Transfer_Parcel>;
  stock_transfer_parcel_id?: Maybe<Scalars['bigint']>;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "stock_transfer_item" */
export type Stock_Transfer_Item_Aggregate = {
  aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Fields>;
  nodes: Array<Stock_Transfer_Item>;
};

export type Stock_Transfer_Item_Aggregate_Bool_Exp = {
  count?: Maybe<Stock_Transfer_Item_Aggregate_Bool_Exp_Count>;
};

export type Stock_Transfer_Item_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Stock_Transfer_Item_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "stock_transfer_item" */
export type Stock_Transfer_Item_Aggregate_Fields = {
  avg?: Maybe<Stock_Transfer_Item_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Stock_Transfer_Item_Max_Fields>;
  min?: Maybe<Stock_Transfer_Item_Min_Fields>;
  stddev?: Maybe<Stock_Transfer_Item_Stddev_Fields>;
  stddev_pop?: Maybe<Stock_Transfer_Item_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Stock_Transfer_Item_Stddev_Samp_Fields>;
  sum?: Maybe<Stock_Transfer_Item_Sum_Fields>;
  var_pop?: Maybe<Stock_Transfer_Item_Var_Pop_Fields>;
  var_samp?: Maybe<Stock_Transfer_Item_Var_Samp_Fields>;
  variance?: Maybe<Stock_Transfer_Item_Variance_Fields>;
};


/** aggregate fields of "stock_transfer_item" */
export type Stock_Transfer_Item_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stock_transfer_item" */
export type Stock_Transfer_Item_Aggregate_Order_By = {
  avg?: Maybe<Stock_Transfer_Item_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Stock_Transfer_Item_Max_Order_By>;
  min?: Maybe<Stock_Transfer_Item_Min_Order_By>;
  stddev?: Maybe<Stock_Transfer_Item_Stddev_Order_By>;
  stddev_pop?: Maybe<Stock_Transfer_Item_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Stock_Transfer_Item_Stddev_Samp_Order_By>;
  sum?: Maybe<Stock_Transfer_Item_Sum_Order_By>;
  var_pop?: Maybe<Stock_Transfer_Item_Var_Pop_Order_By>;
  var_samp?: Maybe<Stock_Transfer_Item_Var_Samp_Order_By>;
  variance?: Maybe<Stock_Transfer_Item_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "stock_transfer_item" */
export type Stock_Transfer_Item_Arr_Rel_Insert_Input = {
  data: Array<Stock_Transfer_Item_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Stock_Transfer_Item_On_Conflict>;
};

/** aggregate avg on columns */
export type Stock_Transfer_Item_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_received?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  stock_transfer_parcel_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Avg_Order_By = {
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "stock_transfer_item". All fields are combined with a logical 'AND'. */
export type Stock_Transfer_Item_Bool_Exp = {
  _and?: Maybe<Array<Stock_Transfer_Item_Bool_Exp>>;
  _not?: Maybe<Stock_Transfer_Item_Bool_Exp>;
  _or?: Maybe<Array<Stock_Transfer_Item_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  inventory_item?: Maybe<Inventory_Item_Bool_Exp>;
  inventory_item_id?: Maybe<Bigint_Comparison_Exp>;
  location?: Maybe<Location_Bool_Exp>;
  quantity?: Maybe<Int_Comparison_Exp>;
  quantity_received?: Maybe<Int_Comparison_Exp>;
  source_location_id?: Maybe<Uuid_Comparison_Exp>;
  stock_transfer?: Maybe<Stock_Transfer_Bool_Exp>;
  stock_transfer_id?: Maybe<Bigint_Comparison_Exp>;
  stock_transfer_parcel?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
  stock_transfer_parcel_id?: Maybe<Bigint_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "stock_transfer_item" */
export const Stock_Transfer_Item_Constraint = {
  /** unique or primary key constraint on columns "id" */
  StockTransferItemPkey: 'stock_transfer_item_pkey'
} as const;

export type Stock_Transfer_Item_Constraint = typeof Stock_Transfer_Item_Constraint[keyof typeof Stock_Transfer_Item_Constraint];
/** input type for incrementing numeric columns in table "stock_transfer_item" */
export type Stock_Transfer_Item_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_received?: Maybe<Scalars['Int']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  stock_transfer_parcel_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stock_transfer_item" */
export type Stock_Transfer_Item_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  inventory_item?: Maybe<Inventory_Item_Obj_Rel_Insert_Input>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  location?: Maybe<Location_Obj_Rel_Insert_Input>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_received?: Maybe<Scalars['Int']>;
  source_location_id?: Maybe<Scalars['uuid']>;
  stock_transfer?: Maybe<Stock_Transfer_Obj_Rel_Insert_Input>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  stock_transfer_parcel?: Maybe<Stock_Transfer_Parcel_Obj_Rel_Insert_Input>;
  stock_transfer_parcel_id?: Maybe<Scalars['bigint']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Stock_Transfer_Item_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_received?: Maybe<Scalars['Int']>;
  source_location_id?: Maybe<Scalars['uuid']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  stock_transfer_parcel_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  source_location_id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Stock_Transfer_Item_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_received?: Maybe<Scalars['Int']>;
  source_location_id?: Maybe<Scalars['uuid']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  stock_transfer_parcel_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  source_location_id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "stock_transfer_item" */
export type Stock_Transfer_Item_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Stock_Transfer_Item>;
};

/** on_conflict condition type for table "stock_transfer_item" */
export type Stock_Transfer_Item_On_Conflict = {
  constraint: Stock_Transfer_Item_Constraint;
  update_columns?: Array<Stock_Transfer_Item_Update_Column>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};

/** Ordering options when selecting data from "stock_transfer_item". */
export type Stock_Transfer_Item_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  inventory_item?: Maybe<Inventory_Item_Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  location?: Maybe<Location_Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  source_location_id?: Maybe<Order_By>;
  stock_transfer?: Maybe<Stock_Transfer_Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel?: Maybe<Stock_Transfer_Parcel_Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: stock_transfer_item */
export type Stock_Transfer_Item_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "stock_transfer_item" */
export const Stock_Transfer_Item_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  InventoryItemId: 'inventory_item_id',
  /** column name */
  Quantity: 'quantity',
  /** column name */
  QuantityReceived: 'quantity_received',
  /** column name */
  SourceLocationId: 'source_location_id',
  /** column name */
  StockTransferId: 'stock_transfer_id',
  /** column name */
  StockTransferParcelId: 'stock_transfer_parcel_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Stock_Transfer_Item_Select_Column = typeof Stock_Transfer_Item_Select_Column[keyof typeof Stock_Transfer_Item_Select_Column];
/** input type for updating data in table "stock_transfer_item" */
export type Stock_Transfer_Item_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_received?: Maybe<Scalars['Int']>;
  source_location_id?: Maybe<Scalars['uuid']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  stock_transfer_parcel_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Stock_Transfer_Item_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_received?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  stock_transfer_parcel_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Stock_Transfer_Item_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_received?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  stock_transfer_parcel_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Stock_Transfer_Item_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_received?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  stock_transfer_parcel_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "stock_transfer_item" */
export type Stock_Transfer_Item_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Stock_Transfer_Item_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Stock_Transfer_Item_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_received?: Maybe<Scalars['Int']>;
  source_location_id?: Maybe<Scalars['uuid']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  stock_transfer_parcel_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Stock_Transfer_Item_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  inventory_item_id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['Int']>;
  quantity_received?: Maybe<Scalars['Int']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  stock_transfer_parcel_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Sum_Order_By = {
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
};

/** update columns of table "stock_transfer_item" */
export const Stock_Transfer_Item_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  InventoryItemId: 'inventory_item_id',
  /** column name */
  Quantity: 'quantity',
  /** column name */
  QuantityReceived: 'quantity_received',
  /** column name */
  SourceLocationId: 'source_location_id',
  /** column name */
  StockTransferId: 'stock_transfer_id',
  /** column name */
  StockTransferParcelId: 'stock_transfer_parcel_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Stock_Transfer_Item_Update_Column = typeof Stock_Transfer_Item_Update_Column[keyof typeof Stock_Transfer_Item_Update_Column];
export type Stock_Transfer_Item_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Stock_Transfer_Item_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Stock_Transfer_Item_Set_Input>;
  /** filter the rows which have to be updated */
  where: Stock_Transfer_Item_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Stock_Transfer_Item_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_received?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  stock_transfer_parcel_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Stock_Transfer_Item_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_received?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  stock_transfer_parcel_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Stock_Transfer_Item_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  inventory_item_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  quantity_received?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  stock_transfer_parcel_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stock_transfer_item" */
export type Stock_Transfer_Item_Variance_Order_By = {
  id?: Maybe<Order_By>;
  inventory_item_id?: Maybe<Order_By>;
  quantity?: Maybe<Order_By>;
  quantity_received?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_parcel_id?: Maybe<Order_By>;
};

/** aggregate max on columns */
export type Stock_Transfer_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  finalised_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  reference_number?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "stock_transfer" */
export type Stock_Transfer_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  finalised_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  label_path?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  notes?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Stock_Transfer_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  finalised_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  reference_number?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "stock_transfer" */
export type Stock_Transfer_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  finalised_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  label_path?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  notes?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "stock_transfer" */
export type Stock_Transfer_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Stock_Transfer>;
};

/** input type for inserting object relation for remote table "stock_transfer" */
export type Stock_Transfer_Obj_Rel_Insert_Input = {
  data: Stock_Transfer_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Stock_Transfer_On_Conflict>;
};

/** on_conflict condition type for table "stock_transfer" */
export type Stock_Transfer_On_Conflict = {
  constraint: Stock_Transfer_Constraint;
  update_columns?: Array<Stock_Transfer_Update_Column>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};

/** Ordering options when selecting data from "stock_transfer". */
export type Stock_Transfer_Order_By = {
  created_at?: Maybe<Order_By>;
  external_entity_id?: Maybe<Order_By>;
  finalised_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  label_path?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  notes?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  stock_transfer_status?: Maybe<Stock_Transfer_Status_Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Order_By>;
  transfer_parcels_aggregate?: Maybe<Stock_Transfer_Parcel_Aggregate_Order_By>;
  transfer_shipments_aggregate?: Maybe<Stock_Transfer_Shipment_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** columns and relationships of "stock_transfer_parcel" */
export type Stock_Transfer_Parcel = {
  created_at: Scalars['timestamptz'];
  height?: Maybe<Scalars['numeric']>;
  id: Scalars['bigint'];
  label_path?: Maybe<Scalars['String']>;
  length?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  parcel_type: Parcel_Type;
  parcel_type_id: Scalars['uuid'];
  /** An object relationship */
  stock_transfer: Stock_Transfer;
  stock_transfer_id: Scalars['bigint'];
  /** An array relationship */
  stock_transfer_items: Array<Stock_Transfer_Item>;
  /** An aggregate relationship */
  stock_transfer_items_aggregate: Stock_Transfer_Item_Aggregate;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};


/** columns and relationships of "stock_transfer_parcel" */
export type Stock_Transfer_ParcelStock_Transfer_ItemsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


/** columns and relationships of "stock_transfer_parcel" */
export type Stock_Transfer_ParcelStock_Transfer_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};

/** aggregated selection of "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Aggregate = {
  aggregate?: Maybe<Stock_Transfer_Parcel_Aggregate_Fields>;
  nodes: Array<Stock_Transfer_Parcel>;
};

export type Stock_Transfer_Parcel_Aggregate_Bool_Exp = {
  count?: Maybe<Stock_Transfer_Parcel_Aggregate_Bool_Exp_Count>;
};

export type Stock_Transfer_Parcel_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Aggregate_Fields = {
  avg?: Maybe<Stock_Transfer_Parcel_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Stock_Transfer_Parcel_Max_Fields>;
  min?: Maybe<Stock_Transfer_Parcel_Min_Fields>;
  stddev?: Maybe<Stock_Transfer_Parcel_Stddev_Fields>;
  stddev_pop?: Maybe<Stock_Transfer_Parcel_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Stock_Transfer_Parcel_Stddev_Samp_Fields>;
  sum?: Maybe<Stock_Transfer_Parcel_Sum_Fields>;
  var_pop?: Maybe<Stock_Transfer_Parcel_Var_Pop_Fields>;
  var_samp?: Maybe<Stock_Transfer_Parcel_Var_Samp_Fields>;
  variance?: Maybe<Stock_Transfer_Parcel_Variance_Fields>;
};


/** aggregate fields of "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Aggregate_Order_By = {
  avg?: Maybe<Stock_Transfer_Parcel_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Stock_Transfer_Parcel_Max_Order_By>;
  min?: Maybe<Stock_Transfer_Parcel_Min_Order_By>;
  stddev?: Maybe<Stock_Transfer_Parcel_Stddev_Order_By>;
  stddev_pop?: Maybe<Stock_Transfer_Parcel_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Stock_Transfer_Parcel_Stddev_Samp_Order_By>;
  sum?: Maybe<Stock_Transfer_Parcel_Sum_Order_By>;
  var_pop?: Maybe<Stock_Transfer_Parcel_Var_Pop_Order_By>;
  var_samp?: Maybe<Stock_Transfer_Parcel_Var_Samp_Order_By>;
  variance?: Maybe<Stock_Transfer_Parcel_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Arr_Rel_Insert_Input = {
  data: Array<Stock_Transfer_Parcel_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Stock_Transfer_Parcel_On_Conflict>;
};

/** aggregate avg on columns */
export type Stock_Transfer_Parcel_Avg_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Avg_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "stock_transfer_parcel". All fields are combined with a logical 'AND'. */
export type Stock_Transfer_Parcel_Bool_Exp = {
  _and?: Maybe<Array<Stock_Transfer_Parcel_Bool_Exp>>;
  _not?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
  _or?: Maybe<Array<Stock_Transfer_Parcel_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  height?: Maybe<Numeric_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  label_path?: Maybe<String_Comparison_Exp>;
  length?: Maybe<Numeric_Comparison_Exp>;
  parcel_type?: Maybe<Parcel_Type_Bool_Exp>;
  parcel_type_id?: Maybe<Uuid_Comparison_Exp>;
  stock_transfer?: Maybe<Stock_Transfer_Bool_Exp>;
  stock_transfer_id?: Maybe<Bigint_Comparison_Exp>;
  stock_transfer_items?: Maybe<Stock_Transfer_Item_Bool_Exp>;
  stock_transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Bool_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  weight?: Maybe<Numeric_Comparison_Exp>;
  width?: Maybe<Numeric_Comparison_Exp>;
};

/** unique or primary key constraints on table "stock_transfer_parcel" */
export const Stock_Transfer_Parcel_Constraint = {
  /** unique or primary key constraint on columns "id" */
  TransferParcelPk: 'transfer_parcel_pk'
} as const;

export type Stock_Transfer_Parcel_Constraint = typeof Stock_Transfer_Parcel_Constraint[keyof typeof Stock_Transfer_Parcel_Constraint];
/** input type for incrementing numeric columns in table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Inc_Input = {
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  length?: Maybe<Scalars['numeric']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  length?: Maybe<Scalars['numeric']>;
  parcel_type?: Maybe<Parcel_Type_Obj_Rel_Insert_Input>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  stock_transfer?: Maybe<Stock_Transfer_Obj_Rel_Insert_Input>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  stock_transfer_items?: Maybe<Stock_Transfer_Item_Arr_Rel_Insert_Input>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type Stock_Transfer_Parcel_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  length?: Maybe<Scalars['numeric']>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** order by max() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  label_path?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  parcel_type_id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Stock_Transfer_Parcel_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  length?: Maybe<Scalars['numeric']>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** order by min() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  label_path?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  parcel_type_id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** response of any mutation on the table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Stock_Transfer_Parcel>;
};

/** input type for inserting object relation for remote table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Obj_Rel_Insert_Input = {
  data: Stock_Transfer_Parcel_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Stock_Transfer_Parcel_On_Conflict>;
};

/** on_conflict condition type for table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_On_Conflict = {
  constraint: Stock_Transfer_Parcel_Constraint;
  update_columns?: Array<Stock_Transfer_Parcel_Update_Column>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};

/** Ordering options when selecting data from "stock_transfer_parcel". */
export type Stock_Transfer_Parcel_Order_By = {
  created_at?: Maybe<Order_By>;
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  label_path?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  parcel_type?: Maybe<Parcel_Type_Order_By>;
  parcel_type_id?: Maybe<Order_By>;
  stock_transfer?: Maybe<Stock_Transfer_Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  stock_transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** primary key columns input for table: stock_transfer_parcel */
export type Stock_Transfer_Parcel_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "stock_transfer_parcel" */
export const Stock_Transfer_Parcel_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Height: 'height',
  /** column name */
  Id: 'id',
  /** column name */
  LabelPath: 'label_path',
  /** column name */
  Length: 'length',
  /** column name */
  ParcelTypeId: 'parcel_type_id',
  /** column name */
  StockTransferId: 'stock_transfer_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  Weight: 'weight',
  /** column name */
  Width: 'width'
} as const;

export type Stock_Transfer_Parcel_Select_Column = typeof Stock_Transfer_Parcel_Select_Column[keyof typeof Stock_Transfer_Parcel_Select_Column];
/** input type for updating data in table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  length?: Maybe<Scalars['numeric']>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type Stock_Transfer_Parcel_Stddev_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Stddev_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Stock_Transfer_Parcel_Stddev_Pop_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Stddev_Pop_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Stock_Transfer_Parcel_Stddev_Samp_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Stddev_Samp_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** Streaming cursor of the table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Stock_Transfer_Parcel_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Stock_Transfer_Parcel_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  length?: Maybe<Scalars['numeric']>;
  parcel_type_id?: Maybe<Scalars['uuid']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type Stock_Transfer_Parcel_Sum_Fields = {
  height?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  length?: Maybe<Scalars['numeric']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  weight?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Sum_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** update columns of table "stock_transfer_parcel" */
export const Stock_Transfer_Parcel_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Height: 'height',
  /** column name */
  Id: 'id',
  /** column name */
  LabelPath: 'label_path',
  /** column name */
  Length: 'length',
  /** column name */
  ParcelTypeId: 'parcel_type_id',
  /** column name */
  StockTransferId: 'stock_transfer_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  Weight: 'weight',
  /** column name */
  Width: 'width'
} as const;

export type Stock_Transfer_Parcel_Update_Column = typeof Stock_Transfer_Parcel_Update_Column[keyof typeof Stock_Transfer_Parcel_Update_Column];
export type Stock_Transfer_Parcel_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Stock_Transfer_Parcel_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Stock_Transfer_Parcel_Set_Input>;
  /** filter the rows which have to be updated */
  where: Stock_Transfer_Parcel_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Stock_Transfer_Parcel_Var_Pop_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Var_Pop_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Stock_Transfer_Parcel_Var_Samp_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Var_Samp_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Stock_Transfer_Parcel_Variance_Fields = {
  height?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
  weight?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stock_transfer_parcel" */
export type Stock_Transfer_Parcel_Variance_Order_By = {
  height?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  length?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  weight?: Maybe<Order_By>;
  width?: Maybe<Order_By>;
};

/** primary key columns input for table: stock_transfer */
export type Stock_Transfer_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "stock_transfer" */
export const Stock_Transfer_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  FinalisedAt: 'finalised_at',
  /** column name */
  Id: 'id',
  /** column name */
  LabelPath: 'label_path',
  /** column name */
  Name: 'name',
  /** column name */
  Notes: 'notes',
  /** column name */
  ReferenceNumber: 'reference_number',
  /** column name */
  Status: 'status',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Stock_Transfer_Select_Column = typeof Stock_Transfer_Select_Column[keyof typeof Stock_Transfer_Select_Column];
/** input type for updating data in table "stock_transfer" */
export type Stock_Transfer_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  finalised_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  reference_number?: Maybe<Scalars['Int']>;
  status?: Maybe<Stock_Transfer_Status_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "stock_transfer_shipment" */
export type Stock_Transfer_Shipment = {
  carrier?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  destination_location_id: Scalars['uuid'];
  eta?: Maybe<Scalars['timestamptz']>;
  id: Scalars['bigint'];
  /** An object relationship */
  location: Location;
  received_at?: Maybe<Scalars['timestamptz']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  stock_transfer: Stock_Transfer;
  stock_transfer_id: Scalars['bigint'];
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Aggregate = {
  aggregate?: Maybe<Stock_Transfer_Shipment_Aggregate_Fields>;
  nodes: Array<Stock_Transfer_Shipment>;
};

export type Stock_Transfer_Shipment_Aggregate_Bool_Exp = {
  count?: Maybe<Stock_Transfer_Shipment_Aggregate_Bool_Exp_Count>;
};

export type Stock_Transfer_Shipment_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Aggregate_Fields = {
  avg?: Maybe<Stock_Transfer_Shipment_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Stock_Transfer_Shipment_Max_Fields>;
  min?: Maybe<Stock_Transfer_Shipment_Min_Fields>;
  stddev?: Maybe<Stock_Transfer_Shipment_Stddev_Fields>;
  stddev_pop?: Maybe<Stock_Transfer_Shipment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Stock_Transfer_Shipment_Stddev_Samp_Fields>;
  sum?: Maybe<Stock_Transfer_Shipment_Sum_Fields>;
  var_pop?: Maybe<Stock_Transfer_Shipment_Var_Pop_Fields>;
  var_samp?: Maybe<Stock_Transfer_Shipment_Var_Samp_Fields>;
  variance?: Maybe<Stock_Transfer_Shipment_Variance_Fields>;
};


/** aggregate fields of "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Aggregate_Order_By = {
  avg?: Maybe<Stock_Transfer_Shipment_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Stock_Transfer_Shipment_Max_Order_By>;
  min?: Maybe<Stock_Transfer_Shipment_Min_Order_By>;
  stddev?: Maybe<Stock_Transfer_Shipment_Stddev_Order_By>;
  stddev_pop?: Maybe<Stock_Transfer_Shipment_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Stock_Transfer_Shipment_Stddev_Samp_Order_By>;
  sum?: Maybe<Stock_Transfer_Shipment_Sum_Order_By>;
  var_pop?: Maybe<Stock_Transfer_Shipment_Var_Pop_Order_By>;
  var_samp?: Maybe<Stock_Transfer_Shipment_Var_Samp_Order_By>;
  variance?: Maybe<Stock_Transfer_Shipment_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Arr_Rel_Insert_Input = {
  data: Array<Stock_Transfer_Shipment_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Stock_Transfer_Shipment_On_Conflict>;
};

/** aggregate avg on columns */
export type Stock_Transfer_Shipment_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Avg_Order_By = {
  id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "stock_transfer_shipment". All fields are combined with a logical 'AND'. */
export type Stock_Transfer_Shipment_Bool_Exp = {
  _and?: Maybe<Array<Stock_Transfer_Shipment_Bool_Exp>>;
  _not?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
  _or?: Maybe<Array<Stock_Transfer_Shipment_Bool_Exp>>;
  carrier?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  destination_location_id?: Maybe<Uuid_Comparison_Exp>;
  eta?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  location?: Maybe<Location_Bool_Exp>;
  received_at?: Maybe<Timestamptz_Comparison_Exp>;
  shipped_at?: Maybe<Timestamptz_Comparison_Exp>;
  stock_transfer?: Maybe<Stock_Transfer_Bool_Exp>;
  stock_transfer_id?: Maybe<Bigint_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  tracking_number?: Maybe<String_Comparison_Exp>;
  tracking_url?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "stock_transfer_shipment" */
export const Stock_Transfer_Shipment_Constraint = {
  /** unique or primary key constraint on columns "id" */
  TransferShipmentPk: 'transfer_shipment_pk'
} as const;

export type Stock_Transfer_Shipment_Constraint = typeof Stock_Transfer_Shipment_Constraint[keyof typeof Stock_Transfer_Shipment_Constraint];
/** input type for incrementing numeric columns in table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Insert_Input = {
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  destination_location_id?: Maybe<Scalars['uuid']>;
  eta?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  location?: Maybe<Location_Obj_Rel_Insert_Input>;
  received_at?: Maybe<Scalars['timestamptz']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  stock_transfer?: Maybe<Stock_Transfer_Obj_Rel_Insert_Input>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Stock_Transfer_Shipment_Max_Fields = {
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  destination_location_id?: Maybe<Scalars['uuid']>;
  eta?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  received_at?: Maybe<Scalars['timestamptz']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Max_Order_By = {
  carrier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  destination_location_id?: Maybe<Order_By>;
  eta?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  received_at?: Maybe<Order_By>;
  shipped_at?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  tracking_number?: Maybe<Order_By>;
  tracking_url?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Stock_Transfer_Shipment_Min_Fields = {
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  destination_location_id?: Maybe<Scalars['uuid']>;
  eta?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  received_at?: Maybe<Scalars['timestamptz']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Min_Order_By = {
  carrier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  destination_location_id?: Maybe<Order_By>;
  eta?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  received_at?: Maybe<Order_By>;
  shipped_at?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  tracking_number?: Maybe<Order_By>;
  tracking_url?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Stock_Transfer_Shipment>;
};

/** on_conflict condition type for table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_On_Conflict = {
  constraint: Stock_Transfer_Shipment_Constraint;
  update_columns?: Array<Stock_Transfer_Shipment_Update_Column>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};

/** Ordering options when selecting data from "stock_transfer_shipment". */
export type Stock_Transfer_Shipment_Order_By = {
  carrier?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  destination_location_id?: Maybe<Order_By>;
  eta?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  location?: Maybe<Location_Order_By>;
  received_at?: Maybe<Order_By>;
  shipped_at?: Maybe<Order_By>;
  stock_transfer?: Maybe<Stock_Transfer_Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  tracking_number?: Maybe<Order_By>;
  tracking_url?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: stock_transfer_shipment */
export type Stock_Transfer_Shipment_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "stock_transfer_shipment" */
export const Stock_Transfer_Shipment_Select_Column = {
  /** column name */
  Carrier: 'carrier',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DestinationLocationId: 'destination_location_id',
  /** column name */
  Eta: 'eta',
  /** column name */
  Id: 'id',
  /** column name */
  ReceivedAt: 'received_at',
  /** column name */
  ShippedAt: 'shipped_at',
  /** column name */
  StockTransferId: 'stock_transfer_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  TrackingNumber: 'tracking_number',
  /** column name */
  TrackingUrl: 'tracking_url',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Stock_Transfer_Shipment_Select_Column = typeof Stock_Transfer_Shipment_Select_Column[keyof typeof Stock_Transfer_Shipment_Select_Column];
/** input type for updating data in table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Set_Input = {
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  destination_location_id?: Maybe<Scalars['uuid']>;
  eta?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  received_at?: Maybe<Scalars['timestamptz']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Stock_Transfer_Shipment_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Stock_Transfer_Shipment_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Stock_Transfer_Shipment_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Stock_Transfer_Shipment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Stock_Transfer_Shipment_Stream_Cursor_Value_Input = {
  carrier?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  destination_location_id?: Maybe<Scalars['uuid']>;
  eta?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  received_at?: Maybe<Scalars['timestamptz']>;
  shipped_at?: Maybe<Scalars['timestamptz']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
  store_id?: Maybe<Scalars['uuid']>;
  tracking_number?: Maybe<Scalars['String']>;
  tracking_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Stock_Transfer_Shipment_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  stock_transfer_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Sum_Order_By = {
  id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
};

/** update columns of table "stock_transfer_shipment" */
export const Stock_Transfer_Shipment_Update_Column = {
  /** column name */
  Carrier: 'carrier',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DestinationLocationId: 'destination_location_id',
  /** column name */
  Eta: 'eta',
  /** column name */
  Id: 'id',
  /** column name */
  ReceivedAt: 'received_at',
  /** column name */
  ShippedAt: 'shipped_at',
  /** column name */
  StockTransferId: 'stock_transfer_id',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  TrackingNumber: 'tracking_number',
  /** column name */
  TrackingUrl: 'tracking_url',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Stock_Transfer_Shipment_Update_Column = typeof Stock_Transfer_Shipment_Update_Column[keyof typeof Stock_Transfer_Shipment_Update_Column];
export type Stock_Transfer_Shipment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Stock_Transfer_Shipment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Stock_Transfer_Shipment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Stock_Transfer_Shipment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Stock_Transfer_Shipment_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Stock_Transfer_Shipment_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Stock_Transfer_Shipment_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  stock_transfer_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stock_transfer_shipment" */
export type Stock_Transfer_Shipment_Variance_Order_By = {
  id?: Maybe<Order_By>;
  stock_transfer_id?: Maybe<Order_By>;
};

/** columns and relationships of "stock_transfer_status" */
export type Stock_Transfer_Status = {
  /** An array relationship */
  stock_transfers: Array<Stock_Transfer>;
  /** An aggregate relationship */
  stock_transfers_aggregate: Stock_Transfer_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "stock_transfer_status" */
export type Stock_Transfer_StatusStock_TransfersArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Order_By>>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};


/** columns and relationships of "stock_transfer_status" */
export type Stock_Transfer_StatusStock_Transfers_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Order_By>>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};

/** aggregated selection of "stock_transfer_status" */
export type Stock_Transfer_Status_Aggregate = {
  aggregate?: Maybe<Stock_Transfer_Status_Aggregate_Fields>;
  nodes: Array<Stock_Transfer_Status>;
};

/** aggregate fields of "stock_transfer_status" */
export type Stock_Transfer_Status_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Stock_Transfer_Status_Max_Fields>;
  min?: Maybe<Stock_Transfer_Status_Min_Fields>;
};


/** aggregate fields of "stock_transfer_status" */
export type Stock_Transfer_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Stock_Transfer_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "stock_transfer_status". All fields are combined with a logical 'AND'. */
export type Stock_Transfer_Status_Bool_Exp = {
  _and?: Maybe<Array<Stock_Transfer_Status_Bool_Exp>>;
  _not?: Maybe<Stock_Transfer_Status_Bool_Exp>;
  _or?: Maybe<Array<Stock_Transfer_Status_Bool_Exp>>;
  stock_transfers?: Maybe<Stock_Transfer_Bool_Exp>;
  stock_transfers_aggregate?: Maybe<Stock_Transfer_Aggregate_Bool_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "stock_transfer_status" */
export const Stock_Transfer_Status_Constraint = {
  /** unique or primary key constraint on columns "value" */
  StockTransferStatusPkey: 'stock_transfer_status_pkey'
} as const;

export type Stock_Transfer_Status_Constraint = typeof Stock_Transfer_Status_Constraint[keyof typeof Stock_Transfer_Status_Constraint];
export const Stock_Transfer_Status_Enum = {
  Cancelled: 'CANCELLED',
  Complete: 'COMPLETE',
  Draft: 'DRAFT',
  Received: 'RECEIVED',
  Shipped: 'SHIPPED',
  Unsent: 'UNSENT'
} as const;

export type Stock_Transfer_Status_Enum = typeof Stock_Transfer_Status_Enum[keyof typeof Stock_Transfer_Status_Enum];
/** Boolean expression to compare columns of type "stock_transfer_status_enum". All fields are combined with logical 'AND'. */
export type Stock_Transfer_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Stock_Transfer_Status_Enum>;
  _in?: Maybe<Array<Stock_Transfer_Status_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Stock_Transfer_Status_Enum>;
  _nin?: Maybe<Array<Stock_Transfer_Status_Enum>>;
};

/** input type for inserting data into table "stock_transfer_status" */
export type Stock_Transfer_Status_Insert_Input = {
  stock_transfers?: Maybe<Stock_Transfer_Arr_Rel_Insert_Input>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Stock_Transfer_Status_Max_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Stock_Transfer_Status_Min_Fields = {
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "stock_transfer_status" */
export type Stock_Transfer_Status_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Stock_Transfer_Status>;
};

/** input type for inserting object relation for remote table "stock_transfer_status" */
export type Stock_Transfer_Status_Obj_Rel_Insert_Input = {
  data: Stock_Transfer_Status_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Stock_Transfer_Status_On_Conflict>;
};

/** on_conflict condition type for table "stock_transfer_status" */
export type Stock_Transfer_Status_On_Conflict = {
  constraint: Stock_Transfer_Status_Constraint;
  update_columns?: Array<Stock_Transfer_Status_Update_Column>;
  where?: Maybe<Stock_Transfer_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "stock_transfer_status". */
export type Stock_Transfer_Status_Order_By = {
  stock_transfers_aggregate?: Maybe<Stock_Transfer_Aggregate_Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: stock_transfer_status */
export type Stock_Transfer_Status_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "stock_transfer_status" */
export const Stock_Transfer_Status_Select_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Stock_Transfer_Status_Select_Column = typeof Stock_Transfer_Status_Select_Column[keyof typeof Stock_Transfer_Status_Select_Column];
/** input type for updating data in table "stock_transfer_status" */
export type Stock_Transfer_Status_Set_Input = {
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "stock_transfer_status" */
export type Stock_Transfer_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Stock_Transfer_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Stock_Transfer_Status_Stream_Cursor_Value_Input = {
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "stock_transfer_status" */
export const Stock_Transfer_Status_Update_Column = {
  /** column name */
  Value: 'value'
} as const;

export type Stock_Transfer_Status_Update_Column = typeof Stock_Transfer_Status_Update_Column[keyof typeof Stock_Transfer_Status_Update_Column];
export type Stock_Transfer_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Stock_Transfer_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Stock_Transfer_Status_Bool_Exp;
};

/** aggregate stddev on columns */
export type Stock_Transfer_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
  reference_number?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stock_transfer" */
export type Stock_Transfer_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Stock_Transfer_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  reference_number?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stock_transfer" */
export type Stock_Transfer_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Stock_Transfer_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  reference_number?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stock_transfer" */
export type Stock_Transfer_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
};

/** Streaming cursor of the table "stock_transfer" */
export type Stock_Transfer_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Stock_Transfer_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Stock_Transfer_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  external_entity_id?: Maybe<Scalars['String']>;
  finalised_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  label_path?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  reference_number?: Maybe<Scalars['Int']>;
  status?: Maybe<Stock_Transfer_Status_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Stock_Transfer_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
  reference_number?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "stock_transfer" */
export type Stock_Transfer_Sum_Order_By = {
  id?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
};

/** update columns of table "stock_transfer" */
export const Stock_Transfer_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  ExternalEntityId: 'external_entity_id',
  /** column name */
  FinalisedAt: 'finalised_at',
  /** column name */
  Id: 'id',
  /** column name */
  LabelPath: 'label_path',
  /** column name */
  Name: 'name',
  /** column name */
  Notes: 'notes',
  /** column name */
  ReferenceNumber: 'reference_number',
  /** column name */
  Status: 'status',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Stock_Transfer_Update_Column = typeof Stock_Transfer_Update_Column[keyof typeof Stock_Transfer_Update_Column];
export type Stock_Transfer_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Stock_Transfer_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Stock_Transfer_Set_Input>;
  /** filter the rows which have to be updated */
  where: Stock_Transfer_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Stock_Transfer_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
  reference_number?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stock_transfer" */
export type Stock_Transfer_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Stock_Transfer_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
  reference_number?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stock_transfer" */
export type Stock_Transfer_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Stock_Transfer_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
  reference_number?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stock_transfer" */
export type Stock_Transfer_Variance_Order_By = {
  id?: Maybe<Order_By>;
  reference_number?: Maybe<Order_By>;
};

/** columns and relationships of "store" */
export type Store = {
  /** An array relationship */
  addresses: Array<Address>;
  /** An aggregate relationship */
  addresses_aggregate: Address_Aggregate;
  brand_color?: Maybe<Scalars['String']>;
  brand_logo_path?: Maybe<Scalars['String']>;
  /** An object relationship */
  carrier_selection: Carrier_Selection;
  carrier_selection_pref: Carrier_Selection_Enum;
  /** An array relationship */
  carriers: Array<Carrier>;
  /** An aggregate relationship */
  carriers_aggregate: Carrier_Aggregate;
  created_at: Scalars['timestamptz'];
  /** An array relationship */
  customers: Array<Customer>;
  /** An aggregate relationship */
  customers_aggregate: Customer_Aggregate;
  fbs_enabled: Scalars['Boolean'];
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  id: Scalars['uuid'];
  include_in_reporting: Scalars['Boolean'];
  integrations?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  inventory_item_quantities: Array<Inventory_Item_Quantity>;
  /** An aggregate relationship */
  inventory_item_quantities_aggregate: Inventory_Item_Quantity_Aggregate;
  /** An array relationship */
  inventory_items: Array<Inventory_Item>;
  /** An aggregate relationship */
  inventory_items_aggregate: Inventory_Item_Aggregate;
  /** An array relationship */
  inventory_sync_jobs: Array<Inventory_Sync_Job>;
  /** An aggregate relationship */
  inventory_sync_jobs_aggregate: Inventory_Sync_Job_Aggregate;
  is_test: Scalars['Boolean'];
  /** An array relationship */
  locations: Array<Location>;
  /** An aggregate relationship */
  locations_aggregate: Location_Aggregate;
  /** An array relationship */
  manifests: Array<Manifest>;
  /** An aggregate relationship */
  manifests_aggregate: Manifest_Aggregate;
  name: Scalars['String'];
  /** An object relationship */
  organization: Organization;
  organization_id: Scalars['uuid'];
  /** An array relationship */
  parcel_types: Array<Parcel_Type>;
  /** An aggregate relationship */
  parcel_types_aggregate: Parcel_Type_Aggregate;
  /** An array relationship */
  product_variants: Array<Product_Variant>;
  /** An aggregate relationship */
  product_variants_aggregate: Product_Variant_Aggregate;
  /** An array relationship */
  products: Array<Product>;
  /** An aggregate relationship */
  products_aggregate: Product_Aggregate;
  /** An array relationship */
  rates: Array<Shipping_Rate>;
  /** An aggregate relationship */
  rates_aggregate: Shipping_Rate_Aggregate;
  release_channel: Release_Channel_Enum;
  /** An array relationship */
  retail_units: Array<Retail_Unit>;
  /** An aggregate relationship */
  retail_units_aggregate: Retail_Unit_Aggregate;
  /** An array relationship */
  sales_order_shipment_charges: Array<Sales_Order_Shipment_Charge>;
  /** An aggregate relationship */
  sales_order_shipment_charges_aggregate: Sales_Order_Shipment_Charge_Aggregate;
  /** An array relationship */
  sales_orders: Array<Sales_Order>;
  /** An aggregate relationship */
  sales_orders_aggregate: Sales_Order_Aggregate;
  /** An array relationship */
  shopify_integrations: Array<Shopify_Integration>;
  /** An aggregate relationship */
  shopify_integrations_aggregate: Shopify_Integration_Aggregate;
  /** An array relationship */
  slugs: Array<Store_Slug>;
  /** An aggregate relationship */
  slugs_aggregate: Store_Slug_Aggregate;
  /** An array relationship */
  stock_transfers: Array<Stock_Transfer>;
  /** An aggregate relationship */
  stock_transfers_aggregate: Stock_Transfer_Aggregate;
  /** An array relationship */
  store_feature_flags: Array<Store_Feature_Flag>;
  /** An aggregate relationship */
  store_feature_flags_aggregate: Store_Feature_Flag_Aggregate;
  /** An array relationship */
  tags: Array<Tag>;
  /** An aggregate relationship */
  tags_aggregate: Tag_Aggregate;
  /** An array relationship */
  transfer_items: Array<Stock_Transfer_Item>;
  /** An aggregate relationship */
  transfer_items_aggregate: Stock_Transfer_Item_Aggregate;
  /** An array relationship */
  transfer_parcels: Array<Stock_Transfer_Parcel>;
  /** An aggregate relationship */
  transfer_parcels_aggregate: Stock_Transfer_Parcel_Aggregate;
  /** An array relationship */
  transfer_shipments: Array<Stock_Transfer_Shipment>;
  /** An aggregate relationship */
  transfer_shipments_aggregate: Stock_Transfer_Shipment_Aggregate;
  updated_at: Scalars['timestamptz'];
  use_branded_returns_portal: Scalars['Boolean'];
  use_branded_tracking_portal: Scalars['Boolean'];
};


/** columns and relationships of "store" */
export type StoreAddressesArgs = {
  distinct_on?: Maybe<Array<Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Order_By>>;
  where?: Maybe<Address_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreAddresses_AggregateArgs = {
  distinct_on?: Maybe<Array<Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Order_By>>;
  where?: Maybe<Address_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreCarriersArgs = {
  distinct_on?: Maybe<Array<Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Order_By>>;
  where?: Maybe<Carrier_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreCarriers_AggregateArgs = {
  distinct_on?: Maybe<Array<Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Order_By>>;
  where?: Maybe<Carrier_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreCustomersArgs = {
  distinct_on?: Maybe<Array<Customer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Order_By>>;
  where?: Maybe<Customer_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreCustomers_AggregateArgs = {
  distinct_on?: Maybe<Array<Customer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Order_By>>;
  where?: Maybe<Customer_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreIntegrationsArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "store" */
export type StoreInventory_Item_QuantitiesArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreInventory_Item_Quantities_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreInventory_ItemsArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Order_By>>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreInventory_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Order_By>>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreInventory_Sync_JobsArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreInventory_Sync_Jobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreLocationsArgs = {
  distinct_on?: Maybe<Array<Location_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Location_Order_By>>;
  where?: Maybe<Location_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreLocations_AggregateArgs = {
  distinct_on?: Maybe<Array<Location_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Location_Order_By>>;
  where?: Maybe<Location_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreManifestsArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreManifests_AggregateArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreParcel_TypesArgs = {
  distinct_on?: Maybe<Array<Parcel_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Parcel_Type_Order_By>>;
  where?: Maybe<Parcel_Type_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreParcel_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Parcel_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Parcel_Type_Order_By>>;
  where?: Maybe<Parcel_Type_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreProduct_VariantsArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreProduct_Variants_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreProductsArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreProducts_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreRatesArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreRates_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreRetail_UnitsArgs = {
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreRetail_Units_AggregateArgs = {
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreSales_Order_Shipment_ChargesArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Shipment_Charge_Order_By>>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreSales_Order_Shipment_Charges_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Shipment_Charge_Order_By>>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreSales_OrdersArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreSales_Orders_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreShopify_IntegrationsArgs = {
  distinct_on?: Maybe<Array<Shopify_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Integration_Order_By>>;
  where?: Maybe<Shopify_Integration_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreShopify_Integrations_AggregateArgs = {
  distinct_on?: Maybe<Array<Shopify_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Integration_Order_By>>;
  where?: Maybe<Shopify_Integration_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreSlugsArgs = {
  distinct_on?: Maybe<Array<Store_Slug_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Slug_Order_By>>;
  where?: Maybe<Store_Slug_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreSlugs_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Slug_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Slug_Order_By>>;
  where?: Maybe<Store_Slug_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreStock_TransfersArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Order_By>>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreStock_Transfers_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Order_By>>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreStore_Feature_FlagsArgs = {
  distinct_on?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Feature_Flag_Order_By>>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreStore_Feature_Flags_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Feature_Flag_Order_By>>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreTagsArgs = {
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreTags_AggregateArgs = {
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreTransfer_ItemsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreTransfer_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreTransfer_ParcelsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreTransfer_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreTransfer_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};


/** columns and relationships of "store" */
export type StoreTransfer_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};

/** aggregated selection of "store" */
export type Store_Aggregate = {
  aggregate?: Maybe<Store_Aggregate_Fields>;
  nodes: Array<Store>;
};

export type Store_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Store_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Store_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Store_Aggregate_Bool_Exp_Count>;
};

export type Store_Aggregate_Bool_Exp_Bool_And = {
  arguments: Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Store_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Store_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Store_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Store_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Store_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Store_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "store" */
export type Store_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Store_Max_Fields>;
  min?: Maybe<Store_Min_Fields>;
};


/** aggregate fields of "store" */
export type Store_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Store_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "store" */
export type Store_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Store_Max_Order_By>;
  min?: Maybe<Store_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Store_Append_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "store" */
export type Store_Arr_Rel_Insert_Input = {
  data: Array<Store_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Store_On_Conflict>;
};

/** Boolean expression to filter rows from the table "store". All fields are combined with a logical 'AND'. */
export type Store_Bool_Exp = {
  _and?: Maybe<Array<Store_Bool_Exp>>;
  _not?: Maybe<Store_Bool_Exp>;
  _or?: Maybe<Array<Store_Bool_Exp>>;
  addresses?: Maybe<Address_Bool_Exp>;
  addresses_aggregate?: Maybe<Address_Aggregate_Bool_Exp>;
  brand_color?: Maybe<String_Comparison_Exp>;
  brand_logo_path?: Maybe<String_Comparison_Exp>;
  carrier_selection?: Maybe<Carrier_Selection_Bool_Exp>;
  carrier_selection_pref?: Maybe<Carrier_Selection_Enum_Comparison_Exp>;
  carriers?: Maybe<Carrier_Bool_Exp>;
  carriers_aggregate?: Maybe<Carrier_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customers?: Maybe<Customer_Bool_Exp>;
  customers_aggregate?: Maybe<Customer_Aggregate_Bool_Exp>;
  fbs_enabled?: Maybe<Boolean_Comparison_Exp>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Bool_Exp>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  include_in_reporting?: Maybe<Boolean_Comparison_Exp>;
  integrations?: Maybe<Jsonb_Comparison_Exp>;
  inventory_item_quantities?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
  inventory_item_quantities_aggregate?: Maybe<Inventory_Item_Quantity_Aggregate_Bool_Exp>;
  inventory_items?: Maybe<Inventory_Item_Bool_Exp>;
  inventory_items_aggregate?: Maybe<Inventory_Item_Aggregate_Bool_Exp>;
  inventory_sync_jobs?: Maybe<Inventory_Sync_Job_Bool_Exp>;
  inventory_sync_jobs_aggregate?: Maybe<Inventory_Sync_Job_Aggregate_Bool_Exp>;
  is_test?: Maybe<Boolean_Comparison_Exp>;
  locations?: Maybe<Location_Bool_Exp>;
  locations_aggregate?: Maybe<Location_Aggregate_Bool_Exp>;
  manifests?: Maybe<Manifest_Bool_Exp>;
  manifests_aggregate?: Maybe<Manifest_Aggregate_Bool_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  organization?: Maybe<Organization_Bool_Exp>;
  organization_id?: Maybe<Uuid_Comparison_Exp>;
  parcel_types?: Maybe<Parcel_Type_Bool_Exp>;
  parcel_types_aggregate?: Maybe<Parcel_Type_Aggregate_Bool_Exp>;
  product_variants?: Maybe<Product_Variant_Bool_Exp>;
  product_variants_aggregate?: Maybe<Product_Variant_Aggregate_Bool_Exp>;
  products?: Maybe<Product_Bool_Exp>;
  products_aggregate?: Maybe<Product_Aggregate_Bool_Exp>;
  rates?: Maybe<Shipping_Rate_Bool_Exp>;
  rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Bool_Exp>;
  release_channel?: Maybe<Release_Channel_Enum_Comparison_Exp>;
  retail_units?: Maybe<Retail_Unit_Bool_Exp>;
  retail_units_aggregate?: Maybe<Retail_Unit_Aggregate_Bool_Exp>;
  sales_order_shipment_charges?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
  sales_order_shipment_charges_aggregate?: Maybe<Sales_Order_Shipment_Charge_Aggregate_Bool_Exp>;
  sales_orders?: Maybe<Sales_Order_Bool_Exp>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Bool_Exp>;
  shopify_integrations?: Maybe<Shopify_Integration_Bool_Exp>;
  shopify_integrations_aggregate?: Maybe<Shopify_Integration_Aggregate_Bool_Exp>;
  slugs?: Maybe<Store_Slug_Bool_Exp>;
  slugs_aggregate?: Maybe<Store_Slug_Aggregate_Bool_Exp>;
  stock_transfers?: Maybe<Stock_Transfer_Bool_Exp>;
  stock_transfers_aggregate?: Maybe<Stock_Transfer_Aggregate_Bool_Exp>;
  store_feature_flags?: Maybe<Store_Feature_Flag_Bool_Exp>;
  store_feature_flags_aggregate?: Maybe<Store_Feature_Flag_Aggregate_Bool_Exp>;
  tags?: Maybe<Tag_Bool_Exp>;
  tags_aggregate?: Maybe<Tag_Aggregate_Bool_Exp>;
  transfer_items?: Maybe<Stock_Transfer_Item_Bool_Exp>;
  transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Bool_Exp>;
  transfer_parcels?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
  transfer_parcels_aggregate?: Maybe<Stock_Transfer_Parcel_Aggregate_Bool_Exp>;
  transfer_shipments?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
  transfer_shipments_aggregate?: Maybe<Stock_Transfer_Shipment_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  use_branded_returns_portal?: Maybe<Boolean_Comparison_Exp>;
  use_branded_tracking_portal?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "store" */
export const Store_Constraint = {
  /** unique or primary key constraint on columns "id" */
  StorePkey: 'store_pkey'
} as const;

export type Store_Constraint = typeof Store_Constraint[keyof typeof Store_Constraint];
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Store_Delete_At_Path_Input = {
  integrations?: Maybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Store_Delete_Elem_Input = {
  integrations?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Store_Delete_Key_Input = {
  integrations?: Maybe<Scalars['String']>;
};

/** columns and relationships of "store_feature_flag" */
export type Store_Feature_Flag = {
  /** An object relationship */
  featureFlagByFeatureFlag: Feature_Flag;
  feature_flag: Feature_Flag_Enum;
  id: Scalars['uuid'];
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
};

/** aggregated selection of "store_feature_flag" */
export type Store_Feature_Flag_Aggregate = {
  aggregate?: Maybe<Store_Feature_Flag_Aggregate_Fields>;
  nodes: Array<Store_Feature_Flag>;
};

export type Store_Feature_Flag_Aggregate_Bool_Exp = {
  count?: Maybe<Store_Feature_Flag_Aggregate_Bool_Exp_Count>;
};

export type Store_Feature_Flag_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Store_Feature_Flag_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "store_feature_flag" */
export type Store_Feature_Flag_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Store_Feature_Flag_Max_Fields>;
  min?: Maybe<Store_Feature_Flag_Min_Fields>;
};


/** aggregate fields of "store_feature_flag" */
export type Store_Feature_Flag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "store_feature_flag" */
export type Store_Feature_Flag_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Store_Feature_Flag_Max_Order_By>;
  min?: Maybe<Store_Feature_Flag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "store_feature_flag" */
export type Store_Feature_Flag_Arr_Rel_Insert_Input = {
  data: Array<Store_Feature_Flag_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Store_Feature_Flag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "store_feature_flag". All fields are combined with a logical 'AND'. */
export type Store_Feature_Flag_Bool_Exp = {
  _and?: Maybe<Array<Store_Feature_Flag_Bool_Exp>>;
  _not?: Maybe<Store_Feature_Flag_Bool_Exp>;
  _or?: Maybe<Array<Store_Feature_Flag_Bool_Exp>>;
  featureFlagByFeatureFlag?: Maybe<Feature_Flag_Bool_Exp>;
  feature_flag?: Maybe<Feature_Flag_Enum_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "store_feature_flag" */
export const Store_Feature_Flag_Constraint = {
  /** unique or primary key constraint on columns "id" */
  StoreFeatureFlagPkey: 'store_feature_flag_pkey',
  /** unique or primary key constraint on columns "store_id", "feature_flag" */
  StoreFeatureFlagStoreIdFeatureFlagKey: 'store_feature_flag_store_id_feature_flag_key'
} as const;

export type Store_Feature_Flag_Constraint = typeof Store_Feature_Flag_Constraint[keyof typeof Store_Feature_Flag_Constraint];
/** input type for inserting data into table "store_feature_flag" */
export type Store_Feature_Flag_Insert_Input = {
  featureFlagByFeatureFlag?: Maybe<Feature_Flag_Obj_Rel_Insert_Input>;
  feature_flag?: Maybe<Feature_Flag_Enum>;
  id?: Maybe<Scalars['uuid']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Store_Feature_Flag_Max_Fields = {
  id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "store_feature_flag" */
export type Store_Feature_Flag_Max_Order_By = {
  id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Store_Feature_Flag_Min_Fields = {
  id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "store_feature_flag" */
export type Store_Feature_Flag_Min_Order_By = {
  id?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "store_feature_flag" */
export type Store_Feature_Flag_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Store_Feature_Flag>;
};

/** on_conflict condition type for table "store_feature_flag" */
export type Store_Feature_Flag_On_Conflict = {
  constraint: Store_Feature_Flag_Constraint;
  update_columns?: Array<Store_Feature_Flag_Update_Column>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};

/** Ordering options when selecting data from "store_feature_flag". */
export type Store_Feature_Flag_Order_By = {
  featureFlagByFeatureFlag?: Maybe<Feature_Flag_Order_By>;
  feature_flag?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
};

/** primary key columns input for table: store_feature_flag */
export type Store_Feature_Flag_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "store_feature_flag" */
export const Store_Feature_Flag_Select_Column = {
  /** column name */
  FeatureFlag: 'feature_flag',
  /** column name */
  Id: 'id',
  /** column name */
  StoreId: 'store_id'
} as const;

export type Store_Feature_Flag_Select_Column = typeof Store_Feature_Flag_Select_Column[keyof typeof Store_Feature_Flag_Select_Column];
/** input type for updating data in table "store_feature_flag" */
export type Store_Feature_Flag_Set_Input = {
  feature_flag?: Maybe<Feature_Flag_Enum>;
  id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "store_feature_flag" */
export type Store_Feature_Flag_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Store_Feature_Flag_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Store_Feature_Flag_Stream_Cursor_Value_Input = {
  feature_flag?: Maybe<Feature_Flag_Enum>;
  id?: Maybe<Scalars['uuid']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "store_feature_flag" */
export const Store_Feature_Flag_Update_Column = {
  /** column name */
  FeatureFlag: 'feature_flag',
  /** column name */
  Id: 'id',
  /** column name */
  StoreId: 'store_id'
} as const;

export type Store_Feature_Flag_Update_Column = typeof Store_Feature_Flag_Update_Column[keyof typeof Store_Feature_Flag_Update_Column];
export type Store_Feature_Flag_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Store_Feature_Flag_Set_Input>;
  /** filter the rows which have to be updated */
  where: Store_Feature_Flag_Bool_Exp;
};

/** input type for inserting data into table "store" */
export type Store_Insert_Input = {
  addresses?: Maybe<Address_Arr_Rel_Insert_Input>;
  brand_color?: Maybe<Scalars['String']>;
  brand_logo_path?: Maybe<Scalars['String']>;
  carrier_selection?: Maybe<Carrier_Selection_Obj_Rel_Insert_Input>;
  carrier_selection_pref?: Maybe<Carrier_Selection_Enum>;
  carriers?: Maybe<Carrier_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customers?: Maybe<Customer_Arr_Rel_Insert_Input>;
  fbs_enabled?: Maybe<Scalars['Boolean']>;
  fulfilment_shipments?: Maybe<Fulfilment_Shipment_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  include_in_reporting?: Maybe<Scalars['Boolean']>;
  integrations?: Maybe<Scalars['jsonb']>;
  inventory_item_quantities?: Maybe<Inventory_Item_Quantity_Arr_Rel_Insert_Input>;
  inventory_items?: Maybe<Inventory_Item_Arr_Rel_Insert_Input>;
  inventory_sync_jobs?: Maybe<Inventory_Sync_Job_Arr_Rel_Insert_Input>;
  is_test?: Maybe<Scalars['Boolean']>;
  locations?: Maybe<Location_Arr_Rel_Insert_Input>;
  manifests?: Maybe<Manifest_Arr_Rel_Insert_Input>;
  name?: Maybe<Scalars['String']>;
  organization?: Maybe<Organization_Obj_Rel_Insert_Input>;
  organization_id?: Maybe<Scalars['uuid']>;
  parcel_types?: Maybe<Parcel_Type_Arr_Rel_Insert_Input>;
  product_variants?: Maybe<Product_Variant_Arr_Rel_Insert_Input>;
  products?: Maybe<Product_Arr_Rel_Insert_Input>;
  rates?: Maybe<Shipping_Rate_Arr_Rel_Insert_Input>;
  release_channel?: Maybe<Release_Channel_Enum>;
  retail_units?: Maybe<Retail_Unit_Arr_Rel_Insert_Input>;
  sales_order_shipment_charges?: Maybe<Sales_Order_Shipment_Charge_Arr_Rel_Insert_Input>;
  sales_orders?: Maybe<Sales_Order_Arr_Rel_Insert_Input>;
  shopify_integrations?: Maybe<Shopify_Integration_Arr_Rel_Insert_Input>;
  slugs?: Maybe<Store_Slug_Arr_Rel_Insert_Input>;
  stock_transfers?: Maybe<Stock_Transfer_Arr_Rel_Insert_Input>;
  store_feature_flags?: Maybe<Store_Feature_Flag_Arr_Rel_Insert_Input>;
  tags?: Maybe<Tag_Arr_Rel_Insert_Input>;
  transfer_items?: Maybe<Stock_Transfer_Item_Arr_Rel_Insert_Input>;
  transfer_parcels?: Maybe<Stock_Transfer_Parcel_Arr_Rel_Insert_Input>;
  transfer_shipments?: Maybe<Stock_Transfer_Shipment_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  use_branded_returns_portal?: Maybe<Scalars['Boolean']>;
  use_branded_tracking_portal?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Store_Max_Fields = {
  brand_color?: Maybe<Scalars['String']>;
  brand_logo_path?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  organization_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "store" */
export type Store_Max_Order_By = {
  brand_color?: Maybe<Order_By>;
  brand_logo_path?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  organization_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Store_Min_Fields = {
  brand_color?: Maybe<Scalars['String']>;
  brand_logo_path?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  organization_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "store" */
export type Store_Min_Order_By = {
  brand_color?: Maybe<Order_By>;
  brand_logo_path?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  organization_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "store" */
export type Store_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Store>;
};

/** input type for inserting object relation for remote table "store" */
export type Store_Obj_Rel_Insert_Input = {
  data: Store_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Store_On_Conflict>;
};

/** on_conflict condition type for table "store" */
export type Store_On_Conflict = {
  constraint: Store_Constraint;
  update_columns?: Array<Store_Update_Column>;
  where?: Maybe<Store_Bool_Exp>;
};

/** Ordering options when selecting data from "store". */
export type Store_Order_By = {
  addresses_aggregate?: Maybe<Address_Aggregate_Order_By>;
  brand_color?: Maybe<Order_By>;
  brand_logo_path?: Maybe<Order_By>;
  carrier_selection?: Maybe<Carrier_Selection_Order_By>;
  carrier_selection_pref?: Maybe<Order_By>;
  carriers_aggregate?: Maybe<Carrier_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  customers_aggregate?: Maybe<Customer_Aggregate_Order_By>;
  fbs_enabled?: Maybe<Order_By>;
  fulfilment_shipments_aggregate?: Maybe<Fulfilment_Shipment_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  include_in_reporting?: Maybe<Order_By>;
  integrations?: Maybe<Order_By>;
  inventory_item_quantities_aggregate?: Maybe<Inventory_Item_Quantity_Aggregate_Order_By>;
  inventory_items_aggregate?: Maybe<Inventory_Item_Aggregate_Order_By>;
  inventory_sync_jobs_aggregate?: Maybe<Inventory_Sync_Job_Aggregate_Order_By>;
  is_test?: Maybe<Order_By>;
  locations_aggregate?: Maybe<Location_Aggregate_Order_By>;
  manifests_aggregate?: Maybe<Manifest_Aggregate_Order_By>;
  name?: Maybe<Order_By>;
  organization?: Maybe<Organization_Order_By>;
  organization_id?: Maybe<Order_By>;
  parcel_types_aggregate?: Maybe<Parcel_Type_Aggregate_Order_By>;
  product_variants_aggregate?: Maybe<Product_Variant_Aggregate_Order_By>;
  products_aggregate?: Maybe<Product_Aggregate_Order_By>;
  rates_aggregate?: Maybe<Shipping_Rate_Aggregate_Order_By>;
  release_channel?: Maybe<Order_By>;
  retail_units_aggregate?: Maybe<Retail_Unit_Aggregate_Order_By>;
  sales_order_shipment_charges_aggregate?: Maybe<Sales_Order_Shipment_Charge_Aggregate_Order_By>;
  sales_orders_aggregate?: Maybe<Sales_Order_Aggregate_Order_By>;
  shopify_integrations_aggregate?: Maybe<Shopify_Integration_Aggregate_Order_By>;
  slugs_aggregate?: Maybe<Store_Slug_Aggregate_Order_By>;
  stock_transfers_aggregate?: Maybe<Stock_Transfer_Aggregate_Order_By>;
  store_feature_flags_aggregate?: Maybe<Store_Feature_Flag_Aggregate_Order_By>;
  tags_aggregate?: Maybe<Tag_Aggregate_Order_By>;
  transfer_items_aggregate?: Maybe<Stock_Transfer_Item_Aggregate_Order_By>;
  transfer_parcels_aggregate?: Maybe<Stock_Transfer_Parcel_Aggregate_Order_By>;
  transfer_shipments_aggregate?: Maybe<Stock_Transfer_Shipment_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  use_branded_returns_portal?: Maybe<Order_By>;
  use_branded_tracking_portal?: Maybe<Order_By>;
};

/** primary key columns input for table: store */
export type Store_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Store_Prepend_Input = {
  integrations?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "store" */
export const Store_Select_Column = {
  /** column name */
  BrandColor: 'brand_color',
  /** column name */
  BrandLogoPath: 'brand_logo_path',
  /** column name */
  CarrierSelectionPref: 'carrier_selection_pref',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FbsEnabled: 'fbs_enabled',
  /** column name */
  Id: 'id',
  /** column name */
  IncludeInReporting: 'include_in_reporting',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  IsTest: 'is_test',
  /** column name */
  Name: 'name',
  /** column name */
  OrganizationId: 'organization_id',
  /** column name */
  ReleaseChannel: 'release_channel',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  UseBrandedReturnsPortal: 'use_branded_returns_portal',
  /** column name */
  UseBrandedTrackingPortal: 'use_branded_tracking_portal'
} as const;

export type Store_Select_Column = typeof Store_Select_Column[keyof typeof Store_Select_Column];
/** select "store_aggregate_bool_exp_bool_and_arguments_columns" columns of table "store" */
export const Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  FbsEnabled: 'fbs_enabled',
  /** column name */
  IncludeInReporting: 'include_in_reporting',
  /** column name */
  IsTest: 'is_test',
  /** column name */
  UseBrandedReturnsPortal: 'use_branded_returns_portal',
  /** column name */
  UseBrandedTrackingPortal: 'use_branded_tracking_portal'
} as const;

export type Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "store_aggregate_bool_exp_bool_or_arguments_columns" columns of table "store" */
export const Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  FbsEnabled: 'fbs_enabled',
  /** column name */
  IncludeInReporting: 'include_in_reporting',
  /** column name */
  IsTest: 'is_test',
  /** column name */
  UseBrandedReturnsPortal: 'use_branded_returns_portal',
  /** column name */
  UseBrandedTrackingPortal: 'use_branded_tracking_portal'
} as const;

export type Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Store_Select_Column_Store_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "store" */
export type Store_Set_Input = {
  brand_color?: Maybe<Scalars['String']>;
  brand_logo_path?: Maybe<Scalars['String']>;
  carrier_selection_pref?: Maybe<Carrier_Selection_Enum>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fbs_enabled?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  include_in_reporting?: Maybe<Scalars['Boolean']>;
  integrations?: Maybe<Scalars['jsonb']>;
  is_test?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  organization_id?: Maybe<Scalars['uuid']>;
  release_channel?: Maybe<Release_Channel_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  use_branded_returns_portal?: Maybe<Scalars['Boolean']>;
  use_branded_tracking_portal?: Maybe<Scalars['Boolean']>;
};

/** Store-specific non-rules-engine preferences */
export type Store_Setting = {
  /** An object relationship */
  carrier?: Maybe<Carrier>;
  carrier_id?: Maybe<Scalars['uuid']>;
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  key: Store_Setting_Key_Enum;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  /** An object relationship */
  store_setting_key: Store_Setting_Key;
  updated_at: Scalars['timestamptz'];
  value?: Maybe<Scalars['String']>;
};

/** aggregated selection of "store_setting" */
export type Store_Setting_Aggregate = {
  aggregate?: Maybe<Store_Setting_Aggregate_Fields>;
  nodes: Array<Store_Setting>;
};

/** aggregate fields of "store_setting" */
export type Store_Setting_Aggregate_Fields = {
  avg?: Maybe<Store_Setting_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Store_Setting_Max_Fields>;
  min?: Maybe<Store_Setting_Min_Fields>;
  stddev?: Maybe<Store_Setting_Stddev_Fields>;
  stddev_pop?: Maybe<Store_Setting_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Store_Setting_Stddev_Samp_Fields>;
  sum?: Maybe<Store_Setting_Sum_Fields>;
  var_pop?: Maybe<Store_Setting_Var_Pop_Fields>;
  var_samp?: Maybe<Store_Setting_Var_Samp_Fields>;
  variance?: Maybe<Store_Setting_Variance_Fields>;
};


/** aggregate fields of "store_setting" */
export type Store_Setting_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Store_Setting_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Store_Setting_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "store_setting". All fields are combined with a logical 'AND'. */
export type Store_Setting_Bool_Exp = {
  _and?: Maybe<Array<Store_Setting_Bool_Exp>>;
  _not?: Maybe<Store_Setting_Bool_Exp>;
  _or?: Maybe<Array<Store_Setting_Bool_Exp>>;
  carrier?: Maybe<Carrier_Bool_Exp>;
  carrier_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  key?: Maybe<Store_Setting_Key_Enum_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  store_setting_key?: Maybe<Store_Setting_Key_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "store_setting" */
export const Store_Setting_Constraint = {
  /** unique or primary key constraint on columns "id" */
  StoreSettingPkey: 'store_setting_pkey',
  /** unique or primary key constraint on columns "store_id", "key", "carrier_id" */
  StoreSettingSettingStoreIdCarrierIdKey: 'store_setting_setting_store_id_carrier_id_key'
} as const;

export type Store_Setting_Constraint = typeof Store_Setting_Constraint[keyof typeof Store_Setting_Constraint];
/** input type for incrementing numeric columns in table "store_setting" */
export type Store_Setting_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "store_setting" */
export type Store_Setting_Insert_Input = {
  carrier?: Maybe<Carrier_Obj_Rel_Insert_Input>;
  carrier_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  key?: Maybe<Store_Setting_Key_Enum>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  store_setting_key?: Maybe<Store_Setting_Key_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  value?: Maybe<Scalars['String']>;
};

/** Enum of different setting types */
export type Store_Setting_Key = {
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "store_setting_key" */
export type Store_Setting_Key_Aggregate = {
  aggregate?: Maybe<Store_Setting_Key_Aggregate_Fields>;
  nodes: Array<Store_Setting_Key>;
};

/** aggregate fields of "store_setting_key" */
export type Store_Setting_Key_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Store_Setting_Key_Max_Fields>;
  min?: Maybe<Store_Setting_Key_Min_Fields>;
};


/** aggregate fields of "store_setting_key" */
export type Store_Setting_Key_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Store_Setting_Key_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "store_setting_key". All fields are combined with a logical 'AND'. */
export type Store_Setting_Key_Bool_Exp = {
  _and?: Maybe<Array<Store_Setting_Key_Bool_Exp>>;
  _not?: Maybe<Store_Setting_Key_Bool_Exp>;
  _or?: Maybe<Array<Store_Setting_Key_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "store_setting_key" */
export const Store_Setting_Key_Constraint = {
  /** unique or primary key constraint on columns "value" */
  StoreSettingKeyPkey: 'store_setting_key_pkey'
} as const;

export type Store_Setting_Key_Constraint = typeof Store_Setting_Key_Constraint[keyof typeof Store_Setting_Key_Constraint];
export const Store_Setting_Key_Enum = {
  /** Age verification required (18+) */
  AtlAgeVerificationRequired: 'ATL_AGE_VERIFICATION_REQUIRED',
  /** If deliveries must be left with recipient or unattended */
  AtlAuthorityToLeave: 'ATL_AUTHORITY_TO_LEAVE',
  /** Signature required */
  AtlSignatureRequired: 'ATL_SIGNATURE_REQUIRED',
  /** Leave if safe location available only */
  AtlUnattendedSafety: 'ATL_UNATTENDED_SAFETY',
  /** List of skus required Express shipping for a store */
  CompulsoryExpressShippingSkus: 'COMPULSORY_EXPRESS_SHIPPING_SKUS',
  /** When order is fulfilled partially, not archive sales order and not create external fulfilment shipment */
  IgnoreArchivePartialFulfilledOrder: 'IGNORE_ARCHIVE_PARTIAL_FULFILLED_ORDER',
  /** If active, Store wont be able to get international rates */
  InternationalRatesDisabled: 'INTERNATIONAL_RATES_DISABLED',
  /** Prevent order to be automatically fulfilled by FC */
  ManualFcOrderForwarding: 'MANUAL_FC_ORDER_FORWARDING',
  /** a default weight for any received orders that have no weight */
  ParcelWeightDefaultGrams: 'PARCEL_WEIGHT_DEFAULT_GRAMS',
  /** Flag whether to include a list of order items on the Same Day shipping label */
  SameDayShowLineItemsOnLabels: 'SAME_DAY_SHOW_LINE_ITEMS_ON_LABELS'
} as const;

export type Store_Setting_Key_Enum = typeof Store_Setting_Key_Enum[keyof typeof Store_Setting_Key_Enum];
/** Boolean expression to compare columns of type "store_setting_key_enum". All fields are combined with logical 'AND'. */
export type Store_Setting_Key_Enum_Comparison_Exp = {
  _eq?: Maybe<Store_Setting_Key_Enum>;
  _in?: Maybe<Array<Store_Setting_Key_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Store_Setting_Key_Enum>;
  _nin?: Maybe<Array<Store_Setting_Key_Enum>>;
};

/** input type for inserting data into table "store_setting_key" */
export type Store_Setting_Key_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Store_Setting_Key_Max_Fields = {
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Store_Setting_Key_Min_Fields = {
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "store_setting_key" */
export type Store_Setting_Key_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Store_Setting_Key>;
};

/** input type for inserting object relation for remote table "store_setting_key" */
export type Store_Setting_Key_Obj_Rel_Insert_Input = {
  data: Store_Setting_Key_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Store_Setting_Key_On_Conflict>;
};

/** on_conflict condition type for table "store_setting_key" */
export type Store_Setting_Key_On_Conflict = {
  constraint: Store_Setting_Key_Constraint;
  update_columns?: Array<Store_Setting_Key_Update_Column>;
  where?: Maybe<Store_Setting_Key_Bool_Exp>;
};

/** Ordering options when selecting data from "store_setting_key". */
export type Store_Setting_Key_Order_By = {
  description?: Maybe<Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: store_setting_key */
export type Store_Setting_Key_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "store_setting_key" */
export const Store_Setting_Key_Select_Column = {
  /** column name */
  Description: 'description',
  /** column name */
  Value: 'value'
} as const;

export type Store_Setting_Key_Select_Column = typeof Store_Setting_Key_Select_Column[keyof typeof Store_Setting_Key_Select_Column];
/** input type for updating data in table "store_setting_key" */
export type Store_Setting_Key_Set_Input = {
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "store_setting_key" */
export type Store_Setting_Key_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Store_Setting_Key_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Store_Setting_Key_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "store_setting_key" */
export const Store_Setting_Key_Update_Column = {
  /** column name */
  Description: 'description',
  /** column name */
  Value: 'value'
} as const;

export type Store_Setting_Key_Update_Column = typeof Store_Setting_Key_Update_Column[keyof typeof Store_Setting_Key_Update_Column];
export type Store_Setting_Key_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Store_Setting_Key_Set_Input>;
  /** filter the rows which have to be updated */
  where: Store_Setting_Key_Bool_Exp;
};

/** aggregate max on columns */
export type Store_Setting_Max_Fields = {
  carrier_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Store_Setting_Min_Fields = {
  carrier_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "store_setting" */
export type Store_Setting_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Store_Setting>;
};

/** on_conflict condition type for table "store_setting" */
export type Store_Setting_On_Conflict = {
  constraint: Store_Setting_Constraint;
  update_columns?: Array<Store_Setting_Update_Column>;
  where?: Maybe<Store_Setting_Bool_Exp>;
};

/** Ordering options when selecting data from "store_setting". */
export type Store_Setting_Order_By = {
  carrier?: Maybe<Carrier_Order_By>;
  carrier_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  store_setting_key?: Maybe<Store_Setting_Key_Order_By>;
  updated_at?: Maybe<Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: store_setting */
export type Store_Setting_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "store_setting" */
export const Store_Setting_Select_Column = {
  /** column name */
  CarrierId: 'carrier_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Key: 'key',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  Value: 'value'
} as const;

export type Store_Setting_Select_Column = typeof Store_Setting_Select_Column[keyof typeof Store_Setting_Select_Column];
/** input type for updating data in table "store_setting" */
export type Store_Setting_Set_Input = {
  carrier_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  key?: Maybe<Store_Setting_Key_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Store_Setting_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Store_Setting_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Store_Setting_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "store_setting" */
export type Store_Setting_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Store_Setting_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Store_Setting_Stream_Cursor_Value_Input = {
  carrier_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  key?: Maybe<Store_Setting_Key_Enum>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Store_Setting_Sum_Fields = {
  id?: Maybe<Scalars['Int']>;
};

/** update columns of table "store_setting" */
export const Store_Setting_Update_Column = {
  /** column name */
  CarrierId: 'carrier_id',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Key: 'key',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  Value: 'value'
} as const;

export type Store_Setting_Update_Column = typeof Store_Setting_Update_Column[keyof typeof Store_Setting_Update_Column];
export type Store_Setting_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Store_Setting_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Store_Setting_Set_Input>;
  /** filter the rows which have to be updated */
  where: Store_Setting_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Store_Setting_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Store_Setting_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Store_Setting_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "store_slug" */
export type Store_Slug = {
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  primary: Scalars['Boolean'];
  slug: Scalars['String'];
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
};

/** aggregated selection of "store_slug" */
export type Store_Slug_Aggregate = {
  aggregate?: Maybe<Store_Slug_Aggregate_Fields>;
  nodes: Array<Store_Slug>;
};

export type Store_Slug_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Store_Slug_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Store_Slug_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Store_Slug_Aggregate_Bool_Exp_Count>;
};

export type Store_Slug_Aggregate_Bool_Exp_Bool_And = {
  arguments: Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Store_Slug_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Store_Slug_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Store_Slug_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Store_Slug_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Store_Slug_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Store_Slug_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "store_slug" */
export type Store_Slug_Aggregate_Fields = {
  avg?: Maybe<Store_Slug_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Store_Slug_Max_Fields>;
  min?: Maybe<Store_Slug_Min_Fields>;
  stddev?: Maybe<Store_Slug_Stddev_Fields>;
  stddev_pop?: Maybe<Store_Slug_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Store_Slug_Stddev_Samp_Fields>;
  sum?: Maybe<Store_Slug_Sum_Fields>;
  var_pop?: Maybe<Store_Slug_Var_Pop_Fields>;
  var_samp?: Maybe<Store_Slug_Var_Samp_Fields>;
  variance?: Maybe<Store_Slug_Variance_Fields>;
};


/** aggregate fields of "store_slug" */
export type Store_Slug_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Store_Slug_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "store_slug" */
export type Store_Slug_Aggregate_Order_By = {
  avg?: Maybe<Store_Slug_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Store_Slug_Max_Order_By>;
  min?: Maybe<Store_Slug_Min_Order_By>;
  stddev?: Maybe<Store_Slug_Stddev_Order_By>;
  stddev_pop?: Maybe<Store_Slug_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Store_Slug_Stddev_Samp_Order_By>;
  sum?: Maybe<Store_Slug_Sum_Order_By>;
  var_pop?: Maybe<Store_Slug_Var_Pop_Order_By>;
  var_samp?: Maybe<Store_Slug_Var_Samp_Order_By>;
  variance?: Maybe<Store_Slug_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "store_slug" */
export type Store_Slug_Arr_Rel_Insert_Input = {
  data: Array<Store_Slug_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Store_Slug_On_Conflict>;
};

/** aggregate avg on columns */
export type Store_Slug_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "store_slug" */
export type Store_Slug_Avg_Order_By = {
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "store_slug". All fields are combined with a logical 'AND'. */
export type Store_Slug_Bool_Exp = {
  _and?: Maybe<Array<Store_Slug_Bool_Exp>>;
  _not?: Maybe<Store_Slug_Bool_Exp>;
  _or?: Maybe<Array<Store_Slug_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  primary?: Maybe<Boolean_Comparison_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "store_slug" */
export const Store_Slug_Constraint = {
  /** unique or primary key constraint on columns "store_id" */
  OnlyOnePrimaryStoreSlugIdx: 'only_one_primary_store_slug_idx',
  /** unique or primary key constraint on columns "id" */
  StoreSlugPkey: 'store_slug_pkey',
  /** unique or primary key constraint on columns "slug" */
  StoreSlugSlugKey: 'store_slug_slug_key'
} as const;

export type Store_Slug_Constraint = typeof Store_Slug_Constraint[keyof typeof Store_Slug_Constraint];
/** input type for incrementing numeric columns in table "store_slug" */
export type Store_Slug_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "store_slug" */
export type Store_Slug_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  primary?: Maybe<Scalars['Boolean']>;
  slug?: Maybe<Scalars['String']>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Store_Slug_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  slug?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "store_slug" */
export type Store_Slug_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Store_Slug_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  slug?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "store_slug" */
export type Store_Slug_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "store_slug" */
export type Store_Slug_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Store_Slug>;
};

/** on_conflict condition type for table "store_slug" */
export type Store_Slug_On_Conflict = {
  constraint: Store_Slug_Constraint;
  update_columns?: Array<Store_Slug_Update_Column>;
  where?: Maybe<Store_Slug_Bool_Exp>;
};

/** Ordering options when selecting data from "store_slug". */
export type Store_Slug_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  primary?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
};

/** primary key columns input for table: store_slug */
export type Store_Slug_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "store_slug" */
export const Store_Slug_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Primary: 'primary',
  /** column name */
  Slug: 'slug',
  /** column name */
  StoreId: 'store_id'
} as const;

export type Store_Slug_Select_Column = typeof Store_Slug_Select_Column[keyof typeof Store_Slug_Select_Column];
/** select "store_slug_aggregate_bool_exp_bool_and_arguments_columns" columns of table "store_slug" */
export const Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = {
  /** column name */
  Primary: 'primary'
} as const;

export type Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_And_Arguments_Columns = typeof Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_And_Arguments_Columns[keyof typeof Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_And_Arguments_Columns];
/** select "store_slug_aggregate_bool_exp_bool_or_arguments_columns" columns of table "store_slug" */
export const Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = {
  /** column name */
  Primary: 'primary'
} as const;

export type Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns = typeof Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns[keyof typeof Store_Slug_Select_Column_Store_Slug_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns];
/** input type for updating data in table "store_slug" */
export type Store_Slug_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  primary?: Maybe<Scalars['Boolean']>;
  slug?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Store_Slug_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "store_slug" */
export type Store_Slug_Stddev_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Store_Slug_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "store_slug" */
export type Store_Slug_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Store_Slug_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "store_slug" */
export type Store_Slug_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "store_slug" */
export type Store_Slug_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Store_Slug_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Store_Slug_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  primary?: Maybe<Scalars['Boolean']>;
  slug?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Store_Slug_Sum_Fields = {
  id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "store_slug" */
export type Store_Slug_Sum_Order_By = {
  id?: Maybe<Order_By>;
};

/** update columns of table "store_slug" */
export const Store_Slug_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Primary: 'primary',
  /** column name */
  Slug: 'slug',
  /** column name */
  StoreId: 'store_id'
} as const;

export type Store_Slug_Update_Column = typeof Store_Slug_Update_Column[keyof typeof Store_Slug_Update_Column];
export type Store_Slug_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Store_Slug_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Store_Slug_Set_Input>;
  /** filter the rows which have to be updated */
  where: Store_Slug_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Store_Slug_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "store_slug" */
export type Store_Slug_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Store_Slug_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "store_slug" */
export type Store_Slug_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Store_Slug_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "store_slug" */
export type Store_Slug_Variance_Order_By = {
  id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "store" */
export type Store_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Store_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Store_Stream_Cursor_Value_Input = {
  brand_color?: Maybe<Scalars['String']>;
  brand_logo_path?: Maybe<Scalars['String']>;
  carrier_selection_pref?: Maybe<Carrier_Selection_Enum>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fbs_enabled?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  include_in_reporting?: Maybe<Scalars['Boolean']>;
  integrations?: Maybe<Scalars['jsonb']>;
  is_test?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  organization_id?: Maybe<Scalars['uuid']>;
  release_channel?: Maybe<Release_Channel_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  use_branded_returns_portal?: Maybe<Scalars['Boolean']>;
  use_branded_tracking_portal?: Maybe<Scalars['Boolean']>;
};

/** update columns of table "store" */
export const Store_Update_Column = {
  /** column name */
  BrandColor: 'brand_color',
  /** column name */
  BrandLogoPath: 'brand_logo_path',
  /** column name */
  CarrierSelectionPref: 'carrier_selection_pref',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  FbsEnabled: 'fbs_enabled',
  /** column name */
  Id: 'id',
  /** column name */
  IncludeInReporting: 'include_in_reporting',
  /** column name */
  Integrations: 'integrations',
  /** column name */
  IsTest: 'is_test',
  /** column name */
  Name: 'name',
  /** column name */
  OrganizationId: 'organization_id',
  /** column name */
  ReleaseChannel: 'release_channel',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  UseBrandedReturnsPortal: 'use_branded_returns_portal',
  /** column name */
  UseBrandedTrackingPortal: 'use_branded_tracking_portal'
} as const;

export type Store_Update_Column = typeof Store_Update_Column[keyof typeof Store_Update_Column];
export type Store_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Store_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Store_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: Maybe<Store_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Store_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Store_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Store_Set_Input>;
  /** filter the rows which have to be updated */
  where: Store_Bool_Exp;
};

export type Subscription_Root = {
  /** fetch aggregated fields from the table: "payment_status" */
  address_payment_statuses_aggregate: Payment_Status_Aggregate;
  /** fetch data from the table in a streaming manner: "address" */
  address_stream: Array<Address>;
  /** fetch data from the table in a streaming manner: "address_type" */
  address_type_stream: Array<Address_Type>;
  /** fetch data from the table: "address_type" */
  address_types: Array<Address_Type>;
  /** fetch aggregated fields from the table: "address_type" */
  address_types_aggregate: Address_Type_Aggregate;
  /** fetch data from the table: "address_type" using primary key columns */
  address_types_by_pk?: Maybe<Address_Type>;
  /** An array relationship */
  addresses: Array<Address>;
  /** An aggregate relationship */
  addresses_aggregate: Address_Aggregate;
  /** fetch data from the table: "address" using primary key columns */
  addresses_by_pk?: Maybe<Address>;
  /** fetch data from the table: "auth.account_providers" */
  auth_account_providers: Array<Auth_Account_Providers>;
  /** fetch aggregated fields from the table: "auth.account_providers" */
  auth_account_providers_aggregate: Auth_Account_Providers_Aggregate;
  /** fetch data from the table: "auth.account_providers" using primary key columns */
  auth_account_providers_by_pk?: Maybe<Auth_Account_Providers>;
  /** fetch data from the table in a streaming manner: "auth.account_providers" */
  auth_account_providers_stream: Array<Auth_Account_Providers>;
  /** fetch data from the table: "auth.account_roles" */
  auth_account_roles: Array<Auth_Account_Roles>;
  /** fetch aggregated fields from the table: "auth.account_roles" */
  auth_account_roles_aggregate: Auth_Account_Roles_Aggregate;
  /** fetch data from the table: "auth.account_roles" using primary key columns */
  auth_account_roles_by_pk?: Maybe<Auth_Account_Roles>;
  /** fetch data from the table in a streaming manner: "auth.account_roles" */
  auth_account_roles_stream: Array<Auth_Account_Roles>;
  /** fetch data from the table: "auth.accounts" */
  auth_accounts: Array<Auth_Accounts>;
  /** fetch aggregated fields from the table: "auth.accounts" */
  auth_accounts_aggregate: Auth_Accounts_Aggregate;
  /** fetch data from the table: "auth.accounts" using primary key columns */
  auth_accounts_by_pk?: Maybe<Auth_Accounts>;
  /** fetch data from the table in a streaming manner: "auth.accounts" */
  auth_accounts_stream: Array<Auth_Accounts>;
  /** fetch data from the table: "auth.providers" */
  auth_providers: Array<Auth_Providers>;
  /** fetch aggregated fields from the table: "auth.providers" */
  auth_providers_aggregate: Auth_Providers_Aggregate;
  /** fetch data from the table: "auth.providers" using primary key columns */
  auth_providers_by_pk?: Maybe<Auth_Providers>;
  /** fetch data from the table in a streaming manner: "auth.providers" */
  auth_providers_stream: Array<Auth_Providers>;
  /** fetch data from the table: "auth.refresh_tokens" */
  auth_refresh_tokens: Array<Auth_Refresh_Tokens>;
  /** fetch aggregated fields from the table: "auth.refresh_tokens" */
  auth_refresh_tokens_aggregate: Auth_Refresh_Tokens_Aggregate;
  /** fetch data from the table: "auth.refresh_tokens" using primary key columns */
  auth_refresh_tokens_by_pk?: Maybe<Auth_Refresh_Tokens>;
  /** fetch data from the table in a streaming manner: "auth.refresh_tokens" */
  auth_refresh_tokens_stream: Array<Auth_Refresh_Tokens>;
  /** fetch data from the table: "auth.roles" */
  auth_roles: Array<Auth_Roles>;
  /** fetch aggregated fields from the table: "auth.roles" */
  auth_roles_aggregate: Auth_Roles_Aggregate;
  /** fetch data from the table: "auth.roles" using primary key columns */
  auth_roles_by_pk?: Maybe<Auth_Roles>;
  /** fetch data from the table in a streaming manner: "auth.roles" */
  auth_roles_stream: Array<Auth_Roles>;
  /** fetch data from the table: "carrier_selection" */
  carrier_selection: Array<Carrier_Selection>;
  /** fetch aggregated fields from the table: "carrier_selection" */
  carrier_selection_aggregate: Carrier_Selection_Aggregate;
  /** fetch data from the table: "carrier_selection" using primary key columns */
  carrier_selection_by_pk?: Maybe<Carrier_Selection>;
  /** fetch data from the table in a streaming manner: "carrier_selection" */
  carrier_selection_stream: Array<Carrier_Selection>;
  /** fetch data from the table in a streaming manner: "carrier" */
  carrier_stream: Array<Carrier>;
  /** An array relationship */
  carriers: Array<Carrier>;
  /** An aggregate relationship */
  carriers_aggregate: Carrier_Aggregate;
  /** fetch data from the table: "carrier" using primary key columns */
  carriers_by_pk?: Maybe<Carrier>;
  /** fetch data from the table in a streaming manner: "customer" */
  customer_stream: Array<Customer>;
  /** An array relationship */
  customers: Array<Customer>;
  /** An aggregate relationship */
  customers_aggregate: Customer_Aggregate;
  /** fetch data from the table: "customer" using primary key columns */
  customers_by_pk?: Maybe<Customer>;
  /** fetch data from the table: "draft_fulfilment_shipment" */
  draft_fulfilment_shipment: Array<Draft_Fulfilment_Shipment>;
  /** fetch aggregated fields from the table: "draft_fulfilment_shipment" */
  draft_fulfilment_shipment_aggregate: Draft_Fulfilment_Shipment_Aggregate;
  /** fetch data from the table in a streaming manner: "draft_fulfilment_shipment" */
  draft_fulfilment_shipment_stream: Array<Draft_Fulfilment_Shipment>;
  /** fetch data from the table: "event_core.event_store" */
  event_core_event_store: Array<Event_Core_Event_Store>;
  /** fetch aggregated fields from the table: "event_core.event_store" */
  event_core_event_store_aggregate: Event_Core_Event_Store_Aggregate;
  /** fetch data from the table: "event_core.event_store" using primary key columns */
  event_core_event_store_by_pk?: Maybe<Event_Core_Event_Store>;
  /** fetch data from the table in a streaming manner: "event_core.event_store" */
  event_core_event_store_stream: Array<Event_Core_Event_Store>;
  /** fetch data from the table in a streaming manner: "feature_flag" */
  feature_flag_stream: Array<Feature_Flag>;
  /** fetch data from the table: "feature_flag" */
  feature_flags: Array<Feature_Flag>;
  /** fetch aggregated fields from the table: "feature_flag" */
  feature_flags_aggregate: Feature_Flag_Aggregate;
  /** fetch data from the table: "feature_flag" using primary key columns */
  feature_flags_by_pk?: Maybe<Feature_Flag>;
  /** fetch data from the table in a streaming manner: "fulfilment_center_carrier" */
  fulfilment_center_carrier_stream: Array<Fulfilment_Center_Carrier>;
  /** An array relationship */
  fulfilment_center_carriers: Array<Fulfilment_Center_Carrier>;
  /** An aggregate relationship */
  fulfilment_center_carriers_aggregate: Fulfilment_Center_Carrier_Aggregate;
  /** fetch data from the table: "fulfilment_center_carrier" using primary key columns */
  fulfilment_center_carriers_by_pk?: Maybe<Fulfilment_Center_Carrier>;
  /** fetch data from the table in a streaming manner: "fulfilment_center" */
  fulfilment_center_stream: Array<Fulfilment_Center>;
  /** fetch data from the table: "fulfilment_center" */
  fulfilment_centers: Array<Fulfilment_Center>;
  /** fetch aggregated fields from the table: "fulfilment_center" */
  fulfilment_centers_aggregate: Fulfilment_Center_Aggregate;
  /** fetch data from the table: "fulfilment_center" using primary key columns */
  fulfilment_centers_by_pk?: Maybe<Fulfilment_Center>;
  /** fetch data from the table in a streaming manner: "fulfilment_shipment_line_item" */
  fulfilment_shipment_line_item_stream: Array<Fulfilment_Shipment_Line_Item>;
  /** An array relationship */
  fulfilment_shipment_line_items: Array<Fulfilment_Shipment_Line_Item>;
  /** An aggregate relationship */
  fulfilment_shipment_line_items_aggregate: Fulfilment_Shipment_Line_Item_Aggregate;
  /** fetch data from the table: "fulfilment_shipment_line_item" using primary key columns */
  fulfilment_shipment_line_items_by_pk?: Maybe<Fulfilment_Shipment_Line_Item>;
  /** fetch data from the table in a streaming manner: "fulfilment_shipment_parcel" */
  fulfilment_shipment_parcel_stream: Array<Fulfilment_Shipment_Parcel>;
  /** An array relationship */
  fulfilment_shipment_parcels: Array<Fulfilment_Shipment_Parcel>;
  /** An aggregate relationship */
  fulfilment_shipment_parcels_aggregate: Fulfilment_Shipment_Parcel_Aggregate;
  /** fetch data from the table: "fulfilment_shipment_parcel" using primary key columns */
  fulfilment_shipment_parcels_by_pk?: Maybe<Fulfilment_Shipment_Parcel>;
  /** fetch data from the table in a streaming manner: "fulfilment_shipment" */
  fulfilment_shipment_stream: Array<Fulfilment_Shipment>;
  /** An array relationship */
  fulfilment_shipments: Array<Fulfilment_Shipment>;
  /** An aggregate relationship */
  fulfilment_shipments_aggregate: Fulfilment_Shipment_Aggregate;
  /** fetch data from the table: "fulfilment_shipment" using primary key columns */
  fulfilment_shipments_by_pk?: Maybe<Fulfilment_Shipment>;
  /** fetch data from the table: "integration_source" */
  integration_source: Array<Integration_Source>;
  /** fetch aggregated fields from the table: "integration_source" */
  integration_source_aggregate: Integration_Source_Aggregate;
  /** fetch data from the table: "integration_source" using primary key columns */
  integration_source_by_pk?: Maybe<Integration_Source>;
  /** fetch data from the table in a streaming manner: "integration_source" */
  integration_source_stream: Array<Integration_Source>;
  /** fetch data from the table in a streaming manner: "integration" */
  integration_stream: Array<Integration>;
  /** fetch data from the table: "integration" */
  integrations: Array<Integration>;
  /** fetch aggregated fields from the table: "integration" */
  integrations_aggregate: Integration_Aggregate;
  /** fetch data from the table: "integration" using primary key columns */
  integrations_by_pk?: Maybe<Integration>;
  /** An array relationship */
  inventory_item_quantities: Array<Inventory_Item_Quantity>;
  /** An aggregate relationship */
  inventory_item_quantities_aggregate: Inventory_Item_Quantity_Aggregate;
  /** fetch data from the table: "inventory_item_quantity" using primary key columns */
  inventory_item_quantities_by_pk?: Maybe<Inventory_Item_Quantity>;
  /** fetch data from the table in a streaming manner: "inventory_item_quantity" */
  inventory_item_quantity_stream: Array<Inventory_Item_Quantity>;
  /** fetch data from the table in a streaming manner: "inventory_item" */
  inventory_item_stream: Array<Inventory_Item>;
  /** An array relationship */
  inventory_items: Array<Inventory_Item>;
  /** An aggregate relationship */
  inventory_items_aggregate: Inventory_Item_Aggregate;
  /** fetch data from the table: "inventory_item" using primary key columns */
  inventory_items_by_pk?: Maybe<Inventory_Item>;
  /** fetch data from the table: "inventory_sync_job_status" */
  inventory_sync_job_status: Array<Inventory_Sync_Job_Status>;
  /** fetch aggregated fields from the table: "inventory_sync_job_status" */
  inventory_sync_job_status_aggregate: Inventory_Sync_Job_Status_Aggregate;
  /** fetch data from the table: "inventory_sync_job_status" using primary key columns */
  inventory_sync_job_status_by_pk?: Maybe<Inventory_Sync_Job_Status>;
  /** fetch data from the table in a streaming manner: "inventory_sync_job_status" */
  inventory_sync_job_status_stream: Array<Inventory_Sync_Job_Status>;
  /** fetch data from the table in a streaming manner: "inventory_sync_job" */
  inventory_sync_job_stream: Array<Inventory_Sync_Job>;
  /** An array relationship */
  inventory_sync_jobs: Array<Inventory_Sync_Job>;
  /** An aggregate relationship */
  inventory_sync_jobs_aggregate: Inventory_Sync_Job_Aggregate;
  /** fetch data from the table: "inventory_sync_job" using primary key columns */
  inventory_sync_jobs_by_pk?: Maybe<Inventory_Sync_Job>;
  /** fetch data from the table in a streaming manner: "location" */
  location_stream: Array<Location>;
  /** An array relationship */
  locations: Array<Location>;
  /** An aggregate relationship */
  locations_aggregate: Location_Aggregate;
  /** fetch data from the table: "location" using primary key columns */
  locations_by_pk?: Maybe<Location>;
  /** fetch data from the table in a streaming manner: "manifest" */
  manifest_stream: Array<Manifest>;
  /** An array relationship */
  manifests: Array<Manifest>;
  /** An aggregate relationship */
  manifests_aggregate: Manifest_Aggregate;
  /** fetch data from the table: "manifest" using primary key columns */
  manifests_by_pk?: Maybe<Manifest>;
  /** fetch data from the table in a streaming manner: "organization" */
  organization_stream: Array<Organization>;
  /** An array relationship */
  organizations: Array<Organization>;
  /** An aggregate relationship */
  organizations_aggregate: Organization_Aggregate;
  /** fetch data from the table: "organization" using primary key columns */
  organizations_by_pk?: Maybe<Organization>;
  /** fetch data from the table in a streaming manner: "packing_status" */
  packing_status_stream: Array<Packing_Status>;
  /** fetch data from the table: "packing_status" */
  packing_statuses: Array<Packing_Status>;
  /** fetch aggregated fields from the table: "packing_status" */
  packing_statuses_aggregate: Packing_Status_Aggregate;
  /** fetch data from the table: "packing_status" using primary key columns */
  packing_statuses_by_pk?: Maybe<Packing_Status>;
  /** fetch data from the table in a streaming manner: "parcel_type" */
  parcel_type_stream: Array<Parcel_Type>;
  /** An array relationship */
  parcel_types: Array<Parcel_Type>;
  /** An aggregate relationship */
  parcel_types_aggregate: Parcel_Type_Aggregate;
  /** fetch data from the table: "parcel_type" using primary key columns */
  parcel_types_by_pk?: Maybe<Parcel_Type>;
  /** fetch data from the table in a streaming manner: "payment_status" */
  payment_status_stream: Array<Payment_Status>;
  /** fetch data from the table: "payment_status" */
  payment_statuses: Array<Payment_Status>;
  /** fetch data from the table: "payment_status" using primary key columns */
  payment_statuses_by_pk?: Maybe<Payment_Status>;
  /** fetch data from the table in a streaming manner: "product" */
  product_stream: Array<Product>;
  /** fetch data from the table in a streaming manner: "product_variant" */
  product_variant_stream: Array<Product_Variant>;
  /** An array relationship */
  product_variants: Array<Product_Variant>;
  /** An aggregate relationship */
  product_variants_aggregate: Product_Variant_Aggregate;
  /** fetch data from the table: "product_variant" using primary key columns */
  product_variants_by_pk?: Maybe<Product_Variant>;
  /** An array relationship */
  products: Array<Product>;
  /** An aggregate relationship */
  products_aggregate: Product_Aggregate;
  /** fetch data from the table: "product" using primary key columns */
  products_by_pk?: Maybe<Product>;
  /** fetch data from the table in a streaming manner: "rate_request" */
  rate_request_stream: Array<Rate_Request>;
  /** fetch data from the table: "rate_request" */
  rate_requests: Array<Rate_Request>;
  /** fetch aggregated fields from the table: "rate_request" */
  rate_requests_aggregate: Rate_Request_Aggregate;
  /** fetch data from the table: "rate_request" using primary key columns */
  rate_requests_by_pk?: Maybe<Rate_Request>;
  /** fetch data from the table: "rate_selected_by" */
  rate_selected_by: Array<Rate_Selected_By>;
  /** fetch aggregated fields from the table: "rate_selected_by" */
  rate_selected_by_aggregate: Rate_Selected_By_Aggregate;
  /** fetch data from the table: "rate_selected_by" using primary key columns */
  rate_selected_by_by_pk?: Maybe<Rate_Selected_By>;
  /** fetch data from the table in a streaming manner: "rate_selected_by" */
  rate_selected_by_stream: Array<Rate_Selected_By>;
  /** fetch data from the table: "release_channel" */
  release_channel: Array<Release_Channel>;
  /** fetch aggregated fields from the table: "release_channel" */
  release_channel_aggregate: Release_Channel_Aggregate;
  /** fetch data from the table: "release_channel" using primary key columns */
  release_channel_by_pk?: Maybe<Release_Channel>;
  /** fetch data from the table in a streaming manner: "release_channel" */
  release_channel_stream: Array<Release_Channel>;
  /** fetch data from the table in a streaming manner: "retail_unit" */
  retail_unit_stream: Array<Retail_Unit>;
  /** An array relationship */
  retail_units: Array<Retail_Unit>;
  /** An aggregate relationship */
  retail_units_aggregate: Retail_Unit_Aggregate;
  /** fetch data from the table: "retail_unit" using primary key columns */
  retail_units_by_pk?: Maybe<Retail_Unit>;
  /** fetch data from the table: "sales_channel" */
  sales_channel: Array<Sales_Channel>;
  /** fetch aggregated fields from the table: "sales_channel" */
  sales_channel_aggregate: Sales_Channel_Aggregate;
  /** fetch data from the table: "sales_channel" using primary key columns */
  sales_channel_by_pk?: Maybe<Sales_Channel>;
  /** fetch data from the table in a streaming manner: "sales_channel" */
  sales_channel_stream: Array<Sales_Channel>;
  /** fetch data from the table: "sales_order_integration" */
  sales_order_integration: Array<Sales_Order_Integration>;
  /** fetch aggregated fields from the table: "sales_order_integration" */
  sales_order_integration_aggregate: Sales_Order_Integration_Aggregate;
  /** fetch data from the table: "sales_order_integration" using primary key columns */
  sales_order_integration_by_pk?: Maybe<Sales_Order_Integration>;
  /** fetch data from the table in a streaming manner: "sales_order_integration" */
  sales_order_integration_stream: Array<Sales_Order_Integration>;
  /** fetch data from the table in a streaming manner: "sales_order_line_item" */
  sales_order_line_item_stream: Array<Sales_Order_Line_Item>;
  /** An array relationship */
  sales_order_line_items: Array<Sales_Order_Line_Item>;
  /** An aggregate relationship */
  sales_order_line_items_aggregate: Sales_Order_Line_Item_Aggregate;
  /** fetch data from the table: "sales_order_line_item" using primary key columns */
  sales_order_line_items_by_pk?: Maybe<Sales_Order_Line_Item>;
  /** fetch data from the table in a streaming manner: "sales_order_shipment_charge" */
  sales_order_shipment_charge_stream: Array<Sales_Order_Shipment_Charge>;
  /** An array relationship */
  sales_order_shipment_charges: Array<Sales_Order_Shipment_Charge>;
  /** An aggregate relationship */
  sales_order_shipment_charges_aggregate: Sales_Order_Shipment_Charge_Aggregate;
  /** fetch data from the table: "sales_order_shipment_charge" using primary key columns */
  sales_order_shipment_charges_by_pk?: Maybe<Sales_Order_Shipment_Charge>;
  /** fetch data from the table in a streaming manner: "sales_order_status" */
  sales_order_status_stream: Array<Sales_Order_Status>;
  /** fetch data from the table: "sales_order_status" */
  sales_order_statuses: Array<Sales_Order_Status>;
  /** fetch aggregated fields from the table: "sales_order_status" */
  sales_order_statuses_aggregate: Sales_Order_Status_Aggregate;
  /** fetch data from the table: "sales_order_status" using primary key columns */
  sales_order_statuses_by_pk?: Maybe<Sales_Order_Status>;
  /** fetch data from the table in a streaming manner: "sales_order" */
  sales_order_stream: Array<Sales_Order>;
  /** fetch data from the table in a streaming manner: "sales_order_tag" */
  sales_order_tag_stream: Array<Sales_Order_Tag>;
  /** An array relationship */
  sales_order_tags: Array<Sales_Order_Tag>;
  /** An aggregate relationship */
  sales_order_tags_aggregate: Sales_Order_Tag_Aggregate;
  /** fetch data from the table: "sales_order_tag" using primary key columns */
  sales_order_tags_by_pk?: Maybe<Sales_Order_Tag>;
  /** An array relationship */
  sales_orders: Array<Sales_Order>;
  /** An aggregate relationship */
  sales_orders_aggregate: Sales_Order_Aggregate;
  /** fetch data from the table: "sales_order" using primary key columns */
  sales_orders_by_pk?: Maybe<Sales_Order>;
  /** execute function "search_retail_unit" which returns "retail_unit" */
  search_retail_unit: Array<Retail_Unit>;
  /** execute function "search_retail_unit" and query aggregates on result of table type "retail_unit" */
  search_retail_unit_aggregate: Retail_Unit_Aggregate;
  /** execute function "search_tag" which returns "tag" */
  search_tag: Array<Tag>;
  /** execute function "search_tag" and query aggregates on result of table type "tag" */
  search_tag_aggregate: Tag_Aggregate;
  /** fetch data from the table: "shipment_source" */
  shipment_source: Array<Shipment_Source>;
  /** fetch aggregated fields from the table: "shipment_source" */
  shipment_source_aggregate: Shipment_Source_Aggregate;
  /** fetch data from the table: "shipment_source" using primary key columns */
  shipment_source_by_pk?: Maybe<Shipment_Source>;
  /** fetch data from the table in a streaming manner: "shipment_source" */
  shipment_source_stream: Array<Shipment_Source>;
  /** fetch data from the table in a streaming manner: "shipment_status" */
  shipment_status_stream: Array<Shipment_Status>;
  /** fetch data from the table: "shipment_status" */
  shipment_statuses: Array<Shipment_Status>;
  /** fetch aggregated fields from the table: "shipment_status" */
  shipment_statuses_aggregate: Shipment_Status_Aggregate;
  /** fetch data from the table: "shipment_status" using primary key columns */
  shipment_statuses_by_pk?: Maybe<Shipment_Status>;
  /** fetch data from the table in a streaming manner: "shipping_area" */
  shipping_area_stream: Array<Shipping_Area>;
  /** fetch data from the table: "shipping_area" */
  shipping_areas: Array<Shipping_Area>;
  /** fetch aggregated fields from the table: "shipping_area" */
  shipping_areas_aggregate: Shipping_Area_Aggregate;
  /** fetch data from the table: "shipping_area" using primary key columns */
  shipping_areas_by_pk?: Maybe<Shipping_Area>;
  /** fetch data from the table in a streaming manner: "shipping_margin" */
  shipping_margin_stream: Array<Shipping_Margin>;
  /** fetch data from the table: "shipping_margin_type" */
  shipping_margin_type: Array<Shipping_Margin_Type>;
  /** fetch aggregated fields from the table: "shipping_margin_type" */
  shipping_margin_type_aggregate: Shipping_Margin_Type_Aggregate;
  /** fetch data from the table: "shipping_margin_type" using primary key columns */
  shipping_margin_type_by_pk?: Maybe<Shipping_Margin_Type>;
  /** fetch data from the table in a streaming manner: "shipping_margin_type" */
  shipping_margin_type_stream: Array<Shipping_Margin_Type>;
  /** An array relationship */
  shipping_margins: Array<Shipping_Margin>;
  /** An aggregate relationship */
  shipping_margins_aggregate: Shipping_Margin_Aggregate;
  /** fetch data from the table: "shipping_margin" using primary key columns */
  shipping_margins_by_pk?: Maybe<Shipping_Margin>;
  /** fetch data from the table: "shipping_provider" */
  shipping_provider: Array<Shipping_Provider>;
  /** fetch aggregated fields from the table: "shipping_provider" */
  shipping_provider_aggregate: Shipping_Provider_Aggregate;
  /** fetch data from the table: "shipping_provider" using primary key columns */
  shipping_provider_by_pk?: Maybe<Shipping_Provider>;
  /** fetch data from the table in a streaming manner: "shipping_provider" */
  shipping_provider_stream: Array<Shipping_Provider>;
  /** fetch data from the table in a streaming manner: "shipping_rate" */
  shipping_rate_stream: Array<Shipping_Rate>;
  /** An array relationship */
  shipping_rates: Array<Shipping_Rate>;
  /** An aggregate relationship */
  shipping_rates_aggregate: Shipping_Rate_Aggregate;
  /** fetch data from the table: "shipping_rate" using primary key columns */
  shipping_rates_by_pk?: Maybe<Shipping_Rate>;
  /** fetch data from the table in a streaming manner: "shopify.integration" */
  shopify_integration_stream: Array<Shopify_Integration>;
  /** An array relationship */
  shopify_integrations: Array<Shopify_Integration>;
  /** An aggregate relationship */
  shopify_integrations_aggregate: Shopify_Integration_Aggregate;
  /** fetch data from the table: "shopify.integration" using primary key columns */
  shopify_integrations_by_pk?: Maybe<Shopify_Integration>;
  /** fetch data from the table in a streaming manner: "shopify.order_archive" */
  shopify_order_archive_stream: Array<Shopify_Order_Archive>;
  /** fetch data from the table: "shopify.order_archive" */
  shopify_order_archives: Array<Shopify_Order_Archive>;
  /** fetch aggregated fields from the table: "shopify.order_archive" */
  shopify_order_archives_aggregate: Shopify_Order_Archive_Aggregate;
  /** fetch data from the table: "shopify.order_archive" using primary key columns */
  shopify_order_archives_by_pk?: Maybe<Shopify_Order_Archive>;
  /** fetch data from the table in a streaming manner: "stock_transfer_item" */
  stock_transfer_item_stream: Array<Stock_Transfer_Item>;
  /** An array relationship */
  stock_transfer_items: Array<Stock_Transfer_Item>;
  /** An aggregate relationship */
  stock_transfer_items_aggregate: Stock_Transfer_Item_Aggregate;
  /** fetch data from the table: "stock_transfer_item" using primary key columns */
  stock_transfer_items_by_pk?: Maybe<Stock_Transfer_Item>;
  /** fetch data from the table in a streaming manner: "stock_transfer_parcel" */
  stock_transfer_parcel_stream: Array<Stock_Transfer_Parcel>;
  /** fetch data from the table: "stock_transfer_parcel" */
  stock_transfer_parcels: Array<Stock_Transfer_Parcel>;
  /** fetch aggregated fields from the table: "stock_transfer_parcel" */
  stock_transfer_parcels_aggregate: Stock_Transfer_Parcel_Aggregate;
  /** fetch data from the table: "stock_transfer_parcel" using primary key columns */
  stock_transfer_parcels_by_pk?: Maybe<Stock_Transfer_Parcel>;
  /** fetch data from the table in a streaming manner: "stock_transfer_shipment" */
  stock_transfer_shipment_stream: Array<Stock_Transfer_Shipment>;
  /** fetch data from the table: "stock_transfer_shipment" */
  stock_transfer_shipments: Array<Stock_Transfer_Shipment>;
  /** fetch aggregated fields from the table: "stock_transfer_shipment" */
  stock_transfer_shipments_aggregate: Stock_Transfer_Shipment_Aggregate;
  /** fetch data from the table: "stock_transfer_shipment" using primary key columns */
  stock_transfer_shipments_by_pk?: Maybe<Stock_Transfer_Shipment>;
  /** fetch data from the table: "stock_transfer_status" */
  stock_transfer_status: Array<Stock_Transfer_Status>;
  /** fetch aggregated fields from the table: "stock_transfer_status" */
  stock_transfer_status_aggregate: Stock_Transfer_Status_Aggregate;
  /** fetch data from the table: "stock_transfer_status" using primary key columns */
  stock_transfer_status_by_pk?: Maybe<Stock_Transfer_Status>;
  /** fetch data from the table in a streaming manner: "stock_transfer_status" */
  stock_transfer_status_stream: Array<Stock_Transfer_Status>;
  /** fetch data from the table in a streaming manner: "stock_transfer" */
  stock_transfer_stream: Array<Stock_Transfer>;
  /** An array relationship */
  stock_transfers: Array<Stock_Transfer>;
  /** An aggregate relationship */
  stock_transfers_aggregate: Stock_Transfer_Aggregate;
  /** fetch data from the table: "stock_transfer" using primary key columns */
  stock_transfers_by_pk?: Maybe<Stock_Transfer>;
  /** fetch data from the table: "store_feature_flag" */
  store_feature_flag: Array<Store_Feature_Flag>;
  /** fetch aggregated fields from the table: "store_feature_flag" */
  store_feature_flag_aggregate: Store_Feature_Flag_Aggregate;
  /** fetch data from the table: "store_feature_flag" using primary key columns */
  store_feature_flag_by_pk?: Maybe<Store_Feature_Flag>;
  /** fetch data from the table in a streaming manner: "store_feature_flag" */
  store_feature_flag_stream: Array<Store_Feature_Flag>;
  /** fetch data from the table: "store_setting" */
  store_setting: Array<Store_Setting>;
  /** fetch aggregated fields from the table: "store_setting" */
  store_setting_aggregate: Store_Setting_Aggregate;
  /** fetch data from the table: "store_setting" using primary key columns */
  store_setting_by_pk?: Maybe<Store_Setting>;
  /** fetch data from the table: "store_setting_key" */
  store_setting_key: Array<Store_Setting_Key>;
  /** fetch aggregated fields from the table: "store_setting_key" */
  store_setting_key_aggregate: Store_Setting_Key_Aggregate;
  /** fetch data from the table: "store_setting_key" using primary key columns */
  store_setting_key_by_pk?: Maybe<Store_Setting_Key>;
  /** fetch data from the table in a streaming manner: "store_setting_key" */
  store_setting_key_stream: Array<Store_Setting_Key>;
  /** fetch data from the table in a streaming manner: "store_setting" */
  store_setting_stream: Array<Store_Setting>;
  /** fetch data from the table: "store_slug" */
  store_slug: Array<Store_Slug>;
  /** fetch aggregated fields from the table: "store_slug" */
  store_slug_aggregate: Store_Slug_Aggregate;
  /** fetch data from the table: "store_slug" using primary key columns */
  store_slug_by_pk?: Maybe<Store_Slug>;
  /** fetch data from the table in a streaming manner: "store_slug" */
  store_slug_stream: Array<Store_Slug>;
  /** fetch data from the table in a streaming manner: "store" */
  store_stream: Array<Store>;
  /** An array relationship */
  stores: Array<Store>;
  /** An aggregate relationship */
  stores_aggregate: Store_Aggregate;
  /** fetch data from the table: "store" using primary key columns */
  stores_by_pk?: Maybe<Store>;
  /** fetch data from the table in a streaming manner: "tag" */
  tag_stream: Array<Tag>;
  /** An array relationship */
  tags: Array<Tag>;
  /** An aggregate relationship */
  tags_aggregate: Tag_Aggregate;
  /** fetch data from the table: "tag" using primary key columns */
  tags_by_pk?: Maybe<Tag>;
  /** fetch data from the table in a streaming manner: "user_organization" */
  user_organization_stream: Array<User_Organization>;
  /** An array relationship */
  user_organizations: Array<User_Organization>;
  /** An aggregate relationship */
  user_organizations_aggregate: User_Organization_Aggregate;
  /** fetch data from the table: "user_organization" using primary key columns */
  user_organizations_by_pk?: Maybe<User_Organization>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table in a streaming manner: "users" */
  users_stream: Array<Users>;
};


export type Subscription_RootAddress_Payment_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Payment_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Status_Order_By>>;
  where?: Maybe<Payment_Status_Bool_Exp>;
};


export type Subscription_RootAddress_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Address_Stream_Cursor_Input>>;
  where?: Maybe<Address_Bool_Exp>;
};


export type Subscription_RootAddress_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Address_Type_Stream_Cursor_Input>>;
  where?: Maybe<Address_Type_Bool_Exp>;
};


export type Subscription_RootAddress_TypesArgs = {
  distinct_on?: Maybe<Array<Address_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Type_Order_By>>;
  where?: Maybe<Address_Type_Bool_Exp>;
};


export type Subscription_RootAddress_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Address_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Type_Order_By>>;
  where?: Maybe<Address_Type_Bool_Exp>;
};


export type Subscription_RootAddress_Types_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootAddressesArgs = {
  distinct_on?: Maybe<Array<Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Order_By>>;
  where?: Maybe<Address_Bool_Exp>;
};


export type Subscription_RootAddresses_AggregateArgs = {
  distinct_on?: Maybe<Array<Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Address_Order_By>>;
  where?: Maybe<Address_Bool_Exp>;
};


export type Subscription_RootAddresses_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAuth_Account_ProvidersArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Providers_Order_By>>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};


export type Subscription_RootAuth_Account_Providers_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Providers_Order_By>>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};


export type Subscription_RootAuth_Account_Providers_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAuth_Account_Providers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Auth_Account_Providers_Stream_Cursor_Input>>;
  where?: Maybe<Auth_Account_Providers_Bool_Exp>;
};


export type Subscription_RootAuth_Account_RolesArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Roles_Order_By>>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};


export type Subscription_RootAuth_Account_Roles_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Account_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Account_Roles_Order_By>>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};


export type Subscription_RootAuth_Account_Roles_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAuth_Account_Roles_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Auth_Account_Roles_Stream_Cursor_Input>>;
  where?: Maybe<Auth_Account_Roles_Bool_Exp>;
};


export type Subscription_RootAuth_AccountsArgs = {
  distinct_on?: Maybe<Array<Auth_Accounts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Accounts_Order_By>>;
  where?: Maybe<Auth_Accounts_Bool_Exp>;
};


export type Subscription_RootAuth_Accounts_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Accounts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Accounts_Order_By>>;
  where?: Maybe<Auth_Accounts_Bool_Exp>;
};


export type Subscription_RootAuth_Accounts_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAuth_Accounts_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Auth_Accounts_Stream_Cursor_Input>>;
  where?: Maybe<Auth_Accounts_Bool_Exp>;
};


export type Subscription_RootAuth_ProvidersArgs = {
  distinct_on?: Maybe<Array<Auth_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Providers_Order_By>>;
  where?: Maybe<Auth_Providers_Bool_Exp>;
};


export type Subscription_RootAuth_Providers_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Providers_Order_By>>;
  where?: Maybe<Auth_Providers_Bool_Exp>;
};


export type Subscription_RootAuth_Providers_By_PkArgs = {
  provider: Scalars['String'];
};


export type Subscription_RootAuth_Providers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Auth_Providers_Stream_Cursor_Input>>;
  where?: Maybe<Auth_Providers_Bool_Exp>;
};


export type Subscription_RootAuth_Refresh_TokensArgs = {
  distinct_on?: Maybe<Array<Auth_Refresh_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Refresh_Tokens_Order_By>>;
  where?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
};


export type Subscription_RootAuth_Refresh_Tokens_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Refresh_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Refresh_Tokens_Order_By>>;
  where?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
};


export type Subscription_RootAuth_Refresh_Tokens_By_PkArgs = {
  refresh_token: Scalars['uuid'];
};


export type Subscription_RootAuth_Refresh_Tokens_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Auth_Refresh_Tokens_Stream_Cursor_Input>>;
  where?: Maybe<Auth_Refresh_Tokens_Bool_Exp>;
};


export type Subscription_RootAuth_RolesArgs = {
  distinct_on?: Maybe<Array<Auth_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Roles_Order_By>>;
  where?: Maybe<Auth_Roles_Bool_Exp>;
};


export type Subscription_RootAuth_Roles_AggregateArgs = {
  distinct_on?: Maybe<Array<Auth_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Auth_Roles_Order_By>>;
  where?: Maybe<Auth_Roles_Bool_Exp>;
};


export type Subscription_RootAuth_Roles_By_PkArgs = {
  role: Scalars['String'];
};


export type Subscription_RootAuth_Roles_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Auth_Roles_Stream_Cursor_Input>>;
  where?: Maybe<Auth_Roles_Bool_Exp>;
};


export type Subscription_RootCarrier_SelectionArgs = {
  distinct_on?: Maybe<Array<Carrier_Selection_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Selection_Order_By>>;
  where?: Maybe<Carrier_Selection_Bool_Exp>;
};


export type Subscription_RootCarrier_Selection_AggregateArgs = {
  distinct_on?: Maybe<Array<Carrier_Selection_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Selection_Order_By>>;
  where?: Maybe<Carrier_Selection_Bool_Exp>;
};


export type Subscription_RootCarrier_Selection_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCarrier_Selection_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Carrier_Selection_Stream_Cursor_Input>>;
  where?: Maybe<Carrier_Selection_Bool_Exp>;
};


export type Subscription_RootCarrier_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Carrier_Stream_Cursor_Input>>;
  where?: Maybe<Carrier_Bool_Exp>;
};


export type Subscription_RootCarriersArgs = {
  distinct_on?: Maybe<Array<Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Order_By>>;
  where?: Maybe<Carrier_Bool_Exp>;
};


export type Subscription_RootCarriers_AggregateArgs = {
  distinct_on?: Maybe<Array<Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Carrier_Order_By>>;
  where?: Maybe<Carrier_Bool_Exp>;
};


export type Subscription_RootCarriers_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCustomer_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Customer_Stream_Cursor_Input>>;
  where?: Maybe<Customer_Bool_Exp>;
};


export type Subscription_RootCustomersArgs = {
  distinct_on?: Maybe<Array<Customer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Order_By>>;
  where?: Maybe<Customer_Bool_Exp>;
};


export type Subscription_RootCustomers_AggregateArgs = {
  distinct_on?: Maybe<Array<Customer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Order_By>>;
  where?: Maybe<Customer_Bool_Exp>;
};


export type Subscription_RootCustomers_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootDraft_Fulfilment_ShipmentArgs = {
  distinct_on?: Maybe<Array<Draft_Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Draft_Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Draft_Fulfilment_Shipment_Bool_Exp>;
};


export type Subscription_RootDraft_Fulfilment_Shipment_AggregateArgs = {
  distinct_on?: Maybe<Array<Draft_Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Draft_Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Draft_Fulfilment_Shipment_Bool_Exp>;
};


export type Subscription_RootDraft_Fulfilment_Shipment_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Draft_Fulfilment_Shipment_Stream_Cursor_Input>>;
  where?: Maybe<Draft_Fulfilment_Shipment_Bool_Exp>;
};


export type Subscription_RootEvent_Core_Event_StoreArgs = {
  distinct_on?: Maybe<Array<Event_Core_Event_Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Event_Core_Event_Store_Order_By>>;
  where?: Maybe<Event_Core_Event_Store_Bool_Exp>;
};


export type Subscription_RootEvent_Core_Event_Store_AggregateArgs = {
  distinct_on?: Maybe<Array<Event_Core_Event_Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Event_Core_Event_Store_Order_By>>;
  where?: Maybe<Event_Core_Event_Store_Bool_Exp>;
};


export type Subscription_RootEvent_Core_Event_Store_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootEvent_Core_Event_Store_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Event_Core_Event_Store_Stream_Cursor_Input>>;
  where?: Maybe<Event_Core_Event_Store_Bool_Exp>;
};


export type Subscription_RootFeature_Flag_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Feature_Flag_Stream_Cursor_Input>>;
  where?: Maybe<Feature_Flag_Bool_Exp>;
};


export type Subscription_RootFeature_FlagsArgs = {
  distinct_on?: Maybe<Array<Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Flag_Order_By>>;
  where?: Maybe<Feature_Flag_Bool_Exp>;
};


export type Subscription_RootFeature_Flags_AggregateArgs = {
  distinct_on?: Maybe<Array<Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Flag_Order_By>>;
  where?: Maybe<Feature_Flag_Bool_Exp>;
};


export type Subscription_RootFeature_Flags_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootFulfilment_Center_Carrier_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Fulfilment_Center_Carrier_Stream_Cursor_Input>>;
  where?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
};


export type Subscription_RootFulfilment_Center_CarriersArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Carrier_Order_By>>;
  where?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
};


export type Subscription_RootFulfilment_Center_Carriers_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Carrier_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Carrier_Order_By>>;
  where?: Maybe<Fulfilment_Center_Carrier_Bool_Exp>;
};


export type Subscription_RootFulfilment_Center_Carriers_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootFulfilment_Center_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Fulfilment_Center_Stream_Cursor_Input>>;
  where?: Maybe<Fulfilment_Center_Bool_Exp>;
};


export type Subscription_RootFulfilment_CentersArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Order_By>>;
  where?: Maybe<Fulfilment_Center_Bool_Exp>;
};


export type Subscription_RootFulfilment_Centers_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Center_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Center_Order_By>>;
  where?: Maybe<Fulfilment_Center_Bool_Exp>;
};


export type Subscription_RootFulfilment_Centers_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootFulfilment_Shipment_Line_Item_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Fulfilment_Shipment_Line_Item_Stream_Cursor_Input>>;
  where?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
};


export type Subscription_RootFulfilment_Shipment_Line_ItemsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Line_Item_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
};


export type Subscription_RootFulfilment_Shipment_Line_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Line_Item_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Line_Item_Bool_Exp>;
};


export type Subscription_RootFulfilment_Shipment_Line_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootFulfilment_Shipment_Parcel_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Fulfilment_Shipment_Parcel_Stream_Cursor_Input>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


export type Subscription_RootFulfilment_Shipment_ParcelsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


export type Subscription_RootFulfilment_Shipment_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Parcel_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Parcel_Bool_Exp>;
};


export type Subscription_RootFulfilment_Shipment_Parcels_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootFulfilment_Shipment_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Fulfilment_Shipment_Stream_Cursor_Input>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


export type Subscription_RootFulfilment_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


export type Subscription_RootFulfilment_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Fulfilment_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Fulfilment_Shipment_Order_By>>;
  where?: Maybe<Fulfilment_Shipment_Bool_Exp>;
};


export type Subscription_RootFulfilment_Shipments_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootIntegration_SourceArgs = {
  distinct_on?: Maybe<Array<Integration_Source_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Integration_Source_Order_By>>;
  where?: Maybe<Integration_Source_Bool_Exp>;
};


export type Subscription_RootIntegration_Source_AggregateArgs = {
  distinct_on?: Maybe<Array<Integration_Source_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Integration_Source_Order_By>>;
  where?: Maybe<Integration_Source_Bool_Exp>;
};


export type Subscription_RootIntegration_Source_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootIntegration_Source_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Integration_Source_Stream_Cursor_Input>>;
  where?: Maybe<Integration_Source_Bool_Exp>;
};


export type Subscription_RootIntegration_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Integration_Stream_Cursor_Input>>;
  where?: Maybe<Integration_Bool_Exp>;
};


export type Subscription_RootIntegrationsArgs = {
  distinct_on?: Maybe<Array<Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Integration_Order_By>>;
  where?: Maybe<Integration_Bool_Exp>;
};


export type Subscription_RootIntegrations_AggregateArgs = {
  distinct_on?: Maybe<Array<Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Integration_Order_By>>;
  where?: Maybe<Integration_Bool_Exp>;
};


export type Subscription_RootIntegrations_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootInventory_Item_QuantitiesArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


export type Subscription_RootInventory_Item_Quantities_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Quantity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Quantity_Order_By>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


export type Subscription_RootInventory_Item_Quantities_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootInventory_Item_Quantity_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Inventory_Item_Quantity_Stream_Cursor_Input>>;
  where?: Maybe<Inventory_Item_Quantity_Bool_Exp>;
};


export type Subscription_RootInventory_Item_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Inventory_Item_Stream_Cursor_Input>>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};


export type Subscription_RootInventory_ItemsArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Order_By>>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};


export type Subscription_RootInventory_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Item_Order_By>>;
  where?: Maybe<Inventory_Item_Bool_Exp>;
};


export type Subscription_RootInventory_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootInventory_Sync_Job_StatusArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Status_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Status_Bool_Exp>;
};


export type Subscription_RootInventory_Sync_Job_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Status_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Status_Bool_Exp>;
};


export type Subscription_RootInventory_Sync_Job_Status_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootInventory_Sync_Job_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Inventory_Sync_Job_Status_Stream_Cursor_Input>>;
  where?: Maybe<Inventory_Sync_Job_Status_Bool_Exp>;
};


export type Subscription_RootInventory_Sync_Job_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Inventory_Sync_Job_Stream_Cursor_Input>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


export type Subscription_RootInventory_Sync_JobsArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


export type Subscription_RootInventory_Sync_Jobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Inventory_Sync_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inventory_Sync_Job_Order_By>>;
  where?: Maybe<Inventory_Sync_Job_Bool_Exp>;
};


export type Subscription_RootInventory_Sync_Jobs_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootLocation_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Location_Stream_Cursor_Input>>;
  where?: Maybe<Location_Bool_Exp>;
};


export type Subscription_RootLocationsArgs = {
  distinct_on?: Maybe<Array<Location_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Location_Order_By>>;
  where?: Maybe<Location_Bool_Exp>;
};


export type Subscription_RootLocations_AggregateArgs = {
  distinct_on?: Maybe<Array<Location_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Location_Order_By>>;
  where?: Maybe<Location_Bool_Exp>;
};


export type Subscription_RootLocations_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootManifest_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Manifest_Stream_Cursor_Input>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


export type Subscription_RootManifestsArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


export type Subscription_RootManifests_AggregateArgs = {
  distinct_on?: Maybe<Array<Manifest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Manifest_Order_By>>;
  where?: Maybe<Manifest_Bool_Exp>;
};


export type Subscription_RootManifests_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrganization_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Organization_Stream_Cursor_Input>>;
  where?: Maybe<Organization_Bool_Exp>;
};


export type Subscription_RootOrganizationsArgs = {
  distinct_on?: Maybe<Array<Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Organization_Order_By>>;
  where?: Maybe<Organization_Bool_Exp>;
};


export type Subscription_RootOrganizations_AggregateArgs = {
  distinct_on?: Maybe<Array<Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Organization_Order_By>>;
  where?: Maybe<Organization_Bool_Exp>;
};


export type Subscription_RootOrganizations_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPacking_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Packing_Status_Stream_Cursor_Input>>;
  where?: Maybe<Packing_Status_Bool_Exp>;
};


export type Subscription_RootPacking_StatusesArgs = {
  distinct_on?: Maybe<Array<Packing_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Packing_Status_Order_By>>;
  where?: Maybe<Packing_Status_Bool_Exp>;
};


export type Subscription_RootPacking_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Packing_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Packing_Status_Order_By>>;
  where?: Maybe<Packing_Status_Bool_Exp>;
};


export type Subscription_RootPacking_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootParcel_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Parcel_Type_Stream_Cursor_Input>>;
  where?: Maybe<Parcel_Type_Bool_Exp>;
};


export type Subscription_RootParcel_TypesArgs = {
  distinct_on?: Maybe<Array<Parcel_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Parcel_Type_Order_By>>;
  where?: Maybe<Parcel_Type_Bool_Exp>;
};


export type Subscription_RootParcel_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Parcel_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Parcel_Type_Order_By>>;
  where?: Maybe<Parcel_Type_Bool_Exp>;
};


export type Subscription_RootParcel_Types_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPayment_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Payment_Status_Stream_Cursor_Input>>;
  where?: Maybe<Payment_Status_Bool_Exp>;
};


export type Subscription_RootPayment_StatusesArgs = {
  distinct_on?: Maybe<Array<Payment_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Status_Order_By>>;
  where?: Maybe<Payment_Status_Bool_Exp>;
};


export type Subscription_RootPayment_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootProduct_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Product_Stream_Cursor_Input>>;
  where?: Maybe<Product_Bool_Exp>;
};


export type Subscription_RootProduct_Variant_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Product_Variant_Stream_Cursor_Input>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


export type Subscription_RootProduct_VariantsArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


export type Subscription_RootProduct_Variants_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Variant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Variant_Order_By>>;
  where?: Maybe<Product_Variant_Bool_Exp>;
};


export type Subscription_RootProduct_Variants_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootProductsArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};


export type Subscription_RootProducts_AggregateArgs = {
  distinct_on?: Maybe<Array<Product_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Product_Order_By>>;
  where?: Maybe<Product_Bool_Exp>;
};


export type Subscription_RootProducts_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootRate_Request_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Rate_Request_Stream_Cursor_Input>>;
  where?: Maybe<Rate_Request_Bool_Exp>;
};


export type Subscription_RootRate_RequestsArgs = {
  distinct_on?: Maybe<Array<Rate_Request_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Rate_Request_Order_By>>;
  where?: Maybe<Rate_Request_Bool_Exp>;
};


export type Subscription_RootRate_Requests_AggregateArgs = {
  distinct_on?: Maybe<Array<Rate_Request_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Rate_Request_Order_By>>;
  where?: Maybe<Rate_Request_Bool_Exp>;
};


export type Subscription_RootRate_Requests_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRate_Selected_ByArgs = {
  distinct_on?: Maybe<Array<Rate_Selected_By_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Rate_Selected_By_Order_By>>;
  where?: Maybe<Rate_Selected_By_Bool_Exp>;
};


export type Subscription_RootRate_Selected_By_AggregateArgs = {
  distinct_on?: Maybe<Array<Rate_Selected_By_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Rate_Selected_By_Order_By>>;
  where?: Maybe<Rate_Selected_By_Bool_Exp>;
};


export type Subscription_RootRate_Selected_By_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootRate_Selected_By_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Rate_Selected_By_Stream_Cursor_Input>>;
  where?: Maybe<Rate_Selected_By_Bool_Exp>;
};


export type Subscription_RootRelease_ChannelArgs = {
  distinct_on?: Maybe<Array<Release_Channel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Release_Channel_Order_By>>;
  where?: Maybe<Release_Channel_Bool_Exp>;
};


export type Subscription_RootRelease_Channel_AggregateArgs = {
  distinct_on?: Maybe<Array<Release_Channel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Release_Channel_Order_By>>;
  where?: Maybe<Release_Channel_Bool_Exp>;
};


export type Subscription_RootRelease_Channel_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootRelease_Channel_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Release_Channel_Stream_Cursor_Input>>;
  where?: Maybe<Release_Channel_Bool_Exp>;
};


export type Subscription_RootRetail_Unit_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Retail_Unit_Stream_Cursor_Input>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


export type Subscription_RootRetail_UnitsArgs = {
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


export type Subscription_RootRetail_Units_AggregateArgs = {
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


export type Subscription_RootRetail_Units_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootSales_ChannelArgs = {
  distinct_on?: Maybe<Array<Sales_Channel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Channel_Order_By>>;
  where?: Maybe<Sales_Channel_Bool_Exp>;
};


export type Subscription_RootSales_Channel_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Channel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Channel_Order_By>>;
  where?: Maybe<Sales_Channel_Bool_Exp>;
};


export type Subscription_RootSales_Channel_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootSales_Channel_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Sales_Channel_Stream_Cursor_Input>>;
  where?: Maybe<Sales_Channel_Bool_Exp>;
};


export type Subscription_RootSales_Order_IntegrationArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Integration_Order_By>>;
  where?: Maybe<Sales_Order_Integration_Bool_Exp>;
};


export type Subscription_RootSales_Order_Integration_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Integration_Order_By>>;
  where?: Maybe<Sales_Order_Integration_Bool_Exp>;
};


export type Subscription_RootSales_Order_Integration_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootSales_Order_Integration_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Sales_Order_Integration_Stream_Cursor_Input>>;
  where?: Maybe<Sales_Order_Integration_Bool_Exp>;
};


export type Subscription_RootSales_Order_Line_Item_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Sales_Order_Line_Item_Stream_Cursor_Input>>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};


export type Subscription_RootSales_Order_Line_ItemsArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Line_Item_Order_By>>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};


export type Subscription_RootSales_Order_Line_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Line_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Line_Item_Order_By>>;
  where?: Maybe<Sales_Order_Line_Item_Bool_Exp>;
};


export type Subscription_RootSales_Order_Line_Items_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSales_Order_Shipment_Charge_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Sales_Order_Shipment_Charge_Stream_Cursor_Input>>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};


export type Subscription_RootSales_Order_Shipment_ChargesArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Shipment_Charge_Order_By>>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};


export type Subscription_RootSales_Order_Shipment_Charges_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Shipment_Charge_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Shipment_Charge_Order_By>>;
  where?: Maybe<Sales_Order_Shipment_Charge_Bool_Exp>;
};


export type Subscription_RootSales_Order_Shipment_Charges_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSales_Order_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Sales_Order_Status_Stream_Cursor_Input>>;
  where?: Maybe<Sales_Order_Status_Bool_Exp>;
};


export type Subscription_RootSales_Order_StatusesArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Status_Order_By>>;
  where?: Maybe<Sales_Order_Status_Bool_Exp>;
};


export type Subscription_RootSales_Order_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Status_Order_By>>;
  where?: Maybe<Sales_Order_Status_Bool_Exp>;
};


export type Subscription_RootSales_Order_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootSales_Order_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Sales_Order_Stream_Cursor_Input>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


export type Subscription_RootSales_Order_Tag_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Sales_Order_Tag_Stream_Cursor_Input>>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};


export type Subscription_RootSales_Order_TagsArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Tag_Order_By>>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};


export type Subscription_RootSales_Order_Tags_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Tag_Order_By>>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};


export type Subscription_RootSales_Order_Tags_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootSales_OrdersArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


export type Subscription_RootSales_Orders_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Order_By>>;
  where?: Maybe<Sales_Order_Bool_Exp>;
};


export type Subscription_RootSales_Orders_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSearch_Retail_UnitArgs = {
  args: Search_Retail_Unit_Args;
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


export type Subscription_RootSearch_Retail_Unit_AggregateArgs = {
  args: Search_Retail_Unit_Args;
  distinct_on?: Maybe<Array<Retail_Unit_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Retail_Unit_Order_By>>;
  where?: Maybe<Retail_Unit_Bool_Exp>;
};


export type Subscription_RootSearch_TagArgs = {
  args: Search_Tag_Args;
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


export type Subscription_RootSearch_Tag_AggregateArgs = {
  args: Search_Tag_Args;
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


export type Subscription_RootShipment_SourceArgs = {
  distinct_on?: Maybe<Array<Shipment_Source_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipment_Source_Order_By>>;
  where?: Maybe<Shipment_Source_Bool_Exp>;
};


export type Subscription_RootShipment_Source_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipment_Source_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipment_Source_Order_By>>;
  where?: Maybe<Shipment_Source_Bool_Exp>;
};


export type Subscription_RootShipment_Source_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootShipment_Source_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Shipment_Source_Stream_Cursor_Input>>;
  where?: Maybe<Shipment_Source_Bool_Exp>;
};


export type Subscription_RootShipment_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Shipment_Status_Stream_Cursor_Input>>;
  where?: Maybe<Shipment_Status_Bool_Exp>;
};


export type Subscription_RootShipment_StatusesArgs = {
  distinct_on?: Maybe<Array<Shipment_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipment_Status_Order_By>>;
  where?: Maybe<Shipment_Status_Bool_Exp>;
};


export type Subscription_RootShipment_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipment_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipment_Status_Order_By>>;
  where?: Maybe<Shipment_Status_Bool_Exp>;
};


export type Subscription_RootShipment_Statuses_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootShipping_Area_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Shipping_Area_Stream_Cursor_Input>>;
  where?: Maybe<Shipping_Area_Bool_Exp>;
};


export type Subscription_RootShipping_AreasArgs = {
  distinct_on?: Maybe<Array<Shipping_Area_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Area_Order_By>>;
  where?: Maybe<Shipping_Area_Bool_Exp>;
};


export type Subscription_RootShipping_Areas_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Area_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Area_Order_By>>;
  where?: Maybe<Shipping_Area_Bool_Exp>;
};


export type Subscription_RootShipping_Areas_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootShipping_Margin_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Shipping_Margin_Stream_Cursor_Input>>;
  where?: Maybe<Shipping_Margin_Bool_Exp>;
};


export type Subscription_RootShipping_Margin_TypeArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Type_Order_By>>;
  where?: Maybe<Shipping_Margin_Type_Bool_Exp>;
};


export type Subscription_RootShipping_Margin_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Type_Order_By>>;
  where?: Maybe<Shipping_Margin_Type_Bool_Exp>;
};


export type Subscription_RootShipping_Margin_Type_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootShipping_Margin_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Shipping_Margin_Type_Stream_Cursor_Input>>;
  where?: Maybe<Shipping_Margin_Type_Bool_Exp>;
};


export type Subscription_RootShipping_MarginsArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Order_By>>;
  where?: Maybe<Shipping_Margin_Bool_Exp>;
};


export type Subscription_RootShipping_Margins_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Margin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Margin_Order_By>>;
  where?: Maybe<Shipping_Margin_Bool_Exp>;
};


export type Subscription_RootShipping_Margins_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootShipping_ProviderArgs = {
  distinct_on?: Maybe<Array<Shipping_Provider_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Provider_Order_By>>;
  where?: Maybe<Shipping_Provider_Bool_Exp>;
};


export type Subscription_RootShipping_Provider_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Provider_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Provider_Order_By>>;
  where?: Maybe<Shipping_Provider_Bool_Exp>;
};


export type Subscription_RootShipping_Provider_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootShipping_Provider_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Shipping_Provider_Stream_Cursor_Input>>;
  where?: Maybe<Shipping_Provider_Bool_Exp>;
};


export type Subscription_RootShipping_Rate_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Shipping_Rate_Stream_Cursor_Input>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


export type Subscription_RootShipping_RatesArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


export type Subscription_RootShipping_Rates_AggregateArgs = {
  distinct_on?: Maybe<Array<Shipping_Rate_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shipping_Rate_Order_By>>;
  where?: Maybe<Shipping_Rate_Bool_Exp>;
};


export type Subscription_RootShipping_Rates_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootShopify_Integration_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Shopify_Integration_Stream_Cursor_Input>>;
  where?: Maybe<Shopify_Integration_Bool_Exp>;
};


export type Subscription_RootShopify_IntegrationsArgs = {
  distinct_on?: Maybe<Array<Shopify_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Integration_Order_By>>;
  where?: Maybe<Shopify_Integration_Bool_Exp>;
};


export type Subscription_RootShopify_Integrations_AggregateArgs = {
  distinct_on?: Maybe<Array<Shopify_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Integration_Order_By>>;
  where?: Maybe<Shopify_Integration_Bool_Exp>;
};


export type Subscription_RootShopify_Integrations_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootShopify_Order_Archive_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Shopify_Order_Archive_Stream_Cursor_Input>>;
  where?: Maybe<Shopify_Order_Archive_Bool_Exp>;
};


export type Subscription_RootShopify_Order_ArchivesArgs = {
  distinct_on?: Maybe<Array<Shopify_Order_Archive_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Order_Archive_Order_By>>;
  where?: Maybe<Shopify_Order_Archive_Bool_Exp>;
};


export type Subscription_RootShopify_Order_Archives_AggregateArgs = {
  distinct_on?: Maybe<Array<Shopify_Order_Archive_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Shopify_Order_Archive_Order_By>>;
  where?: Maybe<Shopify_Order_Archive_Bool_Exp>;
};


export type Subscription_RootShopify_Order_Archives_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootStock_Transfer_Item_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Stock_Transfer_Item_Stream_Cursor_Input>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_ItemsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_Items_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Item_Order_By>>;
  where?: Maybe<Stock_Transfer_Item_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootStock_Transfer_Parcel_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Stock_Transfer_Parcel_Stream_Cursor_Input>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_ParcelsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_Parcels_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Parcel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Parcel_Order_By>>;
  where?: Maybe<Stock_Transfer_Parcel_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_Parcels_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootStock_Transfer_Shipment_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Stock_Transfer_Shipment_Stream_Cursor_Input>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_ShipmentsArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_Shipments_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Shipment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Shipment_Order_By>>;
  where?: Maybe<Stock_Transfer_Shipment_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_Shipments_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootStock_Transfer_StatusArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Status_Order_By>>;
  where?: Maybe<Stock_Transfer_Status_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Status_Order_By>>;
  where?: Maybe<Stock_Transfer_Status_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_Status_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootStock_Transfer_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Stock_Transfer_Status_Stream_Cursor_Input>>;
  where?: Maybe<Stock_Transfer_Status_Bool_Exp>;
};


export type Subscription_RootStock_Transfer_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Stock_Transfer_Stream_Cursor_Input>>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};


export type Subscription_RootStock_TransfersArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Order_By>>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};


export type Subscription_RootStock_Transfers_AggregateArgs = {
  distinct_on?: Maybe<Array<Stock_Transfer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stock_Transfer_Order_By>>;
  where?: Maybe<Stock_Transfer_Bool_Exp>;
};


export type Subscription_RootStock_Transfers_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootStore_Feature_FlagArgs = {
  distinct_on?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Feature_Flag_Order_By>>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};


export type Subscription_RootStore_Feature_Flag_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Feature_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Feature_Flag_Order_By>>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};


export type Subscription_RootStore_Feature_Flag_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootStore_Feature_Flag_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Store_Feature_Flag_Stream_Cursor_Input>>;
  where?: Maybe<Store_Feature_Flag_Bool_Exp>;
};


export type Subscription_RootStore_SettingArgs = {
  distinct_on?: Maybe<Array<Store_Setting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Setting_Order_By>>;
  where?: Maybe<Store_Setting_Bool_Exp>;
};


export type Subscription_RootStore_Setting_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Setting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Setting_Order_By>>;
  where?: Maybe<Store_Setting_Bool_Exp>;
};


export type Subscription_RootStore_Setting_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootStore_Setting_KeyArgs = {
  distinct_on?: Maybe<Array<Store_Setting_Key_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Setting_Key_Order_By>>;
  where?: Maybe<Store_Setting_Key_Bool_Exp>;
};


export type Subscription_RootStore_Setting_Key_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Setting_Key_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Setting_Key_Order_By>>;
  where?: Maybe<Store_Setting_Key_Bool_Exp>;
};


export type Subscription_RootStore_Setting_Key_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootStore_Setting_Key_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Store_Setting_Key_Stream_Cursor_Input>>;
  where?: Maybe<Store_Setting_Key_Bool_Exp>;
};


export type Subscription_RootStore_Setting_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Store_Setting_Stream_Cursor_Input>>;
  where?: Maybe<Store_Setting_Bool_Exp>;
};


export type Subscription_RootStore_SlugArgs = {
  distinct_on?: Maybe<Array<Store_Slug_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Slug_Order_By>>;
  where?: Maybe<Store_Slug_Bool_Exp>;
};


export type Subscription_RootStore_Slug_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Slug_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Slug_Order_By>>;
  where?: Maybe<Store_Slug_Bool_Exp>;
};


export type Subscription_RootStore_Slug_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootStore_Slug_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Store_Slug_Stream_Cursor_Input>>;
  where?: Maybe<Store_Slug_Bool_Exp>;
};


export type Subscription_RootStore_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Store_Stream_Cursor_Input>>;
  where?: Maybe<Store_Bool_Exp>;
};


export type Subscription_RootStoresArgs = {
  distinct_on?: Maybe<Array<Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Order_By>>;
  where?: Maybe<Store_Bool_Exp>;
};


export type Subscription_RootStores_AggregateArgs = {
  distinct_on?: Maybe<Array<Store_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Store_Order_By>>;
  where?: Maybe<Store_Bool_Exp>;
};


export type Subscription_RootStores_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootTag_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Tag_Stream_Cursor_Input>>;
  where?: Maybe<Tag_Bool_Exp>;
};


export type Subscription_RootTagsArgs = {
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


export type Subscription_RootTags_AggregateArgs = {
  distinct_on?: Maybe<Array<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


export type Subscription_RootTags_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootUser_Organization_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Organization_Stream_Cursor_Input>>;
  where?: Maybe<User_Organization_Bool_Exp>;
};


export type Subscription_RootUser_OrganizationsArgs = {
  distinct_on?: Maybe<Array<User_Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Organization_Order_By>>;
  where?: Maybe<User_Organization_Bool_Exp>;
};


export type Subscription_RootUser_Organizations_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Organization_Order_By>>;
  where?: Maybe<User_Organization_Bool_Exp>;
};


export type Subscription_RootUser_Organizations_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsersArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Users_Stream_Cursor_Input>>;
  where?: Maybe<Users_Bool_Exp>;
};

/** columns and relationships of "tag" */
export type Tag = {
  created_at: Scalars['timestamptz'];
  id: Scalars['bigint'];
  name: Scalars['String'];
  /** An array relationship */
  sales_order_tags: Array<Sales_Order_Tag>;
  /** An aggregate relationship */
  sales_order_tags_aggregate: Sales_Order_Tag_Aggregate;
  /** An object relationship */
  store: Store;
  store_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "tag" */
export type TagSales_Order_TagsArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Tag_Order_By>>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};


/** columns and relationships of "tag" */
export type TagSales_Order_Tags_AggregateArgs = {
  distinct_on?: Maybe<Array<Sales_Order_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Sales_Order_Tag_Order_By>>;
  where?: Maybe<Sales_Order_Tag_Bool_Exp>;
};

/** aggregated selection of "tag" */
export type Tag_Aggregate = {
  aggregate?: Maybe<Tag_Aggregate_Fields>;
  nodes: Array<Tag>;
};

export type Tag_Aggregate_Bool_Exp = {
  count?: Maybe<Tag_Aggregate_Bool_Exp_Count>;
};

export type Tag_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Tag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tag_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tag" */
export type Tag_Aggregate_Fields = {
  avg?: Maybe<Tag_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Tag_Max_Fields>;
  min?: Maybe<Tag_Min_Fields>;
  stddev?: Maybe<Tag_Stddev_Fields>;
  stddev_pop?: Maybe<Tag_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Tag_Stddev_Samp_Fields>;
  sum?: Maybe<Tag_Sum_Fields>;
  var_pop?: Maybe<Tag_Var_Pop_Fields>;
  var_samp?: Maybe<Tag_Var_Samp_Fields>;
  variance?: Maybe<Tag_Variance_Fields>;
};


/** aggregate fields of "tag" */
export type Tag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Tag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "tag" */
export type Tag_Aggregate_Order_By = {
  avg?: Maybe<Tag_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Tag_Max_Order_By>;
  min?: Maybe<Tag_Min_Order_By>;
  stddev?: Maybe<Tag_Stddev_Order_By>;
  stddev_pop?: Maybe<Tag_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Tag_Stddev_Samp_Order_By>;
  sum?: Maybe<Tag_Sum_Order_By>;
  var_pop?: Maybe<Tag_Var_Pop_Order_By>;
  var_samp?: Maybe<Tag_Var_Samp_Order_By>;
  variance?: Maybe<Tag_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "tag" */
export type Tag_Arr_Rel_Insert_Input = {
  data: Array<Tag_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Tag_On_Conflict>;
};

/** aggregate avg on columns */
export type Tag_Avg_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "tag" */
export type Tag_Avg_Order_By = {
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'. */
export type Tag_Bool_Exp = {
  _and?: Maybe<Array<Tag_Bool_Exp>>;
  _not?: Maybe<Tag_Bool_Exp>;
  _or?: Maybe<Array<Tag_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  sales_order_tags?: Maybe<Sales_Order_Tag_Bool_Exp>;
  sales_order_tags_aggregate?: Maybe<Sales_Order_Tag_Aggregate_Bool_Exp>;
  store?: Maybe<Store_Bool_Exp>;
  store_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "tag" */
export const Tag_Constraint = {
  /** unique or primary key constraint on columns "store_id", "name" */
  TagNameStoreIdKey: 'tag_name_store_id_key',
  /** unique or primary key constraint on columns "id" */
  TagPkey: 'tag_pkey'
} as const;

export type Tag_Constraint = typeof Tag_Constraint[keyof typeof Tag_Constraint];
/** input type for incrementing numeric columns in table "tag" */
export type Tag_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "tag" */
export type Tag_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  sales_order_tags?: Maybe<Sales_Order_Tag_Arr_Rel_Insert_Input>;
  store?: Maybe<Store_Obj_Rel_Insert_Input>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Tag_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "tag" */
export type Tag_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tag_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "tag" */
export type Tag_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "tag" */
export type Tag_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Tag>;
};

/** input type for inserting object relation for remote table "tag" */
export type Tag_Obj_Rel_Insert_Input = {
  data: Tag_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Tag_On_Conflict>;
};

/** on_conflict condition type for table "tag" */
export type Tag_On_Conflict = {
  constraint: Tag_Constraint;
  update_columns?: Array<Tag_Update_Column>;
  where?: Maybe<Tag_Bool_Exp>;
};

/** Ordering options when selecting data from "tag". */
export type Tag_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  sales_order_tags_aggregate?: Maybe<Sales_Order_Tag_Aggregate_Order_By>;
  store?: Maybe<Store_Order_By>;
  store_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: tag */
export type Tag_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "tag" */
export const Tag_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Tag_Select_Column = typeof Tag_Select_Column[keyof typeof Tag_Select_Column];
/** input type for updating data in table "tag" */
export type Tag_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Tag_Stddev_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "tag" */
export type Tag_Stddev_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Tag_Stddev_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "tag" */
export type Tag_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Tag_Stddev_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "tag" */
export type Tag_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "tag" */
export type Tag_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tag_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tag_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  store_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Tag_Sum_Fields = {
  id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "tag" */
export type Tag_Sum_Order_By = {
  id?: Maybe<Order_By>;
};

/** update columns of table "tag" */
export const Tag_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  Name: 'name',
  /** column name */
  StoreId: 'store_id',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Tag_Update_Column = typeof Tag_Update_Column[keyof typeof Tag_Update_Column];
export type Tag_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Tag_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Tag_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tag_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Tag_Var_Pop_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "tag" */
export type Tag_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Tag_Var_Samp_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "tag" */
export type Tag_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Tag_Variance_Fields = {
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "tag" */
export type Tag_Variance_Order_By = {
  id?: Maybe<Order_By>;
};


/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: Maybe<Scalars['timestamptz']>;
  _gt?: Maybe<Scalars['timestamptz']>;
  _gte?: Maybe<Scalars['timestamptz']>;
  _in?: Maybe<Array<Scalars['timestamptz']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['timestamptz']>;
  _lte?: Maybe<Scalars['timestamptz']>;
  _neq?: Maybe<Scalars['timestamptz']>;
  _nin?: Maybe<Array<Scalars['timestamptz']>>;
};

/** columns and relationships of "user_organization" */
export type User_Organization = {
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  organization: Organization;
  organization_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  user_id: Scalars['uuid'];
  /** An object relationship */
  users: Users;
};

/** aggregated selection of "user_organization" */
export type User_Organization_Aggregate = {
  aggregate?: Maybe<User_Organization_Aggregate_Fields>;
  nodes: Array<User_Organization>;
};

export type User_Organization_Aggregate_Bool_Exp = {
  count?: Maybe<User_Organization_Aggregate_Bool_Exp_Count>;
};

export type User_Organization_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<User_Organization_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Organization_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_organization" */
export type User_Organization_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<User_Organization_Max_Fields>;
  min?: Maybe<User_Organization_Min_Fields>;
};


/** aggregate fields of "user_organization" */
export type User_Organization_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Organization_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_organization" */
export type User_Organization_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<User_Organization_Max_Order_By>;
  min?: Maybe<User_Organization_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_organization" */
export type User_Organization_Arr_Rel_Insert_Input = {
  data: Array<User_Organization_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<User_Organization_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_organization". All fields are combined with a logical 'AND'. */
export type User_Organization_Bool_Exp = {
  _and?: Maybe<Array<User_Organization_Bool_Exp>>;
  _not?: Maybe<User_Organization_Bool_Exp>;
  _or?: Maybe<Array<User_Organization_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  organization?: Maybe<Organization_Bool_Exp>;
  organization_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
  users?: Maybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "user_organization" */
export const User_Organization_Constraint = {
  /** unique or primary key constraint on columns "id" */
  UserOrganizationPkey: 'user_organization_pkey'
} as const;

export type User_Organization_Constraint = typeof User_Organization_Constraint[keyof typeof User_Organization_Constraint];
/** input type for inserting data into table "user_organization" */
export type User_Organization_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  organization?: Maybe<Organization_Obj_Rel_Insert_Input>;
  organization_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  users?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type User_Organization_Max_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  organization_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_organization" */
export type User_Organization_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  organization_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type User_Organization_Min_Fields = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  organization_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_organization" */
export type User_Organization_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  organization_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "user_organization" */
export type User_Organization_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Organization>;
};

/** on_conflict condition type for table "user_organization" */
export type User_Organization_On_Conflict = {
  constraint: User_Organization_Constraint;
  update_columns?: Array<User_Organization_Update_Column>;
  where?: Maybe<User_Organization_Bool_Exp>;
};

/** Ordering options when selecting data from "user_organization". */
export type User_Organization_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  organization?: Maybe<Organization_Order_By>;
  organization_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  users?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: user_organization */
export type User_Organization_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "user_organization" */
export const User_Organization_Select_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  OrganizationId: 'organization_id',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  UserId: 'user_id'
} as const;

export type User_Organization_Select_Column = typeof User_Organization_Select_Column[keyof typeof User_Organization_Select_Column];
/** input type for updating data in table "user_organization" */
export type User_Organization_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  organization_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_organization" */
export type User_Organization_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Organization_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Organization_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  organization_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "user_organization" */
export const User_Organization_Update_Column = {
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  Id: 'id',
  /** column name */
  OrganizationId: 'organization_id',
  /** column name */
  UpdatedAt: 'updated_at',
  /** column name */
  UserId: 'user_id'
} as const;

export type User_Organization_Update_Column = typeof User_Organization_Update_Column[keyof typeof User_Organization_Update_Column];
export type User_Organization_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Organization_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Organization_Bool_Exp;
};

/** columns and relationships of "users" */
export type Users = {
  /** An object relationship */
  account?: Maybe<Auth_Accounts>;
  avatar_url?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  display_name?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  last_name?: Maybe<Scalars['String']>;
  /** An array relationship */
  organizations: Array<Organization>;
  /** An aggregate relationship */
  organizations_aggregate: Organization_Aggregate;
  updated_at: Scalars['timestamptz'];
  /** An array relationship */
  user_organizations: Array<User_Organization>;
  /** An aggregate relationship */
  user_organizations_aggregate: User_Organization_Aggregate;
};


/** columns and relationships of "users" */
export type UsersOrganizationsArgs = {
  distinct_on?: Maybe<Array<Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Organization_Order_By>>;
  where?: Maybe<Organization_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersOrganizations_AggregateArgs = {
  distinct_on?: Maybe<Array<Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Organization_Order_By>>;
  where?: Maybe<Organization_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersUser_OrganizationsArgs = {
  distinct_on?: Maybe<Array<User_Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Organization_Order_By>>;
  where?: Maybe<User_Organization_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersUser_Organizations_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Organization_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Organization_Order_By>>;
  where?: Maybe<User_Organization_Bool_Exp>;
};

/** aggregated selection of "users" */
export type Users_Aggregate = {
  aggregate?: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

/** aggregate fields of "users" */
export type Users_Aggregate_Fields = {
  count: Scalars['Int'];
  max?: Maybe<Users_Max_Fields>;
  min?: Maybe<Users_Min_Fields>;
};


/** aggregate fields of "users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Users_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and?: Maybe<Array<Users_Bool_Exp>>;
  _not?: Maybe<Users_Bool_Exp>;
  _or?: Maybe<Array<Users_Bool_Exp>>;
  account?: Maybe<Auth_Accounts_Bool_Exp>;
  avatar_url?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  display_name?: Maybe<String_Comparison_Exp>;
  first_name?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  last_name?: Maybe<String_Comparison_Exp>;
  organizations?: Maybe<Organization_Bool_Exp>;
  organizations_aggregate?: Maybe<Organization_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_organizations?: Maybe<User_Organization_Bool_Exp>;
  user_organizations_aggregate?: Maybe<User_Organization_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "users" */
export const Users_Constraint = {
  /** unique or primary key constraint on columns "id" */
  UsersPkey: 'users_pkey'
} as const;

export type Users_Constraint = typeof Users_Constraint[keyof typeof Users_Constraint];
/** input type for inserting data into table "users" */
export type Users_Insert_Input = {
  account?: Maybe<Auth_Accounts_Obj_Rel_Insert_Input>;
  avatar_url?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  display_name?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  organizations?: Maybe<Organization_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_organizations?: Maybe<User_Organization_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  avatar_url?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  display_name?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  avatar_url?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  display_name?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "users" */
export type Users_Mutation_Response = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns?: Array<Users_Update_Column>;
  where?: Maybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "users". */
export type Users_Order_By = {
  account?: Maybe<Auth_Accounts_Order_By>;
  avatar_url?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  display_name?: Maybe<Order_By>;
  first_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_name?: Maybe<Order_By>;
  organizations_aggregate?: Maybe<Organization_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  user_organizations_aggregate?: Maybe<User_Organization_Aggregate_Order_By>;
};

/** primary key columns input for table: users */
export type Users_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "users" */
export const Users_Select_Column = {
  /** column name */
  AvatarUrl: 'avatar_url',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DisplayName: 'display_name',
  /** column name */
  FirstName: 'first_name',
  /** column name */
  Id: 'id',
  /** column name */
  LastName: 'last_name',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Users_Select_Column = typeof Users_Select_Column[keyof typeof Users_Select_Column];
/** input type for updating data in table "users" */
export type Users_Set_Input = {
  avatar_url?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  display_name?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "users" */
export type Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Stream_Cursor_Value_Input = {
  avatar_url?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  display_name?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "users" */
export const Users_Update_Column = {
  /** column name */
  AvatarUrl: 'avatar_url',
  /** column name */
  CreatedAt: 'created_at',
  /** column name */
  DisplayName: 'display_name',
  /** column name */
  FirstName: 'first_name',
  /** column name */
  Id: 'id',
  /** column name */
  LastName: 'last_name',
  /** column name */
  UpdatedAt: 'updated_at'
} as const;

export type Users_Update_Column = typeof Users_Update_Column[keyof typeof Users_Update_Column];
export type Users_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Bool_Exp;
};


/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: Maybe<Scalars['uuid']>;
  _gt?: Maybe<Scalars['uuid']>;
  _gte?: Maybe<Scalars['uuid']>;
  _in?: Maybe<Array<Scalars['uuid']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['uuid']>;
  _lte?: Maybe<Scalars['uuid']>;
  _neq?: Maybe<Scalars['uuid']>;
  _nin?: Maybe<Array<Scalars['uuid']>>;
};

export type StockTransferCommandMutationVariables = Exact<{
  command: StockTransferCommand;
  storeId: Scalars['uuid'];
}>;


export type StockTransferCommandMutation = { handleStockTransferCommand?: Maybe<(
    Pick<StockTransferCommandOutput, 'stockTransferId' | 'outcome'>
    & { stockTransfer?: Maybe<Pick<Stock_Transfer, 'id'>> }
  )> };

export type GetStockTransfersQueryVariables = Exact<{
  storeId: Scalars['uuid'];
  offset?: Maybe<Scalars['Int']>;
  limit?: Maybe<Scalars['Int']>;
}>;


export type GetStockTransfersQuery = { stockTransfers: Array<(
    Pick<Stock_Transfer, 'id' | 'status' | 'notes'>
    & { referenceNumber: Stock_Transfer['reference_number'], updatedAt: Stock_Transfer['updated_at'] }
    & { transferItems: Array<(
      Pick<Stock_Transfer_Item, 'quantity'>
      & { quantityReceived: Stock_Transfer_Item['quantity_received'] }
    )>, transferShipments: Array<(
      Pick<Stock_Transfer_Shipment, 'eta'>
      & { updatedAt: Stock_Transfer_Shipment['updated_at'], receivedAt: Stock_Transfer_Shipment['received_at'], trackingNumber: Stock_Transfer_Shipment['tracking_number'], trackingUrl: Stock_Transfer_Shipment['tracking_url'], shippedAt: Stock_Transfer_Shipment['shipped_at'] }
    )> }
  )>, stockTransfersAggregate: { aggregate?: Maybe<Pick<Stock_Transfer_Aggregate_Fields, 'count'>> } };

export type StockTransferItemWithProductInfoFragment = (
  Pick<Stock_Transfer_Item, 'id' | 'quantity'>
  & { stockTransferId: Stock_Transfer_Item['stock_transfer_id'], quantityReceived: Stock_Transfer_Item['quantity_received'] }
  & { inventoryItem: (
    Pick<Inventory_Item, 'id'>
    & { inventoryItemQuantities: Array<(
      Pick<Inventory_Item_Quantity, 'id' | 'incoming' | 'allocated'>
      & { onHand: Inventory_Item_Quantity['on_hand'] }
      & { location: (
        Pick<Location, 'id' | 'title'>
        & { isSkutopiaFc: Location['is_skutopia_fc'] }
      ) }
    )>, retailUnit: SearchProductsRetailUnitsFragment }
  ) }
);

export type AddressFragment = (
  Pick<Address, 'company' | 'name'>
  & { administrativeAreaLevel1: Address['administrative_area_level_1'], administrativeAreaLevel2: Address['administrative_area_level_2'], administrativeAreaLevel3: Address['administrative_area_level_3'], countryCode: Address['country_code'], line1: Address['line_1'], line2: Address['line_2'], postalCode: Address['postal_code'] }
);

export type StockTransferShipmentFragment = (
  Pick<Stock_Transfer_Shipment, 'id' | 'eta' | 'carrier'>
  & { stockTransferId: Stock_Transfer_Shipment['stock_transfer_id'], trackingNumber: Stock_Transfer_Shipment['tracking_number'], trackingUrl: Stock_Transfer_Shipment['tracking_url'], receivedAt: Stock_Transfer_Shipment['received_at'], shippedAt: Stock_Transfer_Shipment['shipped_at'] }
  & { location: { address?: Maybe<AddressFragment> } }
);

export type StockTransferFragment = (
  Pick<Stock_Transfer, 'id' | 'status' | 'notes'>
  & { labelPath: Stock_Transfer['label_path'], storeId: Stock_Transfer['store_id'], referenceNumber: Stock_Transfer['reference_number'], createdAt: Stock_Transfer['created_at'], updatedAt: Stock_Transfer['updated_at'], finalisedAt: Stock_Transfer['finalised_at'] }
  & { stockTransferItems: Array<StockTransferItemWithProductInfoFragment>, stockTransferShipments: Array<StockTransferShipmentFragment> }
);

export type SearchProductsRetailUnitsFragment = (
  Pick<Retail_Unit, 'id' | 'barcode' | 'name' | 'weight'>
  & { isDefault: Retail_Unit['is_default'], computedTitle: Retail_Unit['computed_title'] }
  & { productVariant: (
    Pick<Product_Variant, 'id' | 'sku' | 'title'>
    & { optionValues: Product_Variant['option_values'], imageUrl: Product_Variant['image_url'], weightGram: Product_Variant['weight_gram'] }
    & { product: (
      Pick<Product, 'id' | 'title'>
      & { imageUrl: Product['image_url'] }
    ) }
  ), inventoryItems: Array<(
    Pick<Inventory_Item, 'id'>
    & { inventoryItemQuantities: Array<(
      Pick<Inventory_Item_Quantity, 'id' | 'incoming' | 'allocated'>
      & { onHand: Inventory_Item_Quantity['on_hand'] }
      & { location: (
        Pick<Location, 'id' | 'title'>
        & { isSkutopiaFc: Location['is_skutopia_fc'] }
      ) }
    )> }
  )> }
);

export type SearchProductsQueryVariables = Exact<{
  search: Scalars['String'];
  storeId: Scalars['uuid'];
  maxProducts?: Maybe<Scalars['Int']>;
}>;


export type SearchProductsQuery = { search_retail_unit: Array<SearchProductsRetailUnitsFragment> };

export type GetIndividualStockTransferQueryVariables = Exact<{
  transferId?: Maybe<Scalars['bigint']>;
}>;


export type GetIndividualStockTransferQuery = { stockTransfers: Array<StockTransferFragment> };

export type OnStockTransferUpdateSubscriptionVariables = Exact<{
  stockTransferId: Scalars['bigint'];
}>;


export type OnStockTransferUpdateSubscription = { stockTransfers: Array<(
    Pick<Stock_Transfer, 'status'>
    & { labelPath: Stock_Transfer['label_path'] }
  )> };

export type UserWithStoresFragment = (
  Pick<Users, 'id'>
  & { firstName: Users['first_name'], lastName: Users['last_name'] }
  & { user_organizations: Array<{ organization: { stores: Array<Pick<Store, 'id' | 'name' | 'brand_logo_path'>> } }> }
);

export type UserFragment = (
  Pick<Users, 'id'>
  & { firstName: Users['first_name'], lastName: Users['last_name'], avatarUrl: Users['avatar_url'] }
  & { account?: Maybe<Pick<Auth_Accounts, 'email'>> }
);

export type UserWithOrgAndStoreIdsFragment = (
  { user_organizations: Array<{ organization: (
      Pick<Organization, 'id'>
      & { stores: Array<Pick<Store, 'id'>> }
    ) }> }
  & UserFragment
);

export type LocationFragment = (
  Pick<Location, 'id' | 'title' | 'integrations'>
  & { isDefault: Location['is_default'], isSkutopiaFc: Location['is_skutopia_fc'] }
  & { address?: Maybe<(
    Pick<Address, 'name' | 'locality' | 'company'>
    & { contactNumber: Address['contact_number'], line1: Address['line_1'], line2: Address['line_2'], administrativeAreaLevel1: Address['administrative_area_level_1'], administrativeAreaLevel2: Address['administrative_area_level_2'], administrativeAreaLevel3: Address['administrative_area_level_3'], countryCode: Address['country_code'], postalCode: Address['postal_code'] }
  )> }
);

export type StoreFragment = (
  Pick<Store, 'id' | 'name'>
  & { brandLogoPath: Store['brand_logo_path'], fbsEnabled: Store['fbs_enabled'], releaseChannel: Store['release_channel'] }
  & { slugs: Array<Pick<Store_Slug, 'slug' | 'primary'>>, locations: Array<LocationFragment>, organization: (
    Pick<Organization, 'id' | 'name'>
    & { ownerUserId: Organization['owner_user_id'] }
  ), storeFeatureFlags: Array<{ featureFlag: Store_Feature_Flag['feature_flag'] }>, carriers: Array<Pick<Carrier, 'name'>> }
);

export type GetInitialApplicationDataQueryVariables = Exact<{ [key: string]: never; }>;


export type GetInitialApplicationDataQuery = { users: Array<UserWithOrgAndStoreIdsFragment>, stores: Array<StoreFragment> };

export type GetInitialStoreDataQueryVariables = Exact<{
  storeId?: Maybe<Scalars['uuid']>;
  carrierWhitelist: Array<Scalars['String']> | Scalars['String'];
  labelBookedFrom: Scalars['timestamptz'];
  labelBookedTo?: Scalars['timestamptz'];
}>;


export type GetInitialStoreDataQuery = { fulfilmentShipmentsAggregate: { aggregate?: Maybe<Pick<Fulfilment_Shipment_Aggregate_Fields, 'count'>> } };

export type CarrierSettingCommandMutationVariables = Exact<{
  command: CarrierSettingCommand;
  storeId: Scalars['uuid'];
}>;


export type CarrierSettingCommandMutation = { carrierSettingCommand: Pick<CarrierSettingCommandOutput, 'outcome' | 'error' | 'storeId' | 'carrierId'> };

export type GetCarrierSettingsQueryVariables = Exact<{
  storeId: Scalars['uuid'];
}>;


export type GetCarrierSettingsQuery = { carrierSettings: Array<Pick<CarrierSettingOutput, 'carrierId' | 'carrierName' | 'provider' | 'storeId' | 'ATL_AUTHORITY_TO_LEAVE' | 'ATL_UNATTENDED_SAFETY' | 'ATL_SIGNATURE_REQUIRED' | 'ATL_AGE_VERIFICATION_REQUIRED'>> };

export type EditAddressMutationVariables = Exact<{
  fields: EditAddressInput;
  id: Scalars['uuid'];
  storeId: Scalars['uuid'];
}>;


export type EditAddressMutation = { editAddress?: Maybe<(
    Pick<EditAddressOutput, 'success' | 'errors'>
    & { address?: Maybe<(
      Pick<Address, 'id' | 'name' | 'locality' | 'company' | 'longitude' | 'latitude'>
      & { storeId: Address['store_id'], contactNumber: Address['contact_number'], line1: Address['line_1'], line2: Address['line_2'], administrativeAreaLevel1: Address['administrative_area_level_1'], administrativeAreaLevel2: Address['administrative_area_level_2'], administrativeAreaLevel3: Address['administrative_area_level_3'], countryCode: Address['country_code'], postalCode: Address['postal_code'] }
    )> }
  )> };

export type FulfilmentShipmentParcelFragment = (
  Pick<Fulfilment_Shipment_Parcel, 'id' | 'type'>
  & { widthMm: Fulfilment_Shipment_Parcel['width_mm'], heightMm: Fulfilment_Shipment_Parcel['height_mm'], lengthMm: Fulfilment_Shipment_Parcel['length_mm'], weightGram: Fulfilment_Shipment_Parcel['weight_gram'], emptyWeightGram: Fulfilment_Shipment_Parcel['empty_weight_gram'], parcelTypeId: Fulfilment_Shipment_Parcel['parcel_type_id'] }
  & { parcelType?: Maybe<CompleteParcelTypeFragment> }
);

export type FulfilmentShipmentLineItemFragment = (
  Pick<Fulfilment_Shipment_Line_Item, 'id' | 'sku' | 'name' | 'quantity' | 'barcode'>
  & { salesOrderLineItemId: Fulfilment_Shipment_Line_Item['sales_order_line_item_id'], fulfilmentShipmentId: Fulfilment_Shipment_Line_Item['fulfilment_shipment_id'] }
  & { salesOrderLineItem?: Maybe<SalesOrderLineItemFragment> }
);

export type FulfilmentShipmentFragment = (
  Pick<Fulfilment_Shipment, 'id' | 'error' | 'carrier' | 'status' | 'source'>
  & { totalCost: Fulfilment_Shipment['total_cost'], labelBookedAt: Fulfilment_Shipment['label_booked_at'], labelLastDownloadedAt: Fulfilment_Shipment['label_last_downloaded_at'], labelPaths: Fulfilment_Shipment['label_paths'], trackingNumber: Fulfilment_Shipment['tracking_number'], trackingUrl: Fulfilment_Shipment['tracking_url'], serviceType: Fulfilment_Shipment['service_type'], createdAt: Fulfilment_Shipment['created_at'], shippedAt: Fulfilment_Shipment['shipped_at'], manifestedAt: Fulfilment_Shipment['manifested_at'], deliveredAt: Fulfilment_Shipment['delivered_at'], estimatedDeliveryAt: Fulfilment_Shipment['estimated_delivery_at'], photoUploadPaths: Fulfilment_Shipment['photo_upload_paths'], signatureUploadPath: Fulfilment_Shipment['signature_upload_path'], selectedRateId: Fulfilment_Shipment['selected_rate_id'], atlSignatureRequired: Fulfilment_Shipment['atl_signature_required'], atlAgeVerificationRequired: Fulfilment_Shipment['atl_age_verification_required'], atlAuthorityToLeave: Fulfilment_Shipment['atl_authority_to_leave'], atlUnattendedSafety: Fulfilment_Shipment['atl_unattended_safety'], scheduledPickupDate: Fulfilment_Shipment['scheduled_pickup_date'], grossWeightGram: Fulfilment_Shipment['gross_weight_gram'] }
  & { fulfilmentShipmentParcels: Array<FulfilmentShipmentParcelFragment>, fulfilmentShipmentLineItems: Array<FulfilmentShipmentLineItemFragment>, selectedShippingRate?: Maybe<ShippingRateFragment>, rateRequest?: Maybe<RateRequestFragment>, shippingRates: Array<ShippingRateFragment>, location?: Maybe<(
    Pick<Location, 'title'>
    & { isSkutopiaFc: Location['is_skutopia_fc'] }
  )> }
);

export type FulfilmentShipmentSubscriptionFragment = (
  Pick<Fulfilment_Shipment, 'id' | 'carrier' | 'status' | 'updated_at'>
  & { totalCost: Fulfilment_Shipment['total_cost'], selectedRateId: Fulfilment_Shipment['selected_rate_id'], scheduledPickupDate: Fulfilment_Shipment['scheduled_pickup_date'], grossWeightGram: Fulfilment_Shipment['gross_weight_gram'] }
  & { selectedShippingRate?: Maybe<ShippingRateFragment>, rateRequest?: Maybe<RateRequestFragment> }
);

export type FulfilmentShipmentCommandMutationVariables = Exact<{
  command: FulfilmentShipmentCommand;
  storeId: Scalars['uuid'];
}>;


export type FulfilmentShipmentCommandMutation = { fulfilmentShipmentCommand?: Maybe<(
    Pick<FulfilmentShipmentCommandOutput, 'fulfilmentShipmentId' | 'outcome' | 'error'>
    & { draftFulfilmentShipment?: Maybe<(
      Pick<Draft_Fulfilment_Shipment, 'id'>
      & { selectedRateId: Draft_Fulfilment_Shipment['selected_rate_id'] }
      & { rateRequest?: Maybe<Pick<Rate_Request, 'errors'>>, shippingRates: Array<(
        Pick<Shipping_Rate, 'service' | 'id' | 'amount' | 'currency' | 'carrier' | 'integrations' | 'errors' | 'source'>
        & { serviceCode: Shipping_Rate['service_code'], externalEntityId: Shipping_Rate['external_entity_id'], deliveryDays: Shipping_Rate['delivery_days'] }
      )> }
    )> }
  )> };

export type GetFulfilmentAtlSettingsQueryVariables = Exact<{
  fulfilmentShipmentId: Scalars['uuid'];
}>;


export type GetFulfilmentAtlSettingsQuery = { fulfilmentShipment: Array<{ atlSignatureRequired: Draft_Fulfilment_Shipment['atl_signature_required'], atlAgeVerificationRequired: Draft_Fulfilment_Shipment['atl_age_verification_required'], atlAuthorityToLeave: Draft_Fulfilment_Shipment['atl_authority_to_leave'], atlUnattendedSafety: Draft_Fulfilment_Shipment['atl_unattended_safety'] }> };

export type OnInventorySyncJobUpdateSubscriptionVariables = Exact<{
  inventorySyncJobId: Scalars['bigint'];
}>;


export type OnInventorySyncJobUpdateSubscription = { inventorySyncJob: Array<(
    Pick<Inventory_Sync_Job, 'status' | 'completed_at'>
    & { productCount: Inventory_Sync_Job['product_count'], duplicatedBarcodeProducts: Inventory_Sync_Job['duplicated_barcode_products'], duplicatedSkuProducts: Inventory_Sync_Job['duplicated_sku_products'], missingBarcodeProducts: Inventory_Sync_Job['missing_barcode_products'], missingSkuProducts: Inventory_Sync_Job['missing_sku_products'] }
  )> };

export type UnmanifestedLabelFragment = (
  Pick<Fulfilment_Shipment, 'id' | 'carrier' | 'integrations'>
  & { createdAt: Fulfilment_Shipment['created_at'], manifestedAt: Fulfilment_Shipment['manifested_at'], labelBookedAt: Fulfilment_Shipment['label_booked_at'] }
  & { salesOrder: { orderReference: Sales_Order['order_reference'] } }
);

export type ManifestFragment = (
  Pick<Manifest, 'id' | 'integrations'>
  & { createdAt: Manifest['created_at'], updatedAt: Manifest['updated_at'], storeId: Manifest['store_id'], locationId: Manifest['location_id'], documentPaths: Manifest['document_paths'] }
  & { carrier?: Maybe<Pick<Carrier, 'id' | 'name'>> }
);

export type GetUnmanifestedLabelsQueryVariables = Exact<{
  offset?: Maybe<Scalars['Int']>;
  limit?: Maybe<Scalars['Int']>;
  storeId?: Maybe<Scalars['uuid']>;
  orderBy?: Maybe<Array<Fulfilment_Shipment_Order_By> | Fulfilment_Shipment_Order_By>;
  carrierWhitelist: Array<Scalars['String']> | Scalars['String'];
  from: Scalars['timestamptz'];
  to?: Scalars['timestamptz'];
}>;


export type GetUnmanifestedLabelsQuery = { fulfilmentShipments: Array<UnmanifestedLabelFragment>, fulfilmentShipmentsAggregate: { aggregate?: Maybe<Pick<Fulfilment_Shipment_Aggregate_Fields, 'count'>> } };

export type CreateManifestsMutationVariables = Exact<{
  storeId: Scalars['uuid'];
  fulfilmentShipmentIds: Array<Scalars['uuid']> | Scalars['uuid'];
}>;


export type CreateManifestsMutation = { create_manifest?: Maybe<Array<Maybe<{ manifest?: Maybe<ManifestFragment> }>>> };

export type GetManifestsForPeriodQueryVariables = Exact<{
  from: Scalars['timestamptz'];
  to?: Scalars['timestamptz'];
  storeId?: Maybe<Scalars['uuid']>;
  orderBy?: Maybe<Array<Manifest_Order_By> | Manifest_Order_By>;
}>;


export type GetManifestsForPeriodQuery = { manifests: Array<ManifestFragment> };

export type CompleteParcelTypeFragment = (
  Pick<Parcel_Type, 'id' | 'name' | 'width' | 'height' | 'length' | 'type'>
  & { createdAt: Parcel_Type['created_at'], updatedAt: Parcel_Type['updated_at'], deletedAt: Parcel_Type['deleted_at'], storeId: Parcel_Type['store_id'], isDefault: Parcel_Type['is_default'], isActive: Parcel_Type['is_active'], isPreset: Parcel_Type['is_preset'], maxWeight: Parcel_Type['max_weight'], minWeight: Parcel_Type['min_weight'], emptyWeight: Parcel_Type['empty_weight'] }
);

export type GetParcelTypesQueryVariables = Exact<{
  storeId?: Maybe<Scalars['uuid']>;
}>;


export type GetParcelTypesQuery = { parcelTypes: Array<CompleteParcelTypeFragment> };

export type AddParcelTypesMutationVariables = Exact<{
  parcelTypes: Array<AddParcelTypesInput> | AddParcelTypesInput;
}>;


export type AddParcelTypesMutation = { addedParcelTypes?: Maybe<Pick<AddParcelTypesOutput, 'count'>> };

export type EditParcelTypeByIdMutationVariables = Exact<{
  id: Scalars['uuid'];
  fields: EditParcelTypeInput;
}>;


export type EditParcelTypeByIdMutation = { parcelType?: Maybe<{ parcel_type?: Maybe<(
      Pick<Parcel_Type, 'id'>
      & { isActive: Parcel_Type['is_active'], isDefault: Parcel_Type['is_default'] }
    )> }> };

export type DeleteParcelTypesByIdsMutationVariables = Exact<{
  ids: Array<Scalars['uuid']> | Scalars['uuid'];
  storeId: Scalars['uuid'];
}>;


export type DeleteParcelTypesByIdsMutation = { deleteParcelTypesByIds?: Maybe<Pick<DeleteParcelTypesByIdsOutput, 'success' | 'errors'>> };

export type SyncSalesOrderMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type SyncSalesOrderMutation = { sync_sales_order?: Maybe<{ salesOrder?: Maybe<(
      { shippingAddress?: Maybe<(
        Pick<Address, 'id' | 'company' | 'locality' | 'name' | 'email'>
        & { storeId: Address['store_id'], line1: Address['line_1'], line2: Address['line_2'], countryCode: Address['country_code'], administrativeAreaLevel1: Address['administrative_area_level_1'], administrativeAreaLevel2: Address['administrative_area_level_2'], administrativeAreaLevel3: Address['administrative_area_level_3'], postalCode: Address['postal_code'], contactNumber: Address['contact_number'] }
      )>, customer?: Maybe<{ firstName: Customer['first_name'], lastName: Customer['last_name'] }> }
      & SalesOrderWithUncancelledShipmentFragment
    )> }> };

export type SalesOrderWithUncancelledShipmentFragment = (
  Pick<Sales_Order, 'id' | 'status' | 'note'>
  & { orderReference: Sales_Order['order_reference'], createdAt: Sales_Order['created_at'], storeId: Sales_Order['store_id'], totalWeightGram: Sales_Order['total_weight_gram'], lineItems: Sales_Order['line_items'] }
  & { fulfilmentShipments: Array<(
    Pick<Fulfilment_Shipment, 'id' | 'error' | 'carrier' | 'status' | 'source'>
    & { totalCost: Fulfilment_Shipment['total_cost'], labelPaths: Fulfilment_Shipment['label_paths'], trackingNumber: Fulfilment_Shipment['tracking_number'], trackingUrl: Fulfilment_Shipment['tracking_url'], serviceType: Fulfilment_Shipment['service_type'], createdAt: Fulfilment_Shipment['created_at'], manifestedAt: Fulfilment_Shipment['manifested_at'], deliveredAt: Fulfilment_Shipment['delivered_at'], estimatedDeliveryAt: Fulfilment_Shipment['estimated_delivery_at'], photoUploadPaths: Fulfilment_Shipment['photo_upload_paths'], signatureUploadPath: Fulfilment_Shipment['signature_upload_path'], selectedRateId: Fulfilment_Shipment['selected_rate_id'] }
    & { fulfilmentShipmentParcels: Array<SalesOrderFulfilmentShipmentParcelFragment>, rateRequest?: Maybe<{ shippingRates: Array<ShippingRateFragment> }>, location?: Maybe<(
      Pick<Location, 'title'>
      & { isSkutopiaFc: Location['is_skutopia_fc'] }
    )> }
  )>, shipmentCharges: Array<(
    Pick<Sales_Order_Shipment_Charge, 'id' | 'type' | 'name'>
    & { discountedPrice: Sales_Order_Shipment_Charge['discounted_price'] }
  )>, salesOrderLineItems: Array<(
    Pick<Sales_Order_Line_Item, 'id' | 'name' | 'sku' | 'quantity'>
    & { weightGram: Sales_Order_Line_Item['weight_gram'], quantityPacked: Sales_Order_Line_Item['quantity_packed'], quantityFulfillable: Sales_Order_Line_Item['quantity_fulfillable'], imageUrl: Sales_Order_Line_Item['image_url'] }
  )>, tags: Array<{ tag: Pick<Tag, 'id' | 'name'> }> }
  & SalesOrderDraftFulfilmentShipmentWithRatesFragment
);

export type SalesOrderFulfilmentShipmentParcelFragment = (
  Pick<Fulfilment_Shipment_Parcel, 'id' | 'type'>
  & { widthMm: Fulfilment_Shipment_Parcel['width_mm'], heightMm: Fulfilment_Shipment_Parcel['height_mm'], lengthMm: Fulfilment_Shipment_Parcel['length_mm'], weightGram: Fulfilment_Shipment_Parcel['weight_gram'], emptyWeightGram: Fulfilment_Shipment_Parcel['empty_weight_gram'], parcelTypeId: Fulfilment_Shipment_Parcel['parcel_type_id'] }
  & { parcelType?: Maybe<Pick<Parcel_Type, 'id' | 'name'>> }
);

export type DraftFulfilmentShipmentWithRatesFragment = (
  Pick<Draft_Fulfilment_Shipment, 'id'>
  & { selectedRateId: Draft_Fulfilment_Shipment['selected_rate_id'] }
  & { rateRequest?: Maybe<(
    Pick<Rate_Request, 'errors'>
    & { invalidatedAt: Rate_Request['invalidated_at'] }
  )>, shippingRates: Array<(
    Pick<Shipping_Rate, 'service' | 'id' | 'amount' | 'currency' | 'carrier' | 'integrations' | 'errors' | 'source'>
    & { serviceCode: Shipping_Rate['service_code'], externalEntityId: Shipping_Rate['external_entity_id'], deliveryDays: Shipping_Rate['delivery_days'] }
  )>, fulfilmentShipmentParcels: Array<SalesOrderFulfilmentShipmentParcelFragment> }
);

export type SalesOrderDraftFulfilmentShipmentWithRatesFragment = { draftFulfilmentShipment?: Maybe<DraftFulfilmentShipmentWithRatesFragment> };

export type RateRequestFragment = (
  Pick<Rate_Request, 'errors'>
  & { invalidatedAt: Rate_Request['invalidated_at'] }
  & { shippingRates: Array<(
    Pick<Shipping_Rate, 'service' | 'amount' | 'carrier' | 'id' | 'errors' | 'integrations' | 'source'>
    & { serviceCode: Shipping_Rate['service_code'], externalEntityId: Shipping_Rate['external_entity_id'] }
  )> }
);

export type SalesOrderWithUncancelledShipmentListingFragment = (
  Pick<Sales_Order, 'id' | 'status' | 'note'>
  & { orderReference: Sales_Order['order_reference'], createdAt: Sales_Order['created_at'], updatedAt: Sales_Order['updated_at'] }
  & { fulfilmentShipments: Array<(
    Pick<Fulfilment_Shipment, 'id' | 'carrier' | 'status' | 'source'>
    & { serviceType: Fulfilment_Shipment['service_type'], selectedRateId: Fulfilment_Shipment['selected_rate_id'], totalCost: Fulfilment_Shipment['total_cost'], labelPaths: Fulfilment_Shipment['label_paths'], manifestedAt: Fulfilment_Shipment['manifested_at'], scheduledPickupDate: Fulfilment_Shipment['scheduled_pickup_date'] }
    & { rateRequest?: Maybe<RateRequestFragment>, fulfilmentShipmentParcels: Array<SalesOrderFulfilmentShipmentParcelFragment> }
  )>, tags: Array<{ tag: Pick<Tag, 'id' | 'name'> }>, customer?: Maybe<{ firstName: Customer['first_name'], lastName: Customer['last_name'] }>, shippingAddress?: Maybe<{ countryCode: Address['country_code'], administrativeAreaLevel1: Address['administrative_area_level_1'] }>, shipmentCharges: Array<Pick<Sales_Order_Shipment_Charge, 'name'>> }
  & SalesOrderDraftFulfilmentShipmentWithRatesFragment
);

export type PackLineItemsMutationVariables = Exact<{
  lineItems: Array<PackLineItemsInput> | PackLineItemsInput;
  unpack?: Maybe<Scalars['Boolean']>;
}>;


export type PackLineItemsMutation = { pack_line_items?: Maybe<Pick<PackLineItemsOutput, 'success' | 'errors'>> };

export type GetTagsQueryVariables = Exact<{
  storeId?: Maybe<Uuid_Comparison_Exp>;
}>;


export type GetTagsQuery = { tags: Array<Pick<Tag, 'id' | 'name' | 'store_id'>> };

export type BulkActionFulfilmentShipmentFragment = (
  Pick<Fulfilment_Shipment, 'id' | 'status'>
  & { selectedRateId: Fulfilment_Shipment['selected_rate_id'] }
  & { rateRequest?: Maybe<RateRequestFragment> }
);

export type GetDetailsForBulkBookingQueryVariables = Exact<{
  ids?: Maybe<Array<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type GetDetailsForBulkBookingQuery = { salesOrders: Array<(
    Pick<Sales_Order, 'id'>
    & { fulfilmentShipments: Array<BulkActionFulfilmentShipmentFragment> }
  )> };

export type GetDetailsForBulkCancellingQueryVariables = Exact<{
  ids?: Maybe<Array<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type GetDetailsForBulkCancellingQuery = { salesOrders: Array<(
    Pick<Sales_Order, 'id'>
    & { fulfilmentShipments: Array<BulkActionFulfilmentShipmentFragment> }
  )> };

export type FulfilmentShipmentCountFragment = { aggregate?: Maybe<Pick<Fulfilment_Shipment_Aggregate_Fields, 'count'>> };

export type OnSalesOrderRatesUpdatedSubscriptionVariables = Exact<{
  salesOrderId: Scalars['uuid'];
}>;


export type OnSalesOrderRatesUpdatedSubscription = { salesOrder?: Maybe<(
    Pick<Sales_Order, 'id'>
    & SalesOrderDraftFulfilmentShipmentWithRatesFragment
  )> };

export type SalesOrderCommandMutationVariables = Exact<{
  command: SalesOrderCommand;
  storeId: Scalars['uuid'];
}>;


export type SalesOrderCommandMutation = { handleSalesOrderCommand?: Maybe<Pick<SalesOrderCommandOutput, 'outcome' | 'error' | 'salesOrderId'>> };

export type SalesOrderLineItemFragment = (
  Pick<Sales_Order_Line_Item, 'id' | 'name' | 'sku' | 'barcode' | 'quantity' | 'price'>
  & { weightGram: Sales_Order_Line_Item['weight_gram'], quantityPacked: Sales_Order_Line_Item['quantity_packed'], quantityFulfillable: Sales_Order_Line_Item['quantity_fulfillable'], imageUrl: Sales_Order_Line_Item['image_url'], priceCurrencyCode: Sales_Order_Line_Item['price_currency_code'], customsInfo: Sales_Order_Line_Item['customs_info'], parentLineItemId: Sales_Order_Line_Item['parent_line_item_id'], isDigital: Sales_Order_Line_Item['is_digital'] }
);

export type ShippingAddressFragment = (
  Pick<Address, 'id' | 'company' | 'locality' | 'name' | 'email'>
  & { storeId: Address['store_id'], line1: Address['line_1'], line2: Address['line_2'], countryCode: Address['country_code'], administrativeAreaLevel1: Address['administrative_area_level_1'], administrativeAreaLevel2: Address['administrative_area_level_2'], administrativeAreaLevel3: Address['administrative_area_level_3'], postalCode: Address['postal_code'], contactNumber: Address['contact_number'] }
);

export type SalesOrderShipmentChargeFragment = (
  Pick<Sales_Order_Shipment_Charge, 'id' | 'type' | 'name'>
  & { discountedPrice: Sales_Order_Shipment_Charge['discounted_price'] }
);

export type SalesOrderWithShipmentsFragment = (
  Pick<Sales_Order, 'id' | 'status' | 'note' | 'source'>
  & { orderReference: Sales_Order['order_reference'], createdAt: Sales_Order['created_at'], updatedAt: Sales_Order['updated_at'], storeId: Sales_Order['store_id'], totalWeightGrams: Sales_Order['total_weight_gram'] }
  & { fulfilmentShipments: Array<FulfilmentShipmentFragment>, shipmentCharges: Array<SalesOrderShipmentChargeFragment>, salesOrderLineItems: Array<SalesOrderLineItemFragment>, tags: Array<(
    Pick<Sales_Order_Tag, 'id'>
    & { tag: Pick<Tag, 'id' | 'name'> }
  )>, shippingAddress?: Maybe<ShippingAddressFragment>, customer?: Maybe<{ firstName: Customer['first_name'], lastName: Customer['last_name'] }> }
);

export type SalesOrderWithFulfilmentShipmentsSubscriptionFragment = (
  Pick<Sales_Order, 'id' | 'status'>
  & { createdAt: Sales_Order['created_at'], totalWeightGrams: Sales_Order['total_weight_gram'] }
  & { fulfilmentShipments: Array<FulfilmentShipmentSubscriptionFragment>, tags: Array<(
    Pick<Sales_Order_Tag, 'id'>
    & { tag: Pick<Tag, 'id' | 'name'> }
  )>, shippingAddress?: Maybe<ShippingAddressFragment> }
);

export type GetSalesOrderWithFulfilmentShipmentsQueryVariables = Exact<{
  salesOrderId: Scalars['uuid'];
}>;


export type GetSalesOrderWithFulfilmentShipmentsQuery = { salesOrder?: Maybe<SalesOrderWithShipmentsFragment> };

export type OnSalesOrderTrackingDataUpdatedSubscriptionVariables = Exact<{
  salesOrderId: Scalars['uuid'];
}>;


export type OnSalesOrderTrackingDataUpdatedSubscription = { salesOrder?: Maybe<{ fulfilmentShipments: Array<(
      Pick<Fulfilment_Shipment, 'id'>
      & { trackingNumber: Fulfilment_Shipment['tracking_number'], trackingUrl: Fulfilment_Shipment['tracking_url'] }
    )> }> };

export type OnSalesOrderUpdatedSubscriptionVariables = Exact<{
  salesOrderId: Scalars['uuid'];
}>;


export type OnSalesOrderUpdatedSubscription = { salesOrder?: Maybe<SalesOrderWithShipmentsFragment> };

export type GetSalesOrdersWithFulfilmentShipmentsQueryVariables = Exact<{
  where: Sales_Order_Bool_Exp;
  orderBy?: Maybe<Array<Sales_Order_Order_By> | Sales_Order_Order_By>;
  storeId: Scalars['uuid'];
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
}>;


export type GetSalesOrdersWithFulfilmentShipmentsQuery = { salesOrders: Array<SalesOrderWithShipmentsFragment>, salesOrdersAggregate: { aggregate?: Maybe<Pick<Sales_Order_Aggregate_Fields, 'count'>> } };

export type OnSalesOrdersWithFulfilmentShipmentsUpdatedSubscriptionVariables = Exact<{
  where: Sales_Order_Bool_Exp;
  orderBy?: Maybe<Array<Sales_Order_Order_By> | Sales_Order_Order_By>;
  storeId: Scalars['uuid'];
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
}>;


export type OnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription = { salesOrders: Array<SalesOrderWithFulfilmentShipmentsSubscriptionFragment> };

export type OnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscriptionVariables = Exact<{
  where: Sales_Order_Bool_Exp;
  storeId: Scalars['uuid'];
}>;


export type OnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription = { salesOrdersAggregate: { aggregate?: Maybe<Pick<Sales_Order_Aggregate_Fields, 'count'>> } };

export type SalesOrderTabCountsQueryVariables = Exact<{
  storeId: Scalars['uuid'];
}>;


export type SalesOrderTabCountsQuery = { open: FulfilmentShipmentCountFragment, processing: FulfilmentShipmentCountFragment, scheduled: FulfilmentShipmentCountFragment, awaitingCarrier: FulfilmentShipmentCountFragment, review: FulfilmentShipmentCountFragment };

export type OnSalesOrderTabCountsUpdatedSubscriptionVariables = Exact<{
  source?: Maybe<Scalars['String']>;
  storeId: Scalars['uuid'];
  status: Shipment_Status_Enum;
  scheduled_pickup_date?: Maybe<Scalars['Int']>;
}>;


export type OnSalesOrderTabCountsUpdatedSubscription = { open: FulfilmentShipmentCountFragment };

export type GetOrderDetailsForBulkBookingByIdsQueryVariables = Exact<{
  ids?: Maybe<Array<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type GetOrderDetailsForBulkBookingByIdsQuery = { salesOrders: Array<SalesOrderWithUncancelledShipmentListingFragment> };

export type GetOrderDetailsForBulkCancellingByIdsQueryVariables = Exact<{
  ids?: Maybe<Array<Scalars['uuid']> | Scalars['uuid']>;
  storeId?: Maybe<Scalars['uuid']>;
}>;


export type GetOrderDetailsForBulkCancellingByIdsQuery = { salesOrders: Array<SalesOrderWithUncancelledShipmentListingFragment> };

export type GetSalesOrdersByIdsQueryVariables = Exact<{
  ids?: Maybe<Array<Scalars['uuid']> | Scalars['uuid']>;
  storeId?: Maybe<Scalars['uuid']>;
}>;


export type GetSalesOrdersByIdsQuery = { salesOrders: Array<SalesOrderWithShipmentsFragment> };

export type OnSalesOrdersPackingSlipsReadySubscriptionVariables = Exact<{
  ids: Array<Scalars['uuid']> | Scalars['uuid'];
}>;


export type OnSalesOrdersPackingSlipsReadySubscription = { salesOrders: Array<(
    Pick<Sales_Order, 'id'>
    & { fulfilmentShipments: Array<(
      Pick<Fulfilment_Shipment, 'id'>
      & { packingSlipDocumentPath: Fulfilment_Shipment['packing_slip_document_path'] }
    )> }
  )> };

export type SalesOrdersCommandMutationVariables = Exact<{
  command: SalesOrdersCommand;
  storeId: Scalars['uuid'];
}>;


export type SalesOrdersCommandMutation = { handleSalesOrdersCommand?: Maybe<(
    Pick<SalesOrdersCommandOutput, 'outcome' | 'error' | 'url'>
    & { result?: Maybe<{ createdSalesOrders?: Maybe<Array<Maybe<Pick<CreatedSaleOrder, 'salesOrderId' | 'orderReference'>>>>, failedSalesOrders?: Maybe<Array<Maybe<Pick<FailedSaleOrder, 'reason' | 'orderReference' | 'salesOrderId'>>>> }> }
  )> };

export type ShopifyIntegrationFragment = (
  Pick<Shopify_Integration, 'id'>
  & { storeId: Shopify_Integration['store_id'], shopDomain: Shopify_Integration['shop_domain'], connectedAt: Shopify_Integration['connected_at'] }
);

export type GetIntegrationSettingsQueryVariables = Exact<{
  storeId?: Maybe<Scalars['uuid']>;
}>;


export type GetIntegrationSettingsQuery = { shopifyIntegrations: Array<ShopifyIntegrationFragment> };

export type GetCarrierSelectionPrefQueryVariables = Exact<{
  storeId?: Maybe<Scalars['uuid']>;
}>;


export type GetCarrierSelectionPrefQuery = { stores: Array<(
    Pick<Store, 'id'>
    & { carrierSelectionPref: Store['carrier_selection_pref'] }
  )> };

export type AddShopifyStoreMutationVariables = Exact<{
  storeId: Scalars['uuid'];
  shopDomain: Scalars['String'];
}>;


export type AddShopifyStoreMutation = { add_shopify_store?: Maybe<{ shopify_integration?: Maybe<ShopifyIntegrationFragment> }> };

export type RemoveShopifyIntegrationMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type RemoveShopifyIntegrationMutation = { update_shopify_integrations_by_pk?: Maybe<Pick<Shopify_Integration, 'id'>> };

export type SetAutomaticCarrierSelectionMutationVariables = Exact<{
  storeId: Scalars['uuid'];
  carrierSelectionPref: Scalars['String'];
}>;


export type SetAutomaticCarrierSelectionMutation = { editStore?: Maybe<Pick<EditStoreOutput, 'store_id' | 'success' | 'errors'>> };

export type InventorySyncJobFragment = (
  Pick<Inventory_Sync_Job, 'id' | 'status'>
  & { productCount: Inventory_Sync_Job['product_count'], duplicatedBarcodeProducts: Inventory_Sync_Job['duplicated_barcode_products'], duplicatedSkuProducts: Inventory_Sync_Job['duplicated_sku_products'], missingBarcodeProducts: Inventory_Sync_Job['missing_barcode_products'], missingSkuProducts: Inventory_Sync_Job['missing_sku_products'] }
);

export type GetLatestShopifyInventorySyncQueryVariables = Exact<{
  storeId: Scalars['uuid'];
  shopifyIntegrationId: Scalars['uuid'];
}>;


export type GetLatestShopifyInventorySyncQuery = { inventorySyncJobs: Array<InventorySyncJobFragment> };

export type InitiateShopifyInventorySyncMutationVariables = Exact<{
  storeId: Scalars['uuid'];
  shopifyIntegrationId: Scalars['uuid'];
}>;


export type InitiateShopifyInventorySyncMutation = { initiateShopifyInventorySync?: Maybe<Pick<InitiateShopifyInventorySyncOutput, 'inventorySyncJobId' | 'success' | 'error'>> };

export type ShippingRateFragment = (
  Pick<Shipping_Rate, 'id' | 'amount' | 'currency' | 'carrier' | 'integrations' | 'errors' | 'service' | 'source' | 'carrier_code'>
  & { externalEntityId: Shipping_Rate['external_entity_id'], serviceCode: Shipping_Rate['service_code'], deliveryDays: Shipping_Rate['delivery_days'] }
);

export type SelectShippingRateMutationVariables = Exact<{
  fulfilmentShipmentId: Scalars['uuid'];
  shippingRateId: Scalars['uuid'];
}>;


export type SelectShippingRateMutation = { select_shipping_rate?: Maybe<(
    Pick<SelectShippingRateOutput, 'success' | 'errors'>
    & { fulfilment_shipment?: Maybe<(
      Pick<Fulfilment_Shipment, 'id' | 'selected_rate_id'>
      & { selected_shipping_rate?: Maybe<ShippingRateFragment> }
    )> }
  )> };

export type GetStoreSettingsQueryVariables = Exact<{
  storeId?: Maybe<Scalars['uuid']>;
}>;


export type GetStoreSettingsQuery = { storeSettings: Array<Pick<Store_Setting, 'key' | 'value'>> };

export type ReplaceFulfilmentShipmentParcelsMutationVariables = Exact<{
  parcels: Array<FulfilmentShipmentParcelInput> | FulfilmentShipmentParcelInput;
}>;


export type ReplaceFulfilmentShipmentParcelsMutation = { replace_fulfilment_shipment_parcels?: Maybe<(
    Pick<UpsertFulfilmentShipmentParcelOutput, 'success' | 'errors'>
    & { fulfilment_shipment?: Maybe<(
      Pick<Fulfilment_Shipment, 'id'>
      & { fulfilmentShipmentParcels: Array<SalesOrderFulfilmentShipmentParcelFragment> }
    )> }
  )> };

export const SearchProductsRetailUnitsFragmentDoc = gql`
    fragment SearchProductsRetailUnits on retail_unit {
  id
  isDefault: is_default
  computedTitle: computed_title
  barcode
  name
  weight
  productVariant: product_variant {
    optionValues: option_values
    id
    sku
    title
    imageUrl: image_url
    weightGram: weight_gram
    product {
      id
      title
      imageUrl: image_url
    }
  }
  inventoryItems: inventory_items {
    id
    inventoryItemQuantities: inventory_item_quantities(
      where: {location: {is_skutopia_fc: {_eq: true}}}
    ) {
      id
      incoming
      onHand: on_hand
      allocated
      location {
        id
        title
        isSkutopiaFc: is_skutopia_fc
      }
    }
  }
}
    `;
export const StockTransferItemWithProductInfoFragmentDoc = gql`
    fragment StockTransferItemWithProductInfo on stock_transfer_item {
  id
  stockTransferId: stock_transfer_id
  quantity
  quantityReceived: quantity_received
  inventoryItem: inventory_item {
    id
    inventoryItemQuantities: inventory_item_quantities(
      where: {location: {is_skutopia_fc: {_eq: true}}}
    ) {
      id
      incoming
      onHand: on_hand
      allocated
      location {
        id
        title
        isSkutopiaFc: is_skutopia_fc
      }
    }
    retailUnit: retail_unit {
      ...SearchProductsRetailUnits
    }
  }
}
    ${SearchProductsRetailUnitsFragmentDoc}`;
export const AddressFragmentDoc = gql`
    fragment Address on address {
  administrativeAreaLevel1: administrative_area_level_1
  administrativeAreaLevel2: administrative_area_level_2
  administrativeAreaLevel3: administrative_area_level_3
  company
  countryCode: country_code
  line1: line_1
  line2: line_2
  name
  postalCode: postal_code
}
    `;
export const StockTransferShipmentFragmentDoc = gql`
    fragment StockTransferShipment on stock_transfer_shipment {
  id
  eta
  carrier
  stockTransferId: stock_transfer_id
  trackingNumber: tracking_number
  trackingUrl: tracking_url
  receivedAt: received_at
  shippedAt: shipped_at
  location {
    address {
      ...Address
    }
  }
}
    ${AddressFragmentDoc}`;
export const StockTransferFragmentDoc = gql`
    fragment StockTransfer on stock_transfer {
  id
  status
  notes
  labelPath: label_path
  storeId: store_id
  referenceNumber: reference_number
  createdAt: created_at
  updatedAt: updated_at
  finalisedAt: finalised_at
  stockTransferItems: transfer_items {
    ...StockTransferItemWithProductInfo
  }
  stockTransferShipments: transfer_shipments {
    ...StockTransferShipment
  }
}
    ${StockTransferItemWithProductInfoFragmentDoc}
${StockTransferShipmentFragmentDoc}`;
export const UserWithStoresFragmentDoc = gql`
    fragment UserWithStores on users {
  id
  firstName: first_name
  lastName: last_name
  user_organizations {
    organization {
      stores(order_by: {name: asc}) {
        id
        name
        brand_logo_path
      }
    }
  }
}
    `;
export const UserFragmentDoc = gql`
    fragment User on users {
  id
  firstName: first_name
  lastName: last_name
  avatarUrl: avatar_url
  account {
    email
  }
}
    `;
export const UserWithOrgAndStoreIdsFragmentDoc = gql`
    fragment UserWithOrgAndStoreIds on users {
  ...User
  user_organizations {
    organization {
      id
      stores {
        id
      }
    }
  }
}
    ${UserFragmentDoc}`;
export const LocationFragmentDoc = gql`
    fragment Location on location {
  id
  title
  isDefault: is_default
  isSkutopiaFc: is_skutopia_fc
  address {
    name
    contactNumber: contact_number
    line1: line_1
    line2: line_2
    locality
    administrativeAreaLevel1: administrative_area_level_1
    administrativeAreaLevel2: administrative_area_level_2
    administrativeAreaLevel3: administrative_area_level_3
    countryCode: country_code
    postalCode: postal_code
    company
  }
  integrations
}
    `;
export const StoreFragmentDoc = gql`
    fragment Store on store {
  id
  name
  brandLogoPath: brand_logo_path
  slugs {
    slug
    primary
  }
  locations {
    ...Location
  }
  organization {
    id
    name
    ownerUserId: owner_user_id
  }
  storeFeatureFlags: store_feature_flags {
    featureFlag: feature_flag
  }
  fbsEnabled: fbs_enabled
  releaseChannel: release_channel
  carriers {
    name
  }
}
    ${LocationFragmentDoc}`;
export const UnmanifestedLabelFragmentDoc = gql`
    fragment UnmanifestedLabel on fulfilment_shipment {
  id
  createdAt: created_at
  manifestedAt: manifested_at
  labelBookedAt: label_booked_at
  carrier
  integrations
  salesOrder: sales_order {
    orderReference: order_reference
  }
}
    `;
export const ManifestFragmentDoc = gql`
    fragment Manifest on manifest {
  id
  createdAt: created_at
  updatedAt: updated_at
  storeId: store_id
  carrier {
    id
    name
  }
  locationId: location_id
  integrations
  documentPaths: document_paths
}
    `;
export const SalesOrderFulfilmentShipmentParcelFragmentDoc = gql`
    fragment SalesOrderFulfilmentShipmentParcel on fulfilment_shipment_parcel {
  id
  type
  widthMm: width_mm
  heightMm: height_mm
  lengthMm: length_mm
  weightGram: weight_gram
  emptyWeightGram: empty_weight_gram
  parcelTypeId: parcel_type_id
  parcelType: parcel_type {
    id
    name
  }
}
    `;
export const DraftFulfilmentShipmentWithRatesFragmentDoc = gql`
    fragment DraftFulfilmentShipmentWithRates on draft_fulfilment_shipment {
  id
  selectedRateId: selected_rate_id
  rateRequest: rate_request {
    invalidatedAt: invalidated_at
    errors
  }
  shippingRates: shipping_rates {
    serviceCode: service_code
    service
    id
    externalEntityId: external_entity_id
    amount
    currency
    carrier
    integrations
    errors
    deliveryDays: delivery_days
    integrations
    source
  }
  fulfilmentShipmentParcels: fulfilment_shipment_parcels(
    order_by: {created_at: asc}
  ) {
    ...SalesOrderFulfilmentShipmentParcel
  }
}
    ${SalesOrderFulfilmentShipmentParcelFragmentDoc}`;
export const SalesOrderDraftFulfilmentShipmentWithRatesFragmentDoc = gql`
    fragment SalesOrderDraftFulfilmentShipmentWithRates on sales_order {
  draftFulfilmentShipment: draft_fulfilment_shipment {
    ...DraftFulfilmentShipmentWithRates
  }
}
    ${DraftFulfilmentShipmentWithRatesFragmentDoc}`;
export const ShippingRateFragmentDoc = gql`
    fragment ShippingRate on shipping_rate {
  id
  externalEntityId: external_entity_id
  amount
  currency
  carrier
  integrations
  errors
  serviceCode: service_code
  service
  deliveryDays: delivery_days
  integrations
  source
  carrier_code
}
    `;
export const SalesOrderWithUncancelledShipmentFragmentDoc = gql`
    fragment SalesOrderWithUncancelledShipment on sales_order {
  id
  orderReference: order_reference
  createdAt: created_at
  storeId: store_id
  status
  note
  ...SalesOrderDraftFulfilmentShipmentWithRates
  fulfilmentShipments: fulfilment_shipments(where: {status: {_neq: CANCELLED}}) {
    id
    error
    carrier
    totalCost: total_cost
    status
    labelPaths: label_paths
    fulfilmentShipmentParcels: fulfilment_shipment_parcels {
      ...SalesOrderFulfilmentShipmentParcel
    }
    trackingNumber: tracking_number
    trackingUrl: tracking_url
    serviceType: service_type
    createdAt: created_at
    manifestedAt: manifested_at
    deliveredAt: delivered_at
    estimatedDeliveryAt: estimated_delivery_at
    photoUploadPaths: photo_upload_paths
    signatureUploadPath: signature_upload_path
    selectedRateId: selected_rate_id
    rateRequest: rate_request {
      shippingRates: shipping_rates {
        ...ShippingRate
      }
    }
    source
    location {
      isSkutopiaFc: is_skutopia_fc
      title
    }
  }
  shipmentCharges: sales_order_shipment_charges {
    id
    discountedPrice: discounted_price
    type
    name
  }
  totalWeightGram: total_weight_gram
  lineItems: line_items
  salesOrderLineItems: sales_order_line_items {
    id
    name
    sku
    weightGram: weight_gram
    quantityPacked: quantity_packed
    quantityFulfillable: quantity_fulfillable
    quantity
    imageUrl: image_url
  }
  tags: sales_order_tags {
    tag {
      id
      name
    }
  }
}
    ${SalesOrderDraftFulfilmentShipmentWithRatesFragmentDoc}
${SalesOrderFulfilmentShipmentParcelFragmentDoc}
${ShippingRateFragmentDoc}`;
export const RateRequestFragmentDoc = gql`
    fragment RateRequest on rate_request {
  invalidatedAt: invalidated_at
  errors
  shippingRates: shipping_rates {
    serviceCode: service_code
    service
    amount
    carrier
    id
    errors
    integrations
    source
    externalEntityId: external_entity_id
  }
}
    `;
export const SalesOrderWithUncancelledShipmentListingFragmentDoc = gql`
    fragment SalesOrderWithUncancelledShipmentListing on sales_order {
  id
  status
  note
  orderReference: order_reference
  createdAt: created_at
  updatedAt: updated_at
  ...SalesOrderDraftFulfilmentShipmentWithRates
  fulfilmentShipments: fulfilment_shipments(where: {status: {_neq: CANCELLED}}) {
    id
    carrier
    serviceType: service_type
    status
    selectedRateId: selected_rate_id
    rateRequest: rate_request {
      ...RateRequest
    }
    fulfilmentShipmentParcels: fulfilment_shipment_parcels {
      ...SalesOrderFulfilmentShipmentParcel
    }
    totalCost: total_cost
    labelPaths: label_paths
    manifestedAt: manifested_at
    scheduledPickupDate: scheduled_pickup_date
    source
  }
  tags: sales_order_tags {
    tag {
      id
      name
    }
  }
  customer {
    firstName: first_name
    lastName: last_name
  }
  shippingAddress: shipping_address {
    countryCode: country_code
    administrativeAreaLevel1: administrative_area_level_1
  }
  shipmentCharges: sales_order_shipment_charges {
    name
  }
}
    ${SalesOrderDraftFulfilmentShipmentWithRatesFragmentDoc}
${RateRequestFragmentDoc}
${SalesOrderFulfilmentShipmentParcelFragmentDoc}`;
export const BulkActionFulfilmentShipmentFragmentDoc = gql`
    fragment BulkActionFulfilmentShipment on fulfilment_shipment {
  id
  status
  selectedRateId: selected_rate_id
  rateRequest: rate_request {
    ...RateRequest
  }
}
    ${RateRequestFragmentDoc}`;
export const FulfilmentShipmentCountFragmentDoc = gql`
    fragment FulfilmentShipmentCount on fulfilment_shipment_aggregate {
  aggregate {
    count(columns: status)
  }
}
    `;
export const CompleteParcelTypeFragmentDoc = gql`
    fragment CompleteParcelType on parcel_type {
  id
  createdAt: created_at
  updatedAt: updated_at
  deletedAt: deleted_at
  storeId: store_id
  name
  width
  height
  length
  isDefault: is_default
  isActive: is_active
  isPreset: is_preset
  type
  maxWeight: max_weight
  minWeight: min_weight
  emptyWeight: empty_weight
}
    `;
export const FulfilmentShipmentParcelFragmentDoc = gql`
    fragment FulfilmentShipmentParcel on fulfilment_shipment_parcel {
  id
  widthMm: width_mm
  heightMm: height_mm
  lengthMm: length_mm
  weightGram: weight_gram
  emptyWeightGram: empty_weight_gram
  parcelTypeId: parcel_type_id
  type
  parcelType: parcel_type {
    ...CompleteParcelType
  }
}
    ${CompleteParcelTypeFragmentDoc}`;
export const SalesOrderLineItemFragmentDoc = gql`
    fragment SalesOrderLineItem on sales_order_line_item {
  id
  name
  sku
  barcode
  weightGram: weight_gram
  quantityPacked: quantity_packed
  quantityFulfillable: quantity_fulfillable
  quantity
  imageUrl: image_url
  price
  priceCurrencyCode: price_currency_code
  customsInfo: customs_info
  parentLineItemId: parent_line_item_id
  isDigital: is_digital
}
    `;
export const FulfilmentShipmentLineItemFragmentDoc = gql`
    fragment FulfilmentShipmentLineItem on fulfilment_shipment_line_item {
  id
  salesOrderLineItemId: sales_order_line_item_id
  fulfilmentShipmentId: fulfilment_shipment_id
  sku
  name
  quantity
  barcode
  salesOrderLineItem: sales_order_line_item {
    ...SalesOrderLineItem
  }
}
    ${SalesOrderLineItemFragmentDoc}`;
export const FulfilmentShipmentFragmentDoc = gql`
    fragment FulfilmentShipment on fulfilment_shipment {
  id
  error
  carrier
  totalCost: total_cost
  status
  labelBookedAt: label_booked_at
  labelLastDownloadedAt: label_last_downloaded_at
  labelPaths: label_paths
  fulfilmentShipmentParcels: fulfilment_shipment_parcels(
    order_by: {created_at: asc}
  ) {
    ...FulfilmentShipmentParcel
  }
  fulfilmentShipmentLineItems: fulfilment_shipment_line_items {
    ...FulfilmentShipmentLineItem
  }
  trackingNumber: tracking_number
  trackingUrl: tracking_url
  serviceType: service_type
  createdAt: created_at
  shippedAt: shipped_at
  manifestedAt: manifested_at
  deliveredAt: delivered_at
  estimatedDeliveryAt: estimated_delivery_at
  photoUploadPaths: photo_upload_paths
  signatureUploadPath: signature_upload_path
  selectedRateId: selected_rate_id
  selectedShippingRate: selected_shipping_rate {
    ...ShippingRate
  }
  rateRequest: rate_request {
    ...RateRequest
  }
  shippingRates: shipping_rates {
    ...ShippingRate
  }
  source
  location {
    isSkutopiaFc: is_skutopia_fc
    title
  }
  atlSignatureRequired: atl_signature_required
  atlAgeVerificationRequired: atl_age_verification_required
  atlAuthorityToLeave: atl_authority_to_leave
  atlUnattendedSafety: atl_unattended_safety
  scheduledPickupDate: scheduled_pickup_date
  grossWeightGram: gross_weight_gram
}
    ${FulfilmentShipmentParcelFragmentDoc}
${FulfilmentShipmentLineItemFragmentDoc}
${ShippingRateFragmentDoc}
${RateRequestFragmentDoc}`;
export const SalesOrderShipmentChargeFragmentDoc = gql`
    fragment SalesOrderShipmentCharge on sales_order_shipment_charge {
  id
  discountedPrice: discounted_price
  type
  name
}
    `;
export const ShippingAddressFragmentDoc = gql`
    fragment ShippingAddress on address {
  id
  storeId: store_id
  line1: line_1
  line2: line_2
  company
  countryCode: country_code
  administrativeAreaLevel1: administrative_area_level_1
  administrativeAreaLevel2: administrative_area_level_2
  administrativeAreaLevel3: administrative_area_level_3
  locality
  postalCode: postal_code
  name
  contactNumber: contact_number
  email
}
    `;
export const SalesOrderWithShipmentsFragmentDoc = gql`
    fragment SalesOrderWithShipments on sales_order {
  id
  orderReference: order_reference
  createdAt: created_at
  updatedAt: updated_at
  storeId: store_id
  status
  note
  source
  fulfilmentShipments: fulfilment_shipments(where: {status: {_neq: CANCELLED}}) {
    ...FulfilmentShipment
  }
  shipmentCharges: sales_order_shipment_charges {
    ...SalesOrderShipmentCharge
  }
  totalWeightGrams: total_weight_gram
  salesOrderLineItems: sales_order_line_items {
    ...SalesOrderLineItem
  }
  tags: sales_order_tags {
    id
    tag {
      id
      name
    }
  }
  shippingAddress: shipping_address {
    ...ShippingAddress
  }
  customer {
    firstName: first_name
    lastName: last_name
  }
}
    ${FulfilmentShipmentFragmentDoc}
${SalesOrderShipmentChargeFragmentDoc}
${SalesOrderLineItemFragmentDoc}
${ShippingAddressFragmentDoc}`;
export const FulfilmentShipmentSubscriptionFragmentDoc = gql`
    fragment FulfilmentShipmentSubscription on fulfilment_shipment {
  id
  carrier
  totalCost: total_cost
  status
  selectedRateId: selected_rate_id
  selectedShippingRate: selected_shipping_rate {
    ...ShippingRate
  }
  rateRequest: rate_request {
    ...RateRequest
  }
  scheduledPickupDate: scheduled_pickup_date
  grossWeightGram: gross_weight_gram
  updated_at
}
    ${ShippingRateFragmentDoc}
${RateRequestFragmentDoc}`;
export const SalesOrderWithFulfilmentShipmentsSubscriptionFragmentDoc = gql`
    fragment SalesOrderWithFulfilmentShipmentsSubscription on sales_order {
  id
  createdAt: created_at
  status
  fulfilmentShipments: fulfilment_shipments(where: {status: {_neq: CANCELLED}}) {
    ...FulfilmentShipmentSubscription
  }
  totalWeightGrams: total_weight_gram
  tags: sales_order_tags {
    id
    tag {
      id
      name
    }
  }
  shippingAddress: shipping_address {
    ...ShippingAddress
  }
}
    ${FulfilmentShipmentSubscriptionFragmentDoc}
${ShippingAddressFragmentDoc}`;
export const ShopifyIntegrationFragmentDoc = gql`
    fragment ShopifyIntegration on shopify_integration {
  id
  storeId: store_id
  shopDomain: shop_domain
  connectedAt: connected_at
}
    `;
export const InventorySyncJobFragmentDoc = gql`
    fragment InventorySyncJob on inventory_sync_job {
  id
  productCount: product_count
  status
  duplicatedBarcodeProducts: duplicated_barcode_products
  duplicatedSkuProducts: duplicated_sku_products
  missingBarcodeProducts: missing_barcode_products
  missingSkuProducts: missing_sku_products
}
    `;
export const StockTransferCommandDocument = gql`
    mutation StockTransferCommand($command: StockTransferCommand!, $storeId: uuid!) {
  handleStockTransferCommand: command_stock_transfer(
    command: $command
    storeId: $storeId
  ) {
    stockTransferId
    outcome
    stockTransfer {
      id
    }
  }
}
    `;
export type StockTransferCommandMutationFn = Apollo.MutationFunction<StockTransferCommandMutation, StockTransferCommandMutationVariables>;

/**
 * __useStockTransferCommandMutation__
 *
 * To run a mutation, you first call `useStockTransferCommandMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStockTransferCommandMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [stockTransferCommandMutation, { data, loading, error }] = useStockTransferCommandMutation({
 *   variables: {
 *      command: // value for 'command'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useStockTransferCommandMutation(baseOptions?: Apollo.MutationHookOptions<StockTransferCommandMutation, StockTransferCommandMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StockTransferCommandMutation, StockTransferCommandMutationVariables>(StockTransferCommandDocument, options);
      }
export type StockTransferCommandMutationHookResult = ReturnType<typeof useStockTransferCommandMutation>;
export type StockTransferCommandMutationResult = Apollo.MutationResult<StockTransferCommandMutation>;
export type StockTransferCommandMutationOptions = Apollo.BaseMutationOptions<StockTransferCommandMutation, StockTransferCommandMutationVariables>;
export const GetStockTransfersDocument = gql`
    query GetStockTransfers($storeId: uuid!, $offset: Int = 0, $limit: Int = 10) {
  stockTransfers: stock_transfers(
    order_by: {updated_at: desc_nulls_last}
    where: {store_id: {_eq: $storeId}}
    offset: $offset
    limit: $limit
  ) {
    id
    status
    notes
    referenceNumber: reference_number
    updatedAt: updated_at
    transferItems: transfer_items {
      quantity
      quantityReceived: quantity_received
    }
    transferShipments: transfer_shipments {
      eta
      updatedAt: updated_at
      receivedAt: received_at
      trackingNumber: tracking_number
      trackingUrl: tracking_url
      shippedAt: shipped_at
    }
  }
  stockTransfersAggregate: stock_transfers_aggregate(
    where: {store_id: {_eq: $storeId}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetStockTransfersQuery__
 *
 * To run a query within a React component, call `useGetStockTransfersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStockTransfersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStockTransfersQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      offset: // value for 'offset'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetStockTransfersQuery(baseOptions: Apollo.QueryHookOptions<GetStockTransfersQuery, GetStockTransfersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStockTransfersQuery, GetStockTransfersQueryVariables>(GetStockTransfersDocument, options);
      }
export function useGetStockTransfersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStockTransfersQuery, GetStockTransfersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStockTransfersQuery, GetStockTransfersQueryVariables>(GetStockTransfersDocument, options);
        }
export type GetStockTransfersQueryHookResult = ReturnType<typeof useGetStockTransfersQuery>;
export type GetStockTransfersLazyQueryHookResult = ReturnType<typeof useGetStockTransfersLazyQuery>;
export type GetStockTransfersQueryResult = Apollo.QueryResult<GetStockTransfersQuery, GetStockTransfersQueryVariables>;
export const SearchProductsDocument = gql`
    query SearchProducts($search: String!, $storeId: uuid!, $maxProducts: Int) {
  search_retail_unit(
    args: {search_term: $search, storeid: $storeId, max_retail_units: $maxProducts}
    where: {_and: [{weight: {_is_null: false, _gt: 0}}, {barcode: {_is_null: false, _neq: ""}}, {product_variant: {sku: {_is_null: false, _neq: ""}}}]}
  ) {
    ...SearchProductsRetailUnits
  }
}
    ${SearchProductsRetailUnitsFragmentDoc}`;

/**
 * __useSearchProductsQuery__
 *
 * To run a query within a React component, call `useSearchProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchProductsQuery({
 *   variables: {
 *      search: // value for 'search'
 *      storeId: // value for 'storeId'
 *      maxProducts: // value for 'maxProducts'
 *   },
 * });
 */
export function useSearchProductsQuery(baseOptions: Apollo.QueryHookOptions<SearchProductsQuery, SearchProductsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchProductsQuery, SearchProductsQueryVariables>(SearchProductsDocument, options);
      }
export function useSearchProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchProductsQuery, SearchProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchProductsQuery, SearchProductsQueryVariables>(SearchProductsDocument, options);
        }
export type SearchProductsQueryHookResult = ReturnType<typeof useSearchProductsQuery>;
export type SearchProductsLazyQueryHookResult = ReturnType<typeof useSearchProductsLazyQuery>;
export type SearchProductsQueryResult = Apollo.QueryResult<SearchProductsQuery, SearchProductsQueryVariables>;
export const GetIndividualStockTransferDocument = gql`
    query GetIndividualStockTransfer($transferId: bigint) {
  stockTransfers: stock_transfers(where: {id: {_eq: $transferId}}) {
    ...StockTransfer
  }
}
    ${StockTransferFragmentDoc}`;

/**
 * __useGetIndividualStockTransferQuery__
 *
 * To run a query within a React component, call `useGetIndividualStockTransferQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetIndividualStockTransferQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetIndividualStockTransferQuery({
 *   variables: {
 *      transferId: // value for 'transferId'
 *   },
 * });
 */
export function useGetIndividualStockTransferQuery(baseOptions?: Apollo.QueryHookOptions<GetIndividualStockTransferQuery, GetIndividualStockTransferQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetIndividualStockTransferQuery, GetIndividualStockTransferQueryVariables>(GetIndividualStockTransferDocument, options);
      }
export function useGetIndividualStockTransferLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetIndividualStockTransferQuery, GetIndividualStockTransferQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetIndividualStockTransferQuery, GetIndividualStockTransferQueryVariables>(GetIndividualStockTransferDocument, options);
        }
export type GetIndividualStockTransferQueryHookResult = ReturnType<typeof useGetIndividualStockTransferQuery>;
export type GetIndividualStockTransferLazyQueryHookResult = ReturnType<typeof useGetIndividualStockTransferLazyQuery>;
export type GetIndividualStockTransferQueryResult = Apollo.QueryResult<GetIndividualStockTransferQuery, GetIndividualStockTransferQueryVariables>;
export const OnStockTransferUpdateDocument = gql`
    subscription OnStockTransferUpdate($stockTransferId: bigint!) {
  stockTransfers: stock_transfers(where: {id: {_eq: $stockTransferId}}) {
    labelPath: label_path
    status
  }
}
    `;

/**
 * __useOnStockTransferUpdateSubscription__
 *
 * To run a query within a React component, call `useOnStockTransferUpdateSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnStockTransferUpdateSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnStockTransferUpdateSubscription({
 *   variables: {
 *      stockTransferId: // value for 'stockTransferId'
 *   },
 * });
 */
export function useOnStockTransferUpdateSubscription(baseOptions: Apollo.SubscriptionHookOptions<OnStockTransferUpdateSubscription, OnStockTransferUpdateSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnStockTransferUpdateSubscription, OnStockTransferUpdateSubscriptionVariables>(OnStockTransferUpdateDocument, options);
      }
export type OnStockTransferUpdateSubscriptionHookResult = ReturnType<typeof useOnStockTransferUpdateSubscription>;
export type OnStockTransferUpdateSubscriptionResult = Apollo.SubscriptionResult<OnStockTransferUpdateSubscription>;
export const GetInitialApplicationDataDocument = gql`
    query GetInitialApplicationData {
  users {
    ...UserWithOrgAndStoreIds
  }
  stores(order_by: {name: asc}) {
    ...Store
  }
}
    ${UserWithOrgAndStoreIdsFragmentDoc}
${StoreFragmentDoc}`;

/**
 * __useGetInitialApplicationDataQuery__
 *
 * To run a query within a React component, call `useGetInitialApplicationDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInitialApplicationDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInitialApplicationDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetInitialApplicationDataQuery(baseOptions?: Apollo.QueryHookOptions<GetInitialApplicationDataQuery, GetInitialApplicationDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInitialApplicationDataQuery, GetInitialApplicationDataQueryVariables>(GetInitialApplicationDataDocument, options);
      }
export function useGetInitialApplicationDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInitialApplicationDataQuery, GetInitialApplicationDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInitialApplicationDataQuery, GetInitialApplicationDataQueryVariables>(GetInitialApplicationDataDocument, options);
        }
export type GetInitialApplicationDataQueryHookResult = ReturnType<typeof useGetInitialApplicationDataQuery>;
export type GetInitialApplicationDataLazyQueryHookResult = ReturnType<typeof useGetInitialApplicationDataLazyQuery>;
export type GetInitialApplicationDataQueryResult = Apollo.QueryResult<GetInitialApplicationDataQuery, GetInitialApplicationDataQueryVariables>;
export const GetInitialStoreDataDocument = gql`
    query GetInitialStoreData($storeId: uuid, $carrierWhitelist: [String!]!, $labelBookedFrom: timestamptz!, $labelBookedTo: timestamptz! = "now()") {
  fulfilmentShipmentsAggregate: fulfilment_shipments_aggregate(
    where: {integrations: {_has_key: "ship_engine"}, store_id: {_eq: $storeId}, status: {_nin: [CANCELLED, PROCESSING_AT_SKUTOPIA]}, manifested_at: {_is_null: true}, carrier: {_in: $carrierWhitelist}, _or: [{location_id: {_is_null: true}}, {location: {is_skutopia_fc: {_eq: false}}}], label_booked_at: {_gte: $labelBookedFrom, _lte: $labelBookedTo}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetInitialStoreDataQuery__
 *
 * To run a query within a React component, call `useGetInitialStoreDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInitialStoreDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInitialStoreDataQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      carrierWhitelist: // value for 'carrierWhitelist'
 *      labelBookedFrom: // value for 'labelBookedFrom'
 *      labelBookedTo: // value for 'labelBookedTo'
 *   },
 * });
 */
export function useGetInitialStoreDataQuery(baseOptions: Apollo.QueryHookOptions<GetInitialStoreDataQuery, GetInitialStoreDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInitialStoreDataQuery, GetInitialStoreDataQueryVariables>(GetInitialStoreDataDocument, options);
      }
export function useGetInitialStoreDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInitialStoreDataQuery, GetInitialStoreDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInitialStoreDataQuery, GetInitialStoreDataQueryVariables>(GetInitialStoreDataDocument, options);
        }
export type GetInitialStoreDataQueryHookResult = ReturnType<typeof useGetInitialStoreDataQuery>;
export type GetInitialStoreDataLazyQueryHookResult = ReturnType<typeof useGetInitialStoreDataLazyQuery>;
export type GetInitialStoreDataQueryResult = Apollo.QueryResult<GetInitialStoreDataQuery, GetInitialStoreDataQueryVariables>;
export const CarrierSettingCommandDocument = gql`
    mutation CarrierSettingCommand($command: CarrierSettingCommand!, $storeId: uuid!) {
  carrierSettingCommand: command_carrier_setting(
    command: $command
    storeId: $storeId
  ) {
    outcome
    error
    storeId
    carrierId
  }
}
    `;
export type CarrierSettingCommandMutationFn = Apollo.MutationFunction<CarrierSettingCommandMutation, CarrierSettingCommandMutationVariables>;

/**
 * __useCarrierSettingCommandMutation__
 *
 * To run a mutation, you first call `useCarrierSettingCommandMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCarrierSettingCommandMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [carrierSettingCommandMutation, { data, loading, error }] = useCarrierSettingCommandMutation({
 *   variables: {
 *      command: // value for 'command'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useCarrierSettingCommandMutation(baseOptions?: Apollo.MutationHookOptions<CarrierSettingCommandMutation, CarrierSettingCommandMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CarrierSettingCommandMutation, CarrierSettingCommandMutationVariables>(CarrierSettingCommandDocument, options);
      }
export type CarrierSettingCommandMutationHookResult = ReturnType<typeof useCarrierSettingCommandMutation>;
export type CarrierSettingCommandMutationResult = Apollo.MutationResult<CarrierSettingCommandMutation>;
export type CarrierSettingCommandMutationOptions = Apollo.BaseMutationOptions<CarrierSettingCommandMutation, CarrierSettingCommandMutationVariables>;
export const GetCarrierSettingsDocument = gql`
    query GetCarrierSettings($storeId: uuid!) {
  carrierSettings: get_carrier_settings(storeId: $storeId) {
    carrierId
    carrierName
    provider
    storeId
    ATL_AUTHORITY_TO_LEAVE
    ATL_UNATTENDED_SAFETY
    ATL_SIGNATURE_REQUIRED
    ATL_AGE_VERIFICATION_REQUIRED
  }
}
    `;

/**
 * __useGetCarrierSettingsQuery__
 *
 * To run a query within a React component, call `useGetCarrierSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCarrierSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCarrierSettingsQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useGetCarrierSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetCarrierSettingsQuery, GetCarrierSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCarrierSettingsQuery, GetCarrierSettingsQueryVariables>(GetCarrierSettingsDocument, options);
      }
export function useGetCarrierSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCarrierSettingsQuery, GetCarrierSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCarrierSettingsQuery, GetCarrierSettingsQueryVariables>(GetCarrierSettingsDocument, options);
        }
export type GetCarrierSettingsQueryHookResult = ReturnType<typeof useGetCarrierSettingsQuery>;
export type GetCarrierSettingsLazyQueryHookResult = ReturnType<typeof useGetCarrierSettingsLazyQuery>;
export type GetCarrierSettingsQueryResult = Apollo.QueryResult<GetCarrierSettingsQuery, GetCarrierSettingsQueryVariables>;
export const EditAddressDocument = gql`
    mutation EditAddress($fields: EditAddressInput!, $id: uuid!, $storeId: uuid!) {
  editAddress: edit_address(fields: $fields, id: $id, storeId: $storeId) {
    success
    errors
    address {
      id
      storeId: store_id
      name
      contactNumber: contact_number
      line1: line_1
      line2: line_2
      locality
      company
      administrativeAreaLevel1: administrative_area_level_1
      administrativeAreaLevel2: administrative_area_level_2
      administrativeAreaLevel3: administrative_area_level_3
      countryCode: country_code
      postalCode: postal_code
      longitude
      latitude
    }
  }
}
    `;
export type EditAddressMutationFn = Apollo.MutationFunction<EditAddressMutation, EditAddressMutationVariables>;

/**
 * __useEditAddressMutation__
 *
 * To run a mutation, you first call `useEditAddressMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditAddressMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editAddressMutation, { data, loading, error }] = useEditAddressMutation({
 *   variables: {
 *      fields: // value for 'fields'
 *      id: // value for 'id'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useEditAddressMutation(baseOptions?: Apollo.MutationHookOptions<EditAddressMutation, EditAddressMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditAddressMutation, EditAddressMutationVariables>(EditAddressDocument, options);
      }
export type EditAddressMutationHookResult = ReturnType<typeof useEditAddressMutation>;
export type EditAddressMutationResult = Apollo.MutationResult<EditAddressMutation>;
export type EditAddressMutationOptions = Apollo.BaseMutationOptions<EditAddressMutation, EditAddressMutationVariables>;
export const FulfilmentShipmentCommandDocument = gql`
    mutation FulfilmentShipmentCommand($command: FulfilmentShipmentCommand!, $storeId: uuid!) {
  fulfilmentShipmentCommand: command_fulfilment_shipment(
    command: $command
    storeId: $storeId
  ) {
    fulfilmentShipmentId
    draftFulfilmentShipment: draft_fulfilment_shipment {
      id
      selectedRateId: selected_rate_id
      rateRequest: rate_request {
        errors
      }
      shippingRates: shipping_rates {
        serviceCode: service_code
        service
        id
        externalEntityId: external_entity_id
        amount
        currency
        carrier
        integrations
        errors
        deliveryDays: delivery_days
        integrations
        source
      }
    }
    outcome
    error
  }
}
    `;
export type FulfilmentShipmentCommandMutationFn = Apollo.MutationFunction<FulfilmentShipmentCommandMutation, FulfilmentShipmentCommandMutationVariables>;

/**
 * __useFulfilmentShipmentCommandMutation__
 *
 * To run a mutation, you first call `useFulfilmentShipmentCommandMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFulfilmentShipmentCommandMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [fulfilmentShipmentCommandMutation, { data, loading, error }] = useFulfilmentShipmentCommandMutation({
 *   variables: {
 *      command: // value for 'command'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useFulfilmentShipmentCommandMutation(baseOptions?: Apollo.MutationHookOptions<FulfilmentShipmentCommandMutation, FulfilmentShipmentCommandMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FulfilmentShipmentCommandMutation, FulfilmentShipmentCommandMutationVariables>(FulfilmentShipmentCommandDocument, options);
      }
export type FulfilmentShipmentCommandMutationHookResult = ReturnType<typeof useFulfilmentShipmentCommandMutation>;
export type FulfilmentShipmentCommandMutationResult = Apollo.MutationResult<FulfilmentShipmentCommandMutation>;
export type FulfilmentShipmentCommandMutationOptions = Apollo.BaseMutationOptions<FulfilmentShipmentCommandMutation, FulfilmentShipmentCommandMutationVariables>;
export const GetFulfilmentAtlSettingsDocument = gql`
    query GetFulfilmentAtlSettings($fulfilmentShipmentId: uuid!) {
  fulfilmentShipment: draft_fulfilment_shipment(
    where: {id: {_eq: $fulfilmentShipmentId}}
  ) {
    atlSignatureRequired: atl_signature_required
    atlAgeVerificationRequired: atl_age_verification_required
    atlAuthorityToLeave: atl_authority_to_leave
    atlUnattendedSafety: atl_unattended_safety
  }
}
    `;

/**
 * __useGetFulfilmentAtlSettingsQuery__
 *
 * To run a query within a React component, call `useGetFulfilmentAtlSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFulfilmentAtlSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFulfilmentAtlSettingsQuery({
 *   variables: {
 *      fulfilmentShipmentId: // value for 'fulfilmentShipmentId'
 *   },
 * });
 */
export function useGetFulfilmentAtlSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetFulfilmentAtlSettingsQuery, GetFulfilmentAtlSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFulfilmentAtlSettingsQuery, GetFulfilmentAtlSettingsQueryVariables>(GetFulfilmentAtlSettingsDocument, options);
      }
export function useGetFulfilmentAtlSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFulfilmentAtlSettingsQuery, GetFulfilmentAtlSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFulfilmentAtlSettingsQuery, GetFulfilmentAtlSettingsQueryVariables>(GetFulfilmentAtlSettingsDocument, options);
        }
export type GetFulfilmentAtlSettingsQueryHookResult = ReturnType<typeof useGetFulfilmentAtlSettingsQuery>;
export type GetFulfilmentAtlSettingsLazyQueryHookResult = ReturnType<typeof useGetFulfilmentAtlSettingsLazyQuery>;
export type GetFulfilmentAtlSettingsQueryResult = Apollo.QueryResult<GetFulfilmentAtlSettingsQuery, GetFulfilmentAtlSettingsQueryVariables>;
export const OnInventorySyncJobUpdateDocument = gql`
    subscription OnInventorySyncJobUpdate($inventorySyncJobId: bigint!) {
  inventorySyncJob: inventory_sync_jobs(where: {id: {_eq: $inventorySyncJobId}}) {
    status
    completed_at
    productCount: product_count
    duplicatedBarcodeProducts: duplicated_barcode_products
    duplicatedSkuProducts: duplicated_sku_products
    missingBarcodeProducts: missing_barcode_products
    missingSkuProducts: missing_sku_products
  }
}
    `;

/**
 * __useOnInventorySyncJobUpdateSubscription__
 *
 * To run a query within a React component, call `useOnInventorySyncJobUpdateSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnInventorySyncJobUpdateSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnInventorySyncJobUpdateSubscription({
 *   variables: {
 *      inventorySyncJobId: // value for 'inventorySyncJobId'
 *   },
 * });
 */
export function useOnInventorySyncJobUpdateSubscription(baseOptions: Apollo.SubscriptionHookOptions<OnInventorySyncJobUpdateSubscription, OnInventorySyncJobUpdateSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnInventorySyncJobUpdateSubscription, OnInventorySyncJobUpdateSubscriptionVariables>(OnInventorySyncJobUpdateDocument, options);
      }
export type OnInventorySyncJobUpdateSubscriptionHookResult = ReturnType<typeof useOnInventorySyncJobUpdateSubscription>;
export type OnInventorySyncJobUpdateSubscriptionResult = Apollo.SubscriptionResult<OnInventorySyncJobUpdateSubscription>;
export const GetUnmanifestedLabelsDocument = gql`
    query GetUnmanifestedLabels($offset: Int = 0, $limit: Int = 25, $storeId: uuid, $orderBy: [fulfilment_shipment_order_by!], $carrierWhitelist: [String!]!, $from: timestamptz!, $to: timestamptz! = "now()") {
  fulfilmentShipments: fulfilment_shipments(
    where: {integrations: {_has_key: "ship_engine"}, store_id: {_eq: $storeId}, status: {_nin: [CANCELLED, PROCESSING_AT_SKUTOPIA]}, manifested_at: {_is_null: true}, carrier: {_in: $carrierWhitelist}, _or: [{location_id: {_is_null: true}}, {location: {is_skutopia_fc: {_eq: false}}}], label_booked_at: {_gte: $from, _lte: $to}}
    offset: $offset
    limit: $limit
    order_by: $orderBy
  ) {
    ...UnmanifestedLabel
  }
  fulfilmentShipmentsAggregate: fulfilment_shipments_aggregate(
    where: {integrations: {_has_key: "ship_engine"}, store_id: {_eq: $storeId}, status: {_nin: [CANCELLED, PROCESSING_AT_SKUTOPIA]}, manifested_at: {_is_null: true}, carrier: {_in: $carrierWhitelist}, _or: [{location_id: {_is_null: true}}, {location: {is_skutopia_fc: {_eq: false}}}], label_booked_at: {_gte: $from, _lte: $to}}
  ) {
    aggregate {
      count
    }
  }
}
    ${UnmanifestedLabelFragmentDoc}`;

/**
 * __useGetUnmanifestedLabelsQuery__
 *
 * To run a query within a React component, call `useGetUnmanifestedLabelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUnmanifestedLabelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUnmanifestedLabelsQuery({
 *   variables: {
 *      offset: // value for 'offset'
 *      limit: // value for 'limit'
 *      storeId: // value for 'storeId'
 *      orderBy: // value for 'orderBy'
 *      carrierWhitelist: // value for 'carrierWhitelist'
 *      from: // value for 'from'
 *      to: // value for 'to'
 *   },
 * });
 */
export function useGetUnmanifestedLabelsQuery(baseOptions: Apollo.QueryHookOptions<GetUnmanifestedLabelsQuery, GetUnmanifestedLabelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUnmanifestedLabelsQuery, GetUnmanifestedLabelsQueryVariables>(GetUnmanifestedLabelsDocument, options);
      }
export function useGetUnmanifestedLabelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUnmanifestedLabelsQuery, GetUnmanifestedLabelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUnmanifestedLabelsQuery, GetUnmanifestedLabelsQueryVariables>(GetUnmanifestedLabelsDocument, options);
        }
export type GetUnmanifestedLabelsQueryHookResult = ReturnType<typeof useGetUnmanifestedLabelsQuery>;
export type GetUnmanifestedLabelsLazyQueryHookResult = ReturnType<typeof useGetUnmanifestedLabelsLazyQuery>;
export type GetUnmanifestedLabelsQueryResult = Apollo.QueryResult<GetUnmanifestedLabelsQuery, GetUnmanifestedLabelsQueryVariables>;
export const CreateManifestsDocument = gql`
    mutation CreateManifests($storeId: uuid!, $fulfilmentShipmentIds: [uuid!]!) {
  create_manifest(
    fulfilment_shipment_ids: $fulfilmentShipmentIds
    store_id: $storeId
  ) {
    manifest {
      ...Manifest
    }
  }
}
    ${ManifestFragmentDoc}`;
export type CreateManifestsMutationFn = Apollo.MutationFunction<CreateManifestsMutation, CreateManifestsMutationVariables>;

/**
 * __useCreateManifestsMutation__
 *
 * To run a mutation, you first call `useCreateManifestsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateManifestsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createManifestsMutation, { data, loading, error }] = useCreateManifestsMutation({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      fulfilmentShipmentIds: // value for 'fulfilmentShipmentIds'
 *   },
 * });
 */
export function useCreateManifestsMutation(baseOptions?: Apollo.MutationHookOptions<CreateManifestsMutation, CreateManifestsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateManifestsMutation, CreateManifestsMutationVariables>(CreateManifestsDocument, options);
      }
export type CreateManifestsMutationHookResult = ReturnType<typeof useCreateManifestsMutation>;
export type CreateManifestsMutationResult = Apollo.MutationResult<CreateManifestsMutation>;
export type CreateManifestsMutationOptions = Apollo.BaseMutationOptions<CreateManifestsMutation, CreateManifestsMutationVariables>;
export const GetManifestsForPeriodDocument = gql`
    query GetManifestsForPeriod($from: timestamptz!, $to: timestamptz! = "now()", $storeId: uuid, $orderBy: [manifest_order_by!]) {
  manifests(
    where: {_and: [{created_at: {_gte: $from, _lte: $to}}, {store_id: {_eq: $storeId}}]}
    order_by: $orderBy
  ) {
    ...Manifest
  }
}
    ${ManifestFragmentDoc}`;

/**
 * __useGetManifestsForPeriodQuery__
 *
 * To run a query within a React component, call `useGetManifestsForPeriodQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetManifestsForPeriodQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetManifestsForPeriodQuery({
 *   variables: {
 *      from: // value for 'from'
 *      to: // value for 'to'
 *      storeId: // value for 'storeId'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useGetManifestsForPeriodQuery(baseOptions: Apollo.QueryHookOptions<GetManifestsForPeriodQuery, GetManifestsForPeriodQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetManifestsForPeriodQuery, GetManifestsForPeriodQueryVariables>(GetManifestsForPeriodDocument, options);
      }
export function useGetManifestsForPeriodLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetManifestsForPeriodQuery, GetManifestsForPeriodQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetManifestsForPeriodQuery, GetManifestsForPeriodQueryVariables>(GetManifestsForPeriodDocument, options);
        }
export type GetManifestsForPeriodQueryHookResult = ReturnType<typeof useGetManifestsForPeriodQuery>;
export type GetManifestsForPeriodLazyQueryHookResult = ReturnType<typeof useGetManifestsForPeriodLazyQuery>;
export type GetManifestsForPeriodQueryResult = Apollo.QueryResult<GetManifestsForPeriodQuery, GetManifestsForPeriodQueryVariables>;
export const GetParcelTypesDocument = gql`
    query GetParcelTypes($storeId: uuid) {
  parcelTypes: parcel_types(
    where: {store_id: {_eq: $storeId}}
    order_by: {is_active: desc, created_at: desc}
  ) {
    ...CompleteParcelType
  }
}
    ${CompleteParcelTypeFragmentDoc}`;

/**
 * __useGetParcelTypesQuery__
 *
 * To run a query within a React component, call `useGetParcelTypesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetParcelTypesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetParcelTypesQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useGetParcelTypesQuery(baseOptions?: Apollo.QueryHookOptions<GetParcelTypesQuery, GetParcelTypesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetParcelTypesQuery, GetParcelTypesQueryVariables>(GetParcelTypesDocument, options);
      }
export function useGetParcelTypesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetParcelTypesQuery, GetParcelTypesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetParcelTypesQuery, GetParcelTypesQueryVariables>(GetParcelTypesDocument, options);
        }
export type GetParcelTypesQueryHookResult = ReturnType<typeof useGetParcelTypesQuery>;
export type GetParcelTypesLazyQueryHookResult = ReturnType<typeof useGetParcelTypesLazyQuery>;
export type GetParcelTypesQueryResult = Apollo.QueryResult<GetParcelTypesQuery, GetParcelTypesQueryVariables>;
export const AddParcelTypesDocument = gql`
    mutation AddParcelTypes($parcelTypes: [AddParcelTypesInput!]!) {
  addedParcelTypes: add_parcel_types(parcelTypes: $parcelTypes) {
    count
  }
}
    `;
export type AddParcelTypesMutationFn = Apollo.MutationFunction<AddParcelTypesMutation, AddParcelTypesMutationVariables>;

/**
 * __useAddParcelTypesMutation__
 *
 * To run a mutation, you first call `useAddParcelTypesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddParcelTypesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addParcelTypesMutation, { data, loading, error }] = useAddParcelTypesMutation({
 *   variables: {
 *      parcelTypes: // value for 'parcelTypes'
 *   },
 * });
 */
export function useAddParcelTypesMutation(baseOptions?: Apollo.MutationHookOptions<AddParcelTypesMutation, AddParcelTypesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddParcelTypesMutation, AddParcelTypesMutationVariables>(AddParcelTypesDocument, options);
      }
export type AddParcelTypesMutationHookResult = ReturnType<typeof useAddParcelTypesMutation>;
export type AddParcelTypesMutationResult = Apollo.MutationResult<AddParcelTypesMutation>;
export type AddParcelTypesMutationOptions = Apollo.BaseMutationOptions<AddParcelTypesMutation, AddParcelTypesMutationVariables>;
export const EditParcelTypeByIdDocument = gql`
    mutation EditParcelTypeById($id: uuid!, $fields: EditParcelTypeInput!) {
  parcelType: edit_parcel_types_by_pk(id: $id, fields: $fields) {
    parcel_type {
      id
      isActive: is_active
      isDefault: is_default
    }
  }
}
    `;
export type EditParcelTypeByIdMutationFn = Apollo.MutationFunction<EditParcelTypeByIdMutation, EditParcelTypeByIdMutationVariables>;

/**
 * __useEditParcelTypeByIdMutation__
 *
 * To run a mutation, you first call `useEditParcelTypeByIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditParcelTypeByIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editParcelTypeByIdMutation, { data, loading, error }] = useEditParcelTypeByIdMutation({
 *   variables: {
 *      id: // value for 'id'
 *      fields: // value for 'fields'
 *   },
 * });
 */
export function useEditParcelTypeByIdMutation(baseOptions?: Apollo.MutationHookOptions<EditParcelTypeByIdMutation, EditParcelTypeByIdMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditParcelTypeByIdMutation, EditParcelTypeByIdMutationVariables>(EditParcelTypeByIdDocument, options);
      }
export type EditParcelTypeByIdMutationHookResult = ReturnType<typeof useEditParcelTypeByIdMutation>;
export type EditParcelTypeByIdMutationResult = Apollo.MutationResult<EditParcelTypeByIdMutation>;
export type EditParcelTypeByIdMutationOptions = Apollo.BaseMutationOptions<EditParcelTypeByIdMutation, EditParcelTypeByIdMutationVariables>;
export const DeleteParcelTypesByIdsDocument = gql`
    mutation DeleteParcelTypesByIds($ids: [uuid!]!, $storeId: uuid!) {
  deleteParcelTypesByIds: delete_parcel_types_by_ids(
    parcelTypes: {ids: $ids, storeId: $storeId}
  ) {
    success
    errors
  }
}
    `;
export type DeleteParcelTypesByIdsMutationFn = Apollo.MutationFunction<DeleteParcelTypesByIdsMutation, DeleteParcelTypesByIdsMutationVariables>;

/**
 * __useDeleteParcelTypesByIdsMutation__
 *
 * To run a mutation, you first call `useDeleteParcelTypesByIdsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteParcelTypesByIdsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteParcelTypesByIdsMutation, { data, loading, error }] = useDeleteParcelTypesByIdsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useDeleteParcelTypesByIdsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteParcelTypesByIdsMutation, DeleteParcelTypesByIdsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteParcelTypesByIdsMutation, DeleteParcelTypesByIdsMutationVariables>(DeleteParcelTypesByIdsDocument, options);
      }
export type DeleteParcelTypesByIdsMutationHookResult = ReturnType<typeof useDeleteParcelTypesByIdsMutation>;
export type DeleteParcelTypesByIdsMutationResult = Apollo.MutationResult<DeleteParcelTypesByIdsMutation>;
export type DeleteParcelTypesByIdsMutationOptions = Apollo.BaseMutationOptions<DeleteParcelTypesByIdsMutation, DeleteParcelTypesByIdsMutationVariables>;
export const SyncSalesOrderDocument = gql`
    mutation SyncSalesOrder($id: uuid!) {
  sync_sales_order(sales_order_id: $id) {
    salesOrder: sales_order {
      ...SalesOrderWithUncancelledShipment
      shippingAddress: shipping_address {
        id
        storeId: store_id
        line1: line_1
        line2: line_2
        company
        countryCode: country_code
        administrativeAreaLevel1: administrative_area_level_1
        administrativeAreaLevel2: administrative_area_level_2
        administrativeAreaLevel3: administrative_area_level_3
        locality
        postalCode: postal_code
        name
        contactNumber: contact_number
        email
      }
      customer {
        firstName: first_name
        lastName: last_name
      }
    }
  }
}
    ${SalesOrderWithUncancelledShipmentFragmentDoc}`;
export type SyncSalesOrderMutationFn = Apollo.MutationFunction<SyncSalesOrderMutation, SyncSalesOrderMutationVariables>;

/**
 * __useSyncSalesOrderMutation__
 *
 * To run a mutation, you first call `useSyncSalesOrderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncSalesOrderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncSalesOrderMutation, { data, loading, error }] = useSyncSalesOrderMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSyncSalesOrderMutation(baseOptions?: Apollo.MutationHookOptions<SyncSalesOrderMutation, SyncSalesOrderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncSalesOrderMutation, SyncSalesOrderMutationVariables>(SyncSalesOrderDocument, options);
      }
export type SyncSalesOrderMutationHookResult = ReturnType<typeof useSyncSalesOrderMutation>;
export type SyncSalesOrderMutationResult = Apollo.MutationResult<SyncSalesOrderMutation>;
export type SyncSalesOrderMutationOptions = Apollo.BaseMutationOptions<SyncSalesOrderMutation, SyncSalesOrderMutationVariables>;
export const PackLineItemsDocument = gql`
    mutation PackLineItems($lineItems: [PackLineItemsInput!]!, $unpack: Boolean) {
  pack_line_items(lineItems: $lineItems, unpack: $unpack) {
    success
    errors
  }
}
    `;
export type PackLineItemsMutationFn = Apollo.MutationFunction<PackLineItemsMutation, PackLineItemsMutationVariables>;

/**
 * __usePackLineItemsMutation__
 *
 * To run a mutation, you first call `usePackLineItemsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePackLineItemsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [packLineItemsMutation, { data, loading, error }] = usePackLineItemsMutation({
 *   variables: {
 *      lineItems: // value for 'lineItems'
 *      unpack: // value for 'unpack'
 *   },
 * });
 */
export function usePackLineItemsMutation(baseOptions?: Apollo.MutationHookOptions<PackLineItemsMutation, PackLineItemsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PackLineItemsMutation, PackLineItemsMutationVariables>(PackLineItemsDocument, options);
      }
export type PackLineItemsMutationHookResult = ReturnType<typeof usePackLineItemsMutation>;
export type PackLineItemsMutationResult = Apollo.MutationResult<PackLineItemsMutation>;
export type PackLineItemsMutationOptions = Apollo.BaseMutationOptions<PackLineItemsMutation, PackLineItemsMutationVariables>;
export const GetTagsDocument = gql`
    query GetTags($storeId: uuid_comparison_exp) {
  tags(where: {store_id: $storeId}) {
    id
    name
    store_id
  }
}
    `;

/**
 * __useGetTagsQuery__
 *
 * To run a query within a React component, call `useGetTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTagsQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useGetTagsQuery(baseOptions?: Apollo.QueryHookOptions<GetTagsQuery, GetTagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTagsQuery, GetTagsQueryVariables>(GetTagsDocument, options);
      }
export function useGetTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTagsQuery, GetTagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTagsQuery, GetTagsQueryVariables>(GetTagsDocument, options);
        }
export type GetTagsQueryHookResult = ReturnType<typeof useGetTagsQuery>;
export type GetTagsLazyQueryHookResult = ReturnType<typeof useGetTagsLazyQuery>;
export type GetTagsQueryResult = Apollo.QueryResult<GetTagsQuery, GetTagsQueryVariables>;
export const GetDetailsForBulkBookingDocument = gql`
    query GetDetailsForBulkBooking($ids: [uuid!]) {
  salesOrders: sales_orders(
    where: {_and: {fulfilment_shipments: {status: {_eq: DRAFT}}, id: {_in: $ids}}}
  ) {
    id
    fulfilmentShipments: fulfilment_shipments(where: {status: {_eq: DRAFT}}) {
      ...BulkActionFulfilmentShipment
    }
  }
}
    ${BulkActionFulfilmentShipmentFragmentDoc}`;

/**
 * __useGetDetailsForBulkBookingQuery__
 *
 * To run a query within a React component, call `useGetDetailsForBulkBookingQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDetailsForBulkBookingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDetailsForBulkBookingQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useGetDetailsForBulkBookingQuery(baseOptions?: Apollo.QueryHookOptions<GetDetailsForBulkBookingQuery, GetDetailsForBulkBookingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDetailsForBulkBookingQuery, GetDetailsForBulkBookingQueryVariables>(GetDetailsForBulkBookingDocument, options);
      }
export function useGetDetailsForBulkBookingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDetailsForBulkBookingQuery, GetDetailsForBulkBookingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDetailsForBulkBookingQuery, GetDetailsForBulkBookingQueryVariables>(GetDetailsForBulkBookingDocument, options);
        }
export type GetDetailsForBulkBookingQueryHookResult = ReturnType<typeof useGetDetailsForBulkBookingQuery>;
export type GetDetailsForBulkBookingLazyQueryHookResult = ReturnType<typeof useGetDetailsForBulkBookingLazyQuery>;
export type GetDetailsForBulkBookingQueryResult = Apollo.QueryResult<GetDetailsForBulkBookingQuery, GetDetailsForBulkBookingQueryVariables>;
export const GetDetailsForBulkCancellingDocument = gql`
    query GetDetailsForBulkCancelling($ids: [uuid!]) {
  salesOrders: sales_orders(
    where: {_and: {fulfilment_shipments: {source: {_neq: EXTERNAL}, status: {_eq: UNSENT}}, id: {_in: $ids}}}
  ) {
    id
    fulfilmentShipments: fulfilment_shipments(
      where: {source: {_neq: EXTERNAL}, status: {_eq: UNSENT}}
    ) {
      ...BulkActionFulfilmentShipment
    }
  }
}
    ${BulkActionFulfilmentShipmentFragmentDoc}`;

/**
 * __useGetDetailsForBulkCancellingQuery__
 *
 * To run a query within a React component, call `useGetDetailsForBulkCancellingQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDetailsForBulkCancellingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDetailsForBulkCancellingQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useGetDetailsForBulkCancellingQuery(baseOptions?: Apollo.QueryHookOptions<GetDetailsForBulkCancellingQuery, GetDetailsForBulkCancellingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDetailsForBulkCancellingQuery, GetDetailsForBulkCancellingQueryVariables>(GetDetailsForBulkCancellingDocument, options);
      }
export function useGetDetailsForBulkCancellingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDetailsForBulkCancellingQuery, GetDetailsForBulkCancellingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDetailsForBulkCancellingQuery, GetDetailsForBulkCancellingQueryVariables>(GetDetailsForBulkCancellingDocument, options);
        }
export type GetDetailsForBulkCancellingQueryHookResult = ReturnType<typeof useGetDetailsForBulkCancellingQuery>;
export type GetDetailsForBulkCancellingLazyQueryHookResult = ReturnType<typeof useGetDetailsForBulkCancellingLazyQuery>;
export type GetDetailsForBulkCancellingQueryResult = Apollo.QueryResult<GetDetailsForBulkCancellingQuery, GetDetailsForBulkCancellingQueryVariables>;
export const OnSalesOrderRatesUpdatedDocument = gql`
    subscription OnSalesOrderRatesUpdated($salesOrderId: uuid!) {
  salesOrder: sales_orders_by_pk(id: $salesOrderId) {
    id
    ...SalesOrderDraftFulfilmentShipmentWithRates
  }
}
    ${SalesOrderDraftFulfilmentShipmentWithRatesFragmentDoc}`;

/**
 * __useOnSalesOrderRatesUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnSalesOrderRatesUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnSalesOrderRatesUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnSalesOrderRatesUpdatedSubscription({
 *   variables: {
 *      salesOrderId: // value for 'salesOrderId'
 *   },
 * });
 */
export function useOnSalesOrderRatesUpdatedSubscription(baseOptions: Apollo.SubscriptionHookOptions<OnSalesOrderRatesUpdatedSubscription, OnSalesOrderRatesUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnSalesOrderRatesUpdatedSubscription, OnSalesOrderRatesUpdatedSubscriptionVariables>(OnSalesOrderRatesUpdatedDocument, options);
      }
export type OnSalesOrderRatesUpdatedSubscriptionHookResult = ReturnType<typeof useOnSalesOrderRatesUpdatedSubscription>;
export type OnSalesOrderRatesUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnSalesOrderRatesUpdatedSubscription>;
export const SalesOrderCommandDocument = gql`
    mutation SalesOrderCommand($command: SalesOrderCommand!, $storeId: uuid!) {
  handleSalesOrderCommand: command_sales_order(
    command: $command
    storeId: $storeId
  ) {
    outcome
    error
    salesOrderId
  }
}
    `;
export type SalesOrderCommandMutationFn = Apollo.MutationFunction<SalesOrderCommandMutation, SalesOrderCommandMutationVariables>;

/**
 * __useSalesOrderCommandMutation__
 *
 * To run a mutation, you first call `useSalesOrderCommandMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSalesOrderCommandMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [salesOrderCommandMutation, { data, loading, error }] = useSalesOrderCommandMutation({
 *   variables: {
 *      command: // value for 'command'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useSalesOrderCommandMutation(baseOptions?: Apollo.MutationHookOptions<SalesOrderCommandMutation, SalesOrderCommandMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SalesOrderCommandMutation, SalesOrderCommandMutationVariables>(SalesOrderCommandDocument, options);
      }
export type SalesOrderCommandMutationHookResult = ReturnType<typeof useSalesOrderCommandMutation>;
export type SalesOrderCommandMutationResult = Apollo.MutationResult<SalesOrderCommandMutation>;
export type SalesOrderCommandMutationOptions = Apollo.BaseMutationOptions<SalesOrderCommandMutation, SalesOrderCommandMutationVariables>;
export const GetSalesOrderWithFulfilmentShipmentsDocument = gql`
    query GetSalesOrderWithFulfilmentShipments($salesOrderId: uuid!) {
  salesOrder: sales_orders_by_pk(id: $salesOrderId) {
    ...SalesOrderWithShipments
  }
}
    ${SalesOrderWithShipmentsFragmentDoc}`;

/**
 * __useGetSalesOrderWithFulfilmentShipmentsQuery__
 *
 * To run a query within a React component, call `useGetSalesOrderWithFulfilmentShipmentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSalesOrderWithFulfilmentShipmentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSalesOrderWithFulfilmentShipmentsQuery({
 *   variables: {
 *      salesOrderId: // value for 'salesOrderId'
 *   },
 * });
 */
export function useGetSalesOrderWithFulfilmentShipmentsQuery(baseOptions: Apollo.QueryHookOptions<GetSalesOrderWithFulfilmentShipmentsQuery, GetSalesOrderWithFulfilmentShipmentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSalesOrderWithFulfilmentShipmentsQuery, GetSalesOrderWithFulfilmentShipmentsQueryVariables>(GetSalesOrderWithFulfilmentShipmentsDocument, options);
      }
export function useGetSalesOrderWithFulfilmentShipmentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSalesOrderWithFulfilmentShipmentsQuery, GetSalesOrderWithFulfilmentShipmentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSalesOrderWithFulfilmentShipmentsQuery, GetSalesOrderWithFulfilmentShipmentsQueryVariables>(GetSalesOrderWithFulfilmentShipmentsDocument, options);
        }
export type GetSalesOrderWithFulfilmentShipmentsQueryHookResult = ReturnType<typeof useGetSalesOrderWithFulfilmentShipmentsQuery>;
export type GetSalesOrderWithFulfilmentShipmentsLazyQueryHookResult = ReturnType<typeof useGetSalesOrderWithFulfilmentShipmentsLazyQuery>;
export type GetSalesOrderWithFulfilmentShipmentsQueryResult = Apollo.QueryResult<GetSalesOrderWithFulfilmentShipmentsQuery, GetSalesOrderWithFulfilmentShipmentsQueryVariables>;
export const OnSalesOrderTrackingDataUpdatedDocument = gql`
    subscription OnSalesOrderTrackingDataUpdated($salesOrderId: uuid!) {
  salesOrder: sales_orders_by_pk(id: $salesOrderId) {
    fulfilmentShipments: fulfilment_shipments(
      where: {source: {_neq: EXTERNAL}, status: {_eq: UNSENT}}
    ) {
      id
      trackingNumber: tracking_number
      trackingUrl: tracking_url
    }
  }
}
    `;

/**
 * __useOnSalesOrderTrackingDataUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnSalesOrderTrackingDataUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnSalesOrderTrackingDataUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnSalesOrderTrackingDataUpdatedSubscription({
 *   variables: {
 *      salesOrderId: // value for 'salesOrderId'
 *   },
 * });
 */
export function useOnSalesOrderTrackingDataUpdatedSubscription(baseOptions: Apollo.SubscriptionHookOptions<OnSalesOrderTrackingDataUpdatedSubscription, OnSalesOrderTrackingDataUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnSalesOrderTrackingDataUpdatedSubscription, OnSalesOrderTrackingDataUpdatedSubscriptionVariables>(OnSalesOrderTrackingDataUpdatedDocument, options);
      }
export type OnSalesOrderTrackingDataUpdatedSubscriptionHookResult = ReturnType<typeof useOnSalesOrderTrackingDataUpdatedSubscription>;
export type OnSalesOrderTrackingDataUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnSalesOrderTrackingDataUpdatedSubscription>;
export const OnSalesOrderUpdatedDocument = gql`
    subscription OnSalesOrderUpdated($salesOrderId: uuid!) {
  salesOrder: sales_orders_by_pk(id: $salesOrderId) {
    ...SalesOrderWithShipments
  }
}
    ${SalesOrderWithShipmentsFragmentDoc}`;

/**
 * __useOnSalesOrderUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnSalesOrderUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnSalesOrderUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnSalesOrderUpdatedSubscription({
 *   variables: {
 *      salesOrderId: // value for 'salesOrderId'
 *   },
 * });
 */
export function useOnSalesOrderUpdatedSubscription(baseOptions: Apollo.SubscriptionHookOptions<OnSalesOrderUpdatedSubscription, OnSalesOrderUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnSalesOrderUpdatedSubscription, OnSalesOrderUpdatedSubscriptionVariables>(OnSalesOrderUpdatedDocument, options);
      }
export type OnSalesOrderUpdatedSubscriptionHookResult = ReturnType<typeof useOnSalesOrderUpdatedSubscription>;
export type OnSalesOrderUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnSalesOrderUpdatedSubscription>;
export const GetSalesOrdersWithFulfilmentShipmentsDocument = gql`
    query GetSalesOrdersWithFulfilmentShipments($where: sales_order_bool_exp!, $orderBy: [sales_order_order_by!], $storeId: uuid!, $limit: Int, $offset: Int) {
  salesOrders: sales_orders(
    order_by: $orderBy
    where: {store_id: {_eq: $storeId}, _and: [$where]}
    limit: $limit
    offset: $offset
  ) {
    ...SalesOrderWithShipments
  }
  salesOrdersAggregate: sales_orders_aggregate(
    where: {store_id: {_eq: $storeId}, _and: [$where]}
  ) {
    aggregate {
      count
    }
  }
}
    ${SalesOrderWithShipmentsFragmentDoc}`;

/**
 * __useGetSalesOrdersWithFulfilmentShipmentsQuery__
 *
 * To run a query within a React component, call `useGetSalesOrdersWithFulfilmentShipmentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSalesOrdersWithFulfilmentShipmentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSalesOrdersWithFulfilmentShipmentsQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      storeId: // value for 'storeId'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetSalesOrdersWithFulfilmentShipmentsQuery(baseOptions: Apollo.QueryHookOptions<GetSalesOrdersWithFulfilmentShipmentsQuery, GetSalesOrdersWithFulfilmentShipmentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSalesOrdersWithFulfilmentShipmentsQuery, GetSalesOrdersWithFulfilmentShipmentsQueryVariables>(GetSalesOrdersWithFulfilmentShipmentsDocument, options);
      }
export function useGetSalesOrdersWithFulfilmentShipmentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSalesOrdersWithFulfilmentShipmentsQuery, GetSalesOrdersWithFulfilmentShipmentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSalesOrdersWithFulfilmentShipmentsQuery, GetSalesOrdersWithFulfilmentShipmentsQueryVariables>(GetSalesOrdersWithFulfilmentShipmentsDocument, options);
        }
export type GetSalesOrdersWithFulfilmentShipmentsQueryHookResult = ReturnType<typeof useGetSalesOrdersWithFulfilmentShipmentsQuery>;
export type GetSalesOrdersWithFulfilmentShipmentsLazyQueryHookResult = ReturnType<typeof useGetSalesOrdersWithFulfilmentShipmentsLazyQuery>;
export type GetSalesOrdersWithFulfilmentShipmentsQueryResult = Apollo.QueryResult<GetSalesOrdersWithFulfilmentShipmentsQuery, GetSalesOrdersWithFulfilmentShipmentsQueryVariables>;
export const OnSalesOrdersWithFulfilmentShipmentsUpdatedDocument = gql`
    subscription OnSalesOrdersWithFulfilmentShipmentsUpdated($where: sales_order_bool_exp!, $orderBy: [sales_order_order_by!], $storeId: uuid!, $limit: Int, $offset: Int) {
  salesOrders: sales_orders(
    order_by: $orderBy
    where: {store_id: {_eq: $storeId}, _and: [$where]}
    limit: $limit
    offset: $offset
  ) {
    ...SalesOrderWithFulfilmentShipmentsSubscription
  }
}
    ${SalesOrderWithFulfilmentShipmentsSubscriptionFragmentDoc}`;

/**
 * __useOnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      storeId: // value for 'storeId'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useOnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription(baseOptions: Apollo.SubscriptionHookOptions<OnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription, OnSalesOrdersWithFulfilmentShipmentsUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription, OnSalesOrdersWithFulfilmentShipmentsUpdatedSubscriptionVariables>(OnSalesOrdersWithFulfilmentShipmentsUpdatedDocument, options);
      }
export type OnSalesOrdersWithFulfilmentShipmentsUpdatedSubscriptionHookResult = ReturnType<typeof useOnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription>;
export type OnSalesOrdersWithFulfilmentShipmentsUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnSalesOrdersWithFulfilmentShipmentsUpdatedSubscription>;
export const OnSalesOrdersWithFulfilmentShipmentsCountUpdatedDocument = gql`
    subscription OnSalesOrdersWithFulfilmentShipmentsCountUpdated($where: sales_order_bool_exp!, $storeId: uuid!) {
  salesOrdersAggregate: sales_orders_aggregate(
    where: {store_id: {_eq: $storeId}, _and: [$where]}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useOnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription({
 *   variables: {
 *      where: // value for 'where'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useOnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription(baseOptions: Apollo.SubscriptionHookOptions<OnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription, OnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription, OnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscriptionVariables>(OnSalesOrdersWithFulfilmentShipmentsCountUpdatedDocument, options);
      }
export type OnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscriptionHookResult = ReturnType<typeof useOnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription>;
export type OnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnSalesOrdersWithFulfilmentShipmentsCountUpdatedSubscription>;
export const SalesOrderTabCountsDocument = gql`
    query SalesOrderTabCounts($storeId: uuid!) {
  open: fulfilment_shipments_aggregate(
    where: {status: {_eq: DRAFT}, store_id: {_eq: $storeId}, sales_order: {status: {_nin: [ARCHIVED, CANCELLED]}}}
  ) {
    ...FulfilmentShipmentCount
  }
  processing: fulfilment_shipments_aggregate(
    where: {status: {_eq: PROCESSING_AT_SKUTOPIA}, store_id: {_eq: $storeId}, sales_order: {status: {_nin: [ARCHIVED, CANCELLED]}}}
  ) {
    ...FulfilmentShipmentCount
  }
  scheduled: fulfilment_shipments_aggregate(
    where: {source: {_neq: EXTERNAL}, status: {_eq: UNSENT}, store_id: {_eq: $storeId}, sales_order: {status: {_nin: [ARCHIVED, CANCELLED]}}, scheduled_pickup_date: {_is_null: false}}
  ) {
    ...FulfilmentShipmentCount
  }
  awaitingCarrier: fulfilment_shipments_aggregate(
    where: {source: {_neq: EXTERNAL}, status: {_eq: UNSENT}, store_id: {_eq: $storeId}, sales_order: {status: {_nin: [ARCHIVED, CANCELLED]}}, scheduled_pickup_date: {_is_null: true}}
  ) {
    ...FulfilmentShipmentCount
  }
  review: fulfilment_shipments_aggregate(
    where: {status: {_eq: DRAFT}, store_id: {_eq: $storeId}, selected_rate_id: {_is_null: true}, sales_order: {status: {_nin: [ARCHIVED, CANCELLED]}}}
  ) {
    ...FulfilmentShipmentCount
  }
}
    ${FulfilmentShipmentCountFragmentDoc}`;

/**
 * __useSalesOrderTabCountsQuery__
 *
 * To run a query within a React component, call `useSalesOrderTabCountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSalesOrderTabCountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSalesOrderTabCountsQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useSalesOrderTabCountsQuery(baseOptions: Apollo.QueryHookOptions<SalesOrderTabCountsQuery, SalesOrderTabCountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SalesOrderTabCountsQuery, SalesOrderTabCountsQueryVariables>(SalesOrderTabCountsDocument, options);
      }
export function useSalesOrderTabCountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SalesOrderTabCountsQuery, SalesOrderTabCountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SalesOrderTabCountsQuery, SalesOrderTabCountsQueryVariables>(SalesOrderTabCountsDocument, options);
        }
export type SalesOrderTabCountsQueryHookResult = ReturnType<typeof useSalesOrderTabCountsQuery>;
export type SalesOrderTabCountsLazyQueryHookResult = ReturnType<typeof useSalesOrderTabCountsLazyQuery>;
export type SalesOrderTabCountsQueryResult = Apollo.QueryResult<SalesOrderTabCountsQuery, SalesOrderTabCountsQueryVariables>;
export const OnSalesOrderTabCountsUpdatedDocument = gql`
    subscription OnSalesOrderTabCountsUpdated($source: String, $storeId: uuid!, $status: shipment_status_enum!, $scheduled_pickup_date: Int) {
  open: fulfilment_shipments_aggregate(
    where: {status: {_eq: $status}, store_id: {_eq: $storeId}, sales_order: {status: {_nin: [ARCHIVED, CANCELLED]}}}
  ) {
    ...FulfilmentShipmentCount
  }
}
    ${FulfilmentShipmentCountFragmentDoc}`;

/**
 * __useOnSalesOrderTabCountsUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnSalesOrderTabCountsUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnSalesOrderTabCountsUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnSalesOrderTabCountsUpdatedSubscription({
 *   variables: {
 *      source: // value for 'source'
 *      storeId: // value for 'storeId'
 *      status: // value for 'status'
 *      scheduled_pickup_date: // value for 'scheduled_pickup_date'
 *   },
 * });
 */
export function useOnSalesOrderTabCountsUpdatedSubscription(baseOptions: Apollo.SubscriptionHookOptions<OnSalesOrderTabCountsUpdatedSubscription, OnSalesOrderTabCountsUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnSalesOrderTabCountsUpdatedSubscription, OnSalesOrderTabCountsUpdatedSubscriptionVariables>(OnSalesOrderTabCountsUpdatedDocument, options);
      }
export type OnSalesOrderTabCountsUpdatedSubscriptionHookResult = ReturnType<typeof useOnSalesOrderTabCountsUpdatedSubscription>;
export type OnSalesOrderTabCountsUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnSalesOrderTabCountsUpdatedSubscription>;
export const GetOrderDetailsForBulkBookingByIdsDocument = gql`
    query GetOrderDetailsForBulkBookingByIds($ids: [uuid!]) {
  salesOrders: sales_orders(
    where: {_and: {fulfilment_shipments: {status: {_eq: DRAFT}}, id: {_in: $ids}}}
  ) {
    ...SalesOrderWithUncancelledShipmentListing
  }
}
    ${SalesOrderWithUncancelledShipmentListingFragmentDoc}`;

/**
 * __useGetOrderDetailsForBulkBookingByIdsQuery__
 *
 * To run a query within a React component, call `useGetOrderDetailsForBulkBookingByIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrderDetailsForBulkBookingByIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrderDetailsForBulkBookingByIdsQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useGetOrderDetailsForBulkBookingByIdsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrderDetailsForBulkBookingByIdsQuery, GetOrderDetailsForBulkBookingByIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrderDetailsForBulkBookingByIdsQuery, GetOrderDetailsForBulkBookingByIdsQueryVariables>(GetOrderDetailsForBulkBookingByIdsDocument, options);
      }
export function useGetOrderDetailsForBulkBookingByIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrderDetailsForBulkBookingByIdsQuery, GetOrderDetailsForBulkBookingByIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrderDetailsForBulkBookingByIdsQuery, GetOrderDetailsForBulkBookingByIdsQueryVariables>(GetOrderDetailsForBulkBookingByIdsDocument, options);
        }
export type GetOrderDetailsForBulkBookingByIdsQueryHookResult = ReturnType<typeof useGetOrderDetailsForBulkBookingByIdsQuery>;
export type GetOrderDetailsForBulkBookingByIdsLazyQueryHookResult = ReturnType<typeof useGetOrderDetailsForBulkBookingByIdsLazyQuery>;
export type GetOrderDetailsForBulkBookingByIdsQueryResult = Apollo.QueryResult<GetOrderDetailsForBulkBookingByIdsQuery, GetOrderDetailsForBulkBookingByIdsQueryVariables>;
export const GetOrderDetailsForBulkCancellingByIdsDocument = gql`
    query GetOrderDetailsForBulkCancellingByIds($ids: [uuid!], $storeId: uuid) {
  salesOrders: sales_orders(
    where: {_and: {fulfilment_shipments: {source: {_neq: EXTERNAL}, status: {_eq: UNSENT}}, id: {_in: $ids}, store_id: {_eq: $storeId}}}
  ) {
    ...SalesOrderWithUncancelledShipmentListing
  }
}
    ${SalesOrderWithUncancelledShipmentListingFragmentDoc}`;

/**
 * __useGetOrderDetailsForBulkCancellingByIdsQuery__
 *
 * To run a query within a React component, call `useGetOrderDetailsForBulkCancellingByIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrderDetailsForBulkCancellingByIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrderDetailsForBulkCancellingByIdsQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useGetOrderDetailsForBulkCancellingByIdsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrderDetailsForBulkCancellingByIdsQuery, GetOrderDetailsForBulkCancellingByIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrderDetailsForBulkCancellingByIdsQuery, GetOrderDetailsForBulkCancellingByIdsQueryVariables>(GetOrderDetailsForBulkCancellingByIdsDocument, options);
      }
export function useGetOrderDetailsForBulkCancellingByIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrderDetailsForBulkCancellingByIdsQuery, GetOrderDetailsForBulkCancellingByIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrderDetailsForBulkCancellingByIdsQuery, GetOrderDetailsForBulkCancellingByIdsQueryVariables>(GetOrderDetailsForBulkCancellingByIdsDocument, options);
        }
export type GetOrderDetailsForBulkCancellingByIdsQueryHookResult = ReturnType<typeof useGetOrderDetailsForBulkCancellingByIdsQuery>;
export type GetOrderDetailsForBulkCancellingByIdsLazyQueryHookResult = ReturnType<typeof useGetOrderDetailsForBulkCancellingByIdsLazyQuery>;
export type GetOrderDetailsForBulkCancellingByIdsQueryResult = Apollo.QueryResult<GetOrderDetailsForBulkCancellingByIdsQuery, GetOrderDetailsForBulkCancellingByIdsQueryVariables>;
export const GetSalesOrdersByIdsDocument = gql`
    query GetSalesOrdersByIds($ids: [uuid!], $storeId: uuid) {
  salesOrders: sales_orders(
    where: {_and: {id: {_in: $ids}, store_id: {_eq: $storeId}}}
  ) {
    ...SalesOrderWithShipments
  }
}
    ${SalesOrderWithShipmentsFragmentDoc}`;

/**
 * __useGetSalesOrdersByIdsQuery__
 *
 * To run a query within a React component, call `useGetSalesOrdersByIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSalesOrdersByIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSalesOrdersByIdsQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useGetSalesOrdersByIdsQuery(baseOptions?: Apollo.QueryHookOptions<GetSalesOrdersByIdsQuery, GetSalesOrdersByIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSalesOrdersByIdsQuery, GetSalesOrdersByIdsQueryVariables>(GetSalesOrdersByIdsDocument, options);
      }
export function useGetSalesOrdersByIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSalesOrdersByIdsQuery, GetSalesOrdersByIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSalesOrdersByIdsQuery, GetSalesOrdersByIdsQueryVariables>(GetSalesOrdersByIdsDocument, options);
        }
export type GetSalesOrdersByIdsQueryHookResult = ReturnType<typeof useGetSalesOrdersByIdsQuery>;
export type GetSalesOrdersByIdsLazyQueryHookResult = ReturnType<typeof useGetSalesOrdersByIdsLazyQuery>;
export type GetSalesOrdersByIdsQueryResult = Apollo.QueryResult<GetSalesOrdersByIdsQuery, GetSalesOrdersByIdsQueryVariables>;
export const OnSalesOrdersPackingSlipsReadyDocument = gql`
    subscription OnSalesOrdersPackingSlipsReady($ids: [uuid!]!) {
  salesOrders: sales_orders(
    where: {_and: {id: {_in: $ids}, fulfilment_shipments: {status: {_nin: [CANCELLED]}, packing_slip_document_path: {_is_null: false}}}}
  ) {
    id
    fulfilmentShipments: fulfilment_shipments(where: {status: {_nin: [CANCELLED]}}) {
      id
      packingSlipDocumentPath: packing_slip_document_path
    }
  }
}
    `;

/**
 * __useOnSalesOrdersPackingSlipsReadySubscription__
 *
 * To run a query within a React component, call `useOnSalesOrdersPackingSlipsReadySubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnSalesOrdersPackingSlipsReadySubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnSalesOrdersPackingSlipsReadySubscription({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useOnSalesOrdersPackingSlipsReadySubscription(baseOptions: Apollo.SubscriptionHookOptions<OnSalesOrdersPackingSlipsReadySubscription, OnSalesOrdersPackingSlipsReadySubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnSalesOrdersPackingSlipsReadySubscription, OnSalesOrdersPackingSlipsReadySubscriptionVariables>(OnSalesOrdersPackingSlipsReadyDocument, options);
      }
export type OnSalesOrdersPackingSlipsReadySubscriptionHookResult = ReturnType<typeof useOnSalesOrdersPackingSlipsReadySubscription>;
export type OnSalesOrdersPackingSlipsReadySubscriptionResult = Apollo.SubscriptionResult<OnSalesOrdersPackingSlipsReadySubscription>;
export const SalesOrdersCommandDocument = gql`
    mutation SalesOrdersCommand($command: SalesOrdersCommand!, $storeId: uuid!) {
  handleSalesOrdersCommand: command_sales_orders(
    command: $command
    storeId: $storeId
  ) {
    outcome
    error
    url
    result {
      createdSalesOrders {
        salesOrderId
        orderReference
      }
      failedSalesOrders {
        reason
        orderReference
        salesOrderId
      }
    }
  }
}
    `;
export type SalesOrdersCommandMutationFn = Apollo.MutationFunction<SalesOrdersCommandMutation, SalesOrdersCommandMutationVariables>;

/**
 * __useSalesOrdersCommandMutation__
 *
 * To run a mutation, you first call `useSalesOrdersCommandMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSalesOrdersCommandMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [salesOrdersCommandMutation, { data, loading, error }] = useSalesOrdersCommandMutation({
 *   variables: {
 *      command: // value for 'command'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useSalesOrdersCommandMutation(baseOptions?: Apollo.MutationHookOptions<SalesOrdersCommandMutation, SalesOrdersCommandMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SalesOrdersCommandMutation, SalesOrdersCommandMutationVariables>(SalesOrdersCommandDocument, options);
      }
export type SalesOrdersCommandMutationHookResult = ReturnType<typeof useSalesOrdersCommandMutation>;
export type SalesOrdersCommandMutationResult = Apollo.MutationResult<SalesOrdersCommandMutation>;
export type SalesOrdersCommandMutationOptions = Apollo.BaseMutationOptions<SalesOrdersCommandMutation, SalesOrdersCommandMutationVariables>;
export const GetIntegrationSettingsDocument = gql`
    query GetIntegrationSettings($storeId: uuid) {
  shopifyIntegrations: shopify_integrations(
    where: {store_id: {_eq: $storeId}, is_active: {_eq: true}}
  ) {
    ...ShopifyIntegration
  }
}
    ${ShopifyIntegrationFragmentDoc}`;

/**
 * __useGetIntegrationSettingsQuery__
 *
 * To run a query within a React component, call `useGetIntegrationSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetIntegrationSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetIntegrationSettingsQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useGetIntegrationSettingsQuery(baseOptions?: Apollo.QueryHookOptions<GetIntegrationSettingsQuery, GetIntegrationSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetIntegrationSettingsQuery, GetIntegrationSettingsQueryVariables>(GetIntegrationSettingsDocument, options);
      }
export function useGetIntegrationSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetIntegrationSettingsQuery, GetIntegrationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetIntegrationSettingsQuery, GetIntegrationSettingsQueryVariables>(GetIntegrationSettingsDocument, options);
        }
export type GetIntegrationSettingsQueryHookResult = ReturnType<typeof useGetIntegrationSettingsQuery>;
export type GetIntegrationSettingsLazyQueryHookResult = ReturnType<typeof useGetIntegrationSettingsLazyQuery>;
export type GetIntegrationSettingsQueryResult = Apollo.QueryResult<GetIntegrationSettingsQuery, GetIntegrationSettingsQueryVariables>;
export const GetCarrierSelectionPrefDocument = gql`
    query GetCarrierSelectionPref($storeId: uuid) {
  stores(where: {id: {_eq: $storeId}}) {
    id
    carrierSelectionPref: carrier_selection_pref
  }
}
    `;

/**
 * __useGetCarrierSelectionPrefQuery__
 *
 * To run a query within a React component, call `useGetCarrierSelectionPrefQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCarrierSelectionPrefQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCarrierSelectionPrefQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useGetCarrierSelectionPrefQuery(baseOptions?: Apollo.QueryHookOptions<GetCarrierSelectionPrefQuery, GetCarrierSelectionPrefQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCarrierSelectionPrefQuery, GetCarrierSelectionPrefQueryVariables>(GetCarrierSelectionPrefDocument, options);
      }
export function useGetCarrierSelectionPrefLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCarrierSelectionPrefQuery, GetCarrierSelectionPrefQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCarrierSelectionPrefQuery, GetCarrierSelectionPrefQueryVariables>(GetCarrierSelectionPrefDocument, options);
        }
export type GetCarrierSelectionPrefQueryHookResult = ReturnType<typeof useGetCarrierSelectionPrefQuery>;
export type GetCarrierSelectionPrefLazyQueryHookResult = ReturnType<typeof useGetCarrierSelectionPrefLazyQuery>;
export type GetCarrierSelectionPrefQueryResult = Apollo.QueryResult<GetCarrierSelectionPrefQuery, GetCarrierSelectionPrefQueryVariables>;
export const AddShopifyStoreDocument = gql`
    mutation AddShopifyStore($storeId: uuid!, $shopDomain: String!) {
  add_shopify_store(storeId: $storeId, shopDomain: $shopDomain) {
    shopify_integration {
      ...ShopifyIntegration
    }
  }
}
    ${ShopifyIntegrationFragmentDoc}`;
export type AddShopifyStoreMutationFn = Apollo.MutationFunction<AddShopifyStoreMutation, AddShopifyStoreMutationVariables>;

/**
 * __useAddShopifyStoreMutation__
 *
 * To run a mutation, you first call `useAddShopifyStoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddShopifyStoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addShopifyStoreMutation, { data, loading, error }] = useAddShopifyStoreMutation({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      shopDomain: // value for 'shopDomain'
 *   },
 * });
 */
export function useAddShopifyStoreMutation(baseOptions?: Apollo.MutationHookOptions<AddShopifyStoreMutation, AddShopifyStoreMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddShopifyStoreMutation, AddShopifyStoreMutationVariables>(AddShopifyStoreDocument, options);
      }
export type AddShopifyStoreMutationHookResult = ReturnType<typeof useAddShopifyStoreMutation>;
export type AddShopifyStoreMutationResult = Apollo.MutationResult<AddShopifyStoreMutation>;
export type AddShopifyStoreMutationOptions = Apollo.BaseMutationOptions<AddShopifyStoreMutation, AddShopifyStoreMutationVariables>;
export const RemoveShopifyIntegrationDocument = gql`
    mutation RemoveShopifyIntegration($id: uuid!) {
  update_shopify_integrations_by_pk(
    pk_columns: {id: $id}
    _set: {is_active: false}
  ) {
    id
  }
}
    `;
export type RemoveShopifyIntegrationMutationFn = Apollo.MutationFunction<RemoveShopifyIntegrationMutation, RemoveShopifyIntegrationMutationVariables>;

/**
 * __useRemoveShopifyIntegrationMutation__
 *
 * To run a mutation, you first call `useRemoveShopifyIntegrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveShopifyIntegrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeShopifyIntegrationMutation, { data, loading, error }] = useRemoveShopifyIntegrationMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoveShopifyIntegrationMutation(baseOptions?: Apollo.MutationHookOptions<RemoveShopifyIntegrationMutation, RemoveShopifyIntegrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveShopifyIntegrationMutation, RemoveShopifyIntegrationMutationVariables>(RemoveShopifyIntegrationDocument, options);
      }
export type RemoveShopifyIntegrationMutationHookResult = ReturnType<typeof useRemoveShopifyIntegrationMutation>;
export type RemoveShopifyIntegrationMutationResult = Apollo.MutationResult<RemoveShopifyIntegrationMutation>;
export type RemoveShopifyIntegrationMutationOptions = Apollo.BaseMutationOptions<RemoveShopifyIntegrationMutation, RemoveShopifyIntegrationMutationVariables>;
export const SetAutomaticCarrierSelectionDocument = gql`
    mutation SetAutomaticCarrierSelection($storeId: uuid!, $carrierSelectionPref: String!) {
  editStore: edit_store(
    storeId: $storeId
    fields: {carrierSelectionPref: $carrierSelectionPref}
  ) {
    store_id
    success
    errors
  }
}
    `;
export type SetAutomaticCarrierSelectionMutationFn = Apollo.MutationFunction<SetAutomaticCarrierSelectionMutation, SetAutomaticCarrierSelectionMutationVariables>;

/**
 * __useSetAutomaticCarrierSelectionMutation__
 *
 * To run a mutation, you first call `useSetAutomaticCarrierSelectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetAutomaticCarrierSelectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setAutomaticCarrierSelectionMutation, { data, loading, error }] = useSetAutomaticCarrierSelectionMutation({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      carrierSelectionPref: // value for 'carrierSelectionPref'
 *   },
 * });
 */
export function useSetAutomaticCarrierSelectionMutation(baseOptions?: Apollo.MutationHookOptions<SetAutomaticCarrierSelectionMutation, SetAutomaticCarrierSelectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetAutomaticCarrierSelectionMutation, SetAutomaticCarrierSelectionMutationVariables>(SetAutomaticCarrierSelectionDocument, options);
      }
export type SetAutomaticCarrierSelectionMutationHookResult = ReturnType<typeof useSetAutomaticCarrierSelectionMutation>;
export type SetAutomaticCarrierSelectionMutationResult = Apollo.MutationResult<SetAutomaticCarrierSelectionMutation>;
export type SetAutomaticCarrierSelectionMutationOptions = Apollo.BaseMutationOptions<SetAutomaticCarrierSelectionMutation, SetAutomaticCarrierSelectionMutationVariables>;
export const GetLatestShopifyInventorySyncDocument = gql`
    query GetLatestShopifyInventorySync($storeId: uuid!, $shopifyIntegrationId: uuid!) {
  inventorySyncJobs: inventory_sync_jobs(
    where: {store_id: {_eq: $storeId}, integration: {shopify_integration_id: {_eq: $shopifyIntegrationId}}}
    order_by: {created_at: desc}
    limit: 1
  ) {
    ...InventorySyncJob
  }
}
    ${InventorySyncJobFragmentDoc}`;

/**
 * __useGetLatestShopifyInventorySyncQuery__
 *
 * To run a query within a React component, call `useGetLatestShopifyInventorySyncQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLatestShopifyInventorySyncQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLatestShopifyInventorySyncQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      shopifyIntegrationId: // value for 'shopifyIntegrationId'
 *   },
 * });
 */
export function useGetLatestShopifyInventorySyncQuery(baseOptions: Apollo.QueryHookOptions<GetLatestShopifyInventorySyncQuery, GetLatestShopifyInventorySyncQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLatestShopifyInventorySyncQuery, GetLatestShopifyInventorySyncQueryVariables>(GetLatestShopifyInventorySyncDocument, options);
      }
export function useGetLatestShopifyInventorySyncLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLatestShopifyInventorySyncQuery, GetLatestShopifyInventorySyncQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLatestShopifyInventorySyncQuery, GetLatestShopifyInventorySyncQueryVariables>(GetLatestShopifyInventorySyncDocument, options);
        }
export type GetLatestShopifyInventorySyncQueryHookResult = ReturnType<typeof useGetLatestShopifyInventorySyncQuery>;
export type GetLatestShopifyInventorySyncLazyQueryHookResult = ReturnType<typeof useGetLatestShopifyInventorySyncLazyQuery>;
export type GetLatestShopifyInventorySyncQueryResult = Apollo.QueryResult<GetLatestShopifyInventorySyncQuery, GetLatestShopifyInventorySyncQueryVariables>;
export const InitiateShopifyInventorySyncDocument = gql`
    mutation InitiateShopifyInventorySync($storeId: uuid!, $shopifyIntegrationId: uuid!) {
  initiateShopifyInventorySync: initiate_shopify_inventory_sync(
    storeId: $storeId
    shopifyIntegrationId: $shopifyIntegrationId
  ) {
    inventorySyncJobId
    success
    error
  }
}
    `;
export type InitiateShopifyInventorySyncMutationFn = Apollo.MutationFunction<InitiateShopifyInventorySyncMutation, InitiateShopifyInventorySyncMutationVariables>;

/**
 * __useInitiateShopifyInventorySyncMutation__
 *
 * To run a mutation, you first call `useInitiateShopifyInventorySyncMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInitiateShopifyInventorySyncMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [initiateShopifyInventorySyncMutation, { data, loading, error }] = useInitiateShopifyInventorySyncMutation({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      shopifyIntegrationId: // value for 'shopifyIntegrationId'
 *   },
 * });
 */
export function useInitiateShopifyInventorySyncMutation(baseOptions?: Apollo.MutationHookOptions<InitiateShopifyInventorySyncMutation, InitiateShopifyInventorySyncMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InitiateShopifyInventorySyncMutation, InitiateShopifyInventorySyncMutationVariables>(InitiateShopifyInventorySyncDocument, options);
      }
export type InitiateShopifyInventorySyncMutationHookResult = ReturnType<typeof useInitiateShopifyInventorySyncMutation>;
export type InitiateShopifyInventorySyncMutationResult = Apollo.MutationResult<InitiateShopifyInventorySyncMutation>;
export type InitiateShopifyInventorySyncMutationOptions = Apollo.BaseMutationOptions<InitiateShopifyInventorySyncMutation, InitiateShopifyInventorySyncMutationVariables>;
export const SelectShippingRateDocument = gql`
    mutation SelectShippingRate($fulfilmentShipmentId: uuid!, $shippingRateId: uuid!) {
  select_shipping_rate(
    fulfilmentShipmentId: $fulfilmentShipmentId
    shippingRateId: $shippingRateId
  ) {
    success
    errors
    fulfilment_shipment {
      id
      selected_rate_id
      selected_shipping_rate {
        ...ShippingRate
      }
    }
  }
}
    ${ShippingRateFragmentDoc}`;
export type SelectShippingRateMutationFn = Apollo.MutationFunction<SelectShippingRateMutation, SelectShippingRateMutationVariables>;

/**
 * __useSelectShippingRateMutation__
 *
 * To run a mutation, you first call `useSelectShippingRateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSelectShippingRateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [selectShippingRateMutation, { data, loading, error }] = useSelectShippingRateMutation({
 *   variables: {
 *      fulfilmentShipmentId: // value for 'fulfilmentShipmentId'
 *      shippingRateId: // value for 'shippingRateId'
 *   },
 * });
 */
export function useSelectShippingRateMutation(baseOptions?: Apollo.MutationHookOptions<SelectShippingRateMutation, SelectShippingRateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SelectShippingRateMutation, SelectShippingRateMutationVariables>(SelectShippingRateDocument, options);
      }
export type SelectShippingRateMutationHookResult = ReturnType<typeof useSelectShippingRateMutation>;
export type SelectShippingRateMutationResult = Apollo.MutationResult<SelectShippingRateMutation>;
export type SelectShippingRateMutationOptions = Apollo.BaseMutationOptions<SelectShippingRateMutation, SelectShippingRateMutationVariables>;
export const GetStoreSettingsDocument = gql`
    query GetStoreSettings($storeId: uuid) {
  storeSettings: store_setting(where: {store_id: {_eq: $storeId}}) {
    key
    value
  }
}
    `;

/**
 * __useGetStoreSettingsQuery__
 *
 * To run a query within a React component, call `useGetStoreSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStoreSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStoreSettingsQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useGetStoreSettingsQuery(baseOptions?: Apollo.QueryHookOptions<GetStoreSettingsQuery, GetStoreSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStoreSettingsQuery, GetStoreSettingsQueryVariables>(GetStoreSettingsDocument, options);
      }
export function useGetStoreSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStoreSettingsQuery, GetStoreSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStoreSettingsQuery, GetStoreSettingsQueryVariables>(GetStoreSettingsDocument, options);
        }
export type GetStoreSettingsQueryHookResult = ReturnType<typeof useGetStoreSettingsQuery>;
export type GetStoreSettingsLazyQueryHookResult = ReturnType<typeof useGetStoreSettingsLazyQuery>;
export type GetStoreSettingsQueryResult = Apollo.QueryResult<GetStoreSettingsQuery, GetStoreSettingsQueryVariables>;
export const ReplaceFulfilmentShipmentParcelsDocument = gql`
    mutation ReplaceFulfilmentShipmentParcels($parcels: [FulfilmentShipmentParcelInput!]!) {
  replace_fulfilment_shipment_parcels(parcels: $parcels) {
    success
    errors
    fulfilment_shipment {
      id
      fulfilmentShipmentParcels: fulfilment_shipment_parcels {
        ...SalesOrderFulfilmentShipmentParcel
      }
    }
  }
}
    ${SalesOrderFulfilmentShipmentParcelFragmentDoc}`;
export type ReplaceFulfilmentShipmentParcelsMutationFn = Apollo.MutationFunction<ReplaceFulfilmentShipmentParcelsMutation, ReplaceFulfilmentShipmentParcelsMutationVariables>;

/**
 * __useReplaceFulfilmentShipmentParcelsMutation__
 *
 * To run a mutation, you first call `useReplaceFulfilmentShipmentParcelsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReplaceFulfilmentShipmentParcelsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [replaceFulfilmentShipmentParcelsMutation, { data, loading, error }] = useReplaceFulfilmentShipmentParcelsMutation({
 *   variables: {
 *      parcels: // value for 'parcels'
 *   },
 * });
 */
export function useReplaceFulfilmentShipmentParcelsMutation(baseOptions?: Apollo.MutationHookOptions<ReplaceFulfilmentShipmentParcelsMutation, ReplaceFulfilmentShipmentParcelsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReplaceFulfilmentShipmentParcelsMutation, ReplaceFulfilmentShipmentParcelsMutationVariables>(ReplaceFulfilmentShipmentParcelsDocument, options);
      }
export type ReplaceFulfilmentShipmentParcelsMutationHookResult = ReturnType<typeof useReplaceFulfilmentShipmentParcelsMutation>;
export type ReplaceFulfilmentShipmentParcelsMutationResult = Apollo.MutationResult<ReplaceFulfilmentShipmentParcelsMutation>;
export type ReplaceFulfilmentShipmentParcelsMutationOptions = Apollo.BaseMutationOptions<ReplaceFulfilmentShipmentParcelsMutation, ReplaceFulfilmentShipmentParcelsMutationVariables>;

      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {}
};
      export default result;
    
export const Operations = {
  Query: {
    GetStockTransfers: 'GetStockTransfers' as const,
    SearchProducts: 'SearchProducts' as const,
    GetIndividualStockTransfer: 'GetIndividualStockTransfer' as const,
    GetInitialApplicationData: 'GetInitialApplicationData' as const,
    GetInitialStoreData: 'GetInitialStoreData' as const,
    GetCarrierSettings: 'GetCarrierSettings' as const,
    GetFulfilmentAtlSettings: 'GetFulfilmentAtlSettings' as const,
    GetUnmanifestedLabels: 'GetUnmanifestedLabels' as const,
    GetManifestsForPeriod: 'GetManifestsForPeriod' as const,
    GetParcelTypes: 'GetParcelTypes' as const,
    GetTags: 'GetTags' as const,
    GetDetailsForBulkBooking: 'GetDetailsForBulkBooking' as const,
    GetDetailsForBulkCancelling: 'GetDetailsForBulkCancelling' as const,
    GetSalesOrderWithFulfilmentShipments: 'GetSalesOrderWithFulfilmentShipments' as const,
    GetSalesOrdersWithFulfilmentShipments: 'GetSalesOrdersWithFulfilmentShipments' as const,
    SalesOrderTabCounts: 'SalesOrderTabCounts' as const,
    GetOrderDetailsForBulkBookingByIds: 'GetOrderDetailsForBulkBookingByIds' as const,
    GetOrderDetailsForBulkCancellingByIds: 'GetOrderDetailsForBulkCancellingByIds' as const,
    GetSalesOrdersByIds: 'GetSalesOrdersByIds' as const,
    GetIntegrationSettings: 'GetIntegrationSettings' as const,
    GetCarrierSelectionPref: 'GetCarrierSelectionPref' as const,
    GetLatestShopifyInventorySync: 'GetLatestShopifyInventorySync' as const,
    GetStoreSettings: 'GetStoreSettings' as const
  },
  Mutation: {
    StockTransferCommand: 'StockTransferCommand' as const,
    CarrierSettingCommand: 'CarrierSettingCommand' as const,
    EditAddress: 'EditAddress' as const,
    FulfilmentShipmentCommand: 'FulfilmentShipmentCommand' as const,
    CreateManifests: 'CreateManifests' as const,
    AddParcelTypes: 'AddParcelTypes' as const,
    EditParcelTypeById: 'EditParcelTypeById' as const,
    DeleteParcelTypesByIds: 'DeleteParcelTypesByIds' as const,
    SyncSalesOrder: 'SyncSalesOrder' as const,
    PackLineItems: 'PackLineItems' as const,
    SalesOrderCommand: 'SalesOrderCommand' as const,
    SalesOrdersCommand: 'SalesOrdersCommand' as const,
    AddShopifyStore: 'AddShopifyStore' as const,
    RemoveShopifyIntegration: 'RemoveShopifyIntegration' as const,
    SetAutomaticCarrierSelection: 'SetAutomaticCarrierSelection' as const,
    InitiateShopifyInventorySync: 'InitiateShopifyInventorySync' as const,
    SelectShippingRate: 'SelectShippingRate' as const,
    ReplaceFulfilmentShipmentParcels: 'ReplaceFulfilmentShipmentParcels' as const
  },
  Subscription: {
    OnStockTransferUpdate: 'OnStockTransferUpdate' as const,
    OnInventorySyncJobUpdate: 'OnInventorySyncJobUpdate' as const,
    OnSalesOrderRatesUpdated: 'OnSalesOrderRatesUpdated' as const,
    OnSalesOrderTrackingDataUpdated: 'OnSalesOrderTrackingDataUpdated' as const,
    OnSalesOrderUpdated: 'OnSalesOrderUpdated' as const,
    OnSalesOrdersWithFulfilmentShipmentsUpdated: 'OnSalesOrdersWithFulfilmentShipmentsUpdated' as const,
    OnSalesOrdersWithFulfilmentShipmentsCountUpdated: 'OnSalesOrdersWithFulfilmentShipmentsCountUpdated' as const,
    OnSalesOrderTabCountsUpdated: 'OnSalesOrderTabCountsUpdated' as const,
    OnSalesOrdersPackingSlipsReady: 'OnSalesOrdersPackingSlipsReady' as const
  },
  Fragment: {
    StockTransferItemWithProductInfo: 'StockTransferItemWithProductInfo' as const,
    Address: 'Address' as const,
    StockTransferShipment: 'StockTransferShipment' as const,
    StockTransfer: 'StockTransfer' as const,
    SearchProductsRetailUnits: 'SearchProductsRetailUnits' as const,
    UserWithStores: 'UserWithStores' as const,
    User: 'User' as const,
    UserWithOrgAndStoreIds: 'UserWithOrgAndStoreIds' as const,
    Location: 'Location' as const,
    Store: 'Store' as const,
    FulfilmentShipmentParcel: 'FulfilmentShipmentParcel' as const,
    FulfilmentShipmentLineItem: 'FulfilmentShipmentLineItem' as const,
    FulfilmentShipment: 'FulfilmentShipment' as const,
    FulfilmentShipmentSubscription: 'FulfilmentShipmentSubscription' as const,
    UnmanifestedLabel: 'UnmanifestedLabel' as const,
    Manifest: 'Manifest' as const,
    CompleteParcelType: 'CompleteParcelType' as const,
    SalesOrderWithUncancelledShipment: 'SalesOrderWithUncancelledShipment' as const,
    SalesOrderFulfilmentShipmentParcel: 'SalesOrderFulfilmentShipmentParcel' as const,
    DraftFulfilmentShipmentWithRates: 'DraftFulfilmentShipmentWithRates' as const,
    SalesOrderDraftFulfilmentShipmentWithRates: 'SalesOrderDraftFulfilmentShipmentWithRates' as const,
    RateRequest: 'RateRequest' as const,
    SalesOrderWithUncancelledShipmentListing: 'SalesOrderWithUncancelledShipmentListing' as const,
    BulkActionFulfilmentShipment: 'BulkActionFulfilmentShipment' as const,
    FulfilmentShipmentCount: 'FulfilmentShipmentCount' as const,
    SalesOrderLineItem: 'SalesOrderLineItem' as const,
    ShippingAddress: 'ShippingAddress' as const,
    SalesOrderShipmentCharge: 'SalesOrderShipmentCharge' as const,
    SalesOrderWithShipments: 'SalesOrderWithShipments' as const,
    SalesOrderWithFulfilmentShipmentsSubscription: 'SalesOrderWithFulfilmentShipmentsSubscription' as const,
    ShopifyIntegration: 'ShopifyIntegration' as const,
    InventorySyncJob: 'InventorySyncJob' as const,
    ShippingRate: 'ShippingRate' as const
  }
}